<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸ƒæ—å¸¦ç­–ç•¥ç³»ç»Ÿ</title>
    <!-- Chart.js å›¾è¡¨åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            position: relative;
            overflow-x: hidden;
        }
        
        /* åŠ¨æ€èƒŒæ™¯æ ·å¼ */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            overflow: hidden;
            display: none; /* é»˜è®¤éšè—åŠ¨ç”»èƒŒæ™¯ */
        }
        
        /* æ·»åŠ æ˜Ÿæ˜Ÿæ•ˆæœ */
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.4);
        }
        
        .star:nth-child(1) {
            top: 15%;
            left: 20%;
            animation-delay: 0s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(2) {
            top: 25%;
            right: 15%;
            animation-delay: 0.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(3) {
            top: 45%;
            left: 10%;
            animation-delay: 1s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(4) {
            top: 35%;
            right: 25%;
            animation-delay: 1.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(5) {
            top: 65%;
            left: 30%;
            animation-delay: 2s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(6) {
            top: 55%;
            right: 40%;
            animation-delay: 2.5s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(7) {
            top: 75%;
            left: 60%;
            animation-delay: 3s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(8) {
            top: 85%;
            right: 20%;
            animation-delay: 3.5s;
            width: 3px;
            height: 3px;
        }
        
        @keyframes twinkle {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.3);
            }
        }
        

        
        /* è§†é¢‘èƒŒæ™¯æ ·å¼ */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            object-fit: cover;
            opacity: 0.8;
            display: block; /* é»˜è®¤æ˜¾ç¤ºè§†é¢‘èƒŒæ™¯ */
            filter: blur(2px);
        }
        
        .video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
            z-index: -2;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: transparent; 
            padding: 20px;
            border-radius: 15px;
            position: relative;
            z-index: 1;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .help-text {
            background: rgba(0, 0, 0, 0.1);
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 5px 5px 0;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .tab {
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: transparent;
            border-radius: 0 0 5px 5px;
            color: white;
        }
        .tab-content.active {
            display: block;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        
        /* è¶…çŸ­äº¤æ˜“è¯¦æƒ…æ ·å¼ */
        .signal-details {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 5px;
            border-left: 3px solid #007bff;
        }
        
        .detail-item label {
            font-weight: bold;
            color: #ccc;
        }
        
        .detail-item span {
            color: #fff;
            font-weight: bold;
        }
        
        .trading-signals {
            margin-bottom: 20px;
        }
        
        .signal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .signal-item:last-child {
            border-bottom: none;
        }
        
        .signal-label {
            color: #ccc;
            font-weight: bold;
        }
        
        .signal-value {
            color: #fff;
            font-weight: bold;
        }
        
        .strategy-explanation {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #28a745;
        }
        
        .strategy-explanation h6 {
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .strategy-explanation p {
            margin: 8px 0;
            color: #ccc;
            line-height: 1.5;
        }
        
        /* æ—¥å¿—è¯Šæ–­æ ·å¼ */
        .logs-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            max-height: 600px;
            overflow: hidden;
        }
        
        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .log-count {
            color: #007bff;
            font-size: 14px;
            font-weight: normal;
        }
        
        .log-controls {
            display: flex;
            gap: 15px;
        }
        
        .log-controls label {
            color: #ccc;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .logs-content {
            background: #0a0a0a;
            border-radius: 5px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px 8px;
            border-radius: 3px;
            border-left: 3px solid #333;
            word-wrap: break-word;
        }
        
        .log-entry.info {
            border-left-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }
        
        .log-entry.warning {
            border-left-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .log-entry.error {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .log-time {
            color: #888;
            font-size: 11px;
            margin-right: 10px;
        }
        
        .log-level {
            color: #fff;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            display: inline-block;
        }
        
        .log-message {
            color: #ccc;
        }
        
        .log-entry.info .log-level {
            color: #007bff;
        }
        
        .log-entry.warning .log-level {
            color: #ffc107;
        }
        
        .log-entry.error .log-level {
            color: #dc3545;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-warning:hover {
            background: #e0a800;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.1);
            color: white;
        }
        .results-container {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 15px;
            background: transparent;
            color: white;
        }
        .result-item {
            background: transparent;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
            color: white;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background: rgba(40, 167, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .status.error {
            background: rgba(220, 53, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .position-item {
            background: transparent;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
        }
        .order-item {
            background: transparent;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: transparent;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
                .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .stat-label {
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* è¡¨æ ¼æ ·å¼ */
         .table-container {
             overflow-x: auto;
             margin-top: 15px;
         }
         
                                                                                                                                                                                                                               .analysis-table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            color: white;
            border-radius: 8px;
            overflow: hidden;
        }
         
         .analysis-table th,
         .analysis-table td {
             padding: 12px 8px;
             text-align: left;
             border-bottom: 1px solid #e9ecef;
         }
         
                                                                                                                                                                                                                               .analysis-table th {
            background: transparent;
            font-weight: bold;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 10;
            padding: 15px 12px;
        }
         
                           .analysis-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
                                   .analysis-table tr:nth-child(even) {
              background: transparent;
          }
         
         /* ç­›é€‰æ§åˆ¶æ ·å¼ */
                                                                                                                                                                                                                               .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            flex-wrap: wrap;
            color: white;
        }
         
         .filter-group {
             display: flex;
             align-items: center;
             gap: 8px;
         }
         
         .filter-group label {
             font-weight: bold;
             margin: 0;
             white-space: nowrap;
         }
         
                                                                               .filter-group select,
            .filter-group input {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
         .filter-group button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .filter-group button:hover {
             background: #0056b3;
         }
         
         /* åˆ†é¡µæ§åˆ¶æ ·å¼ */
                                                                                                                                                                                                                               .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            color: white;
        }
         
         .pagination-controls button {
             padding: 8px 15px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .pagination-controls button:hover {
             background: #0056b3;
         }
         
         .pagination-controls button:disabled {
             background: #6c757d;
             cursor: not-allowed;
         }
         
                                                                               .pagination-controls select {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
                 #pageInfo {
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* çŠ¶æ€æ ‡ç­¾æ ·å¼ */
         .status-badge {
             padding: 4px 8px;
             border-radius: 12px;
             font-size: 12px;
             font-weight: bold;
             text-align: center;
         }
         
         .status-buy {
             background: #d4edda;
             color: #155724;
         }
         
         .status-sell {
             background: #f8d7da;
             color: #721c24;
         }
         
         .status-hold {
             background: #fff3cd;
             color: #856404;
         }
         
         /* æ“ä½œæŒ‰é’®æ ·å¼ */
         .action-btn {
             padding: 4px 8px;
             margin: 2px;
             border: none;
             border-radius: 3px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .action-btn-buy {
             background: #28a745;
             color: white;
         }
         
         .action-btn-sell {
             background: #dc3545;
             color: white;
         }
         
         /* æ¨¡æ€å¯¹è¯æ¡†æ ·å¼ */
         .modal {
             display: none;
             position: fixed;
             z-index: 1000;
             left: 0;
             top: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.7);
             backdrop-filter: blur(5px);
         }
         
         .modal-content {
             background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
             margin: 5% auto;
             padding: 30px;
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: 15px;
             width: 80%;
             max-width: 500px;
             color: white;
             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
         }
         
         .modal-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px solid rgba(255, 255, 255, 0.3);
         }
         
         .modal-title {
             font-size: 20px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .close {
             color: rgba(255, 255, 255, 0.7);
             font-size: 28px;
             font-weight: bold;
             cursor: pointer;
             transition: color 0.3s;
         }
         
         .close:hover {
             color: white;
         }
         
         .modal-body {
             margin-bottom: 20px;
         }
         
         .modal-footer {
             display: flex;
             justify-content: flex-end;
             gap: 10px;
         }
         
         /* å›¾è¡¨å®¹å™¨æ ·å¼ */
         .chart-container {
             margin-top: 20px;
             padding: 20px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 10px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .chart-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 15px;
             color: white;
         }
         
         .chart-title {
             font-size: 18px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .chart-controls {
             display: flex;
             gap: 10px;
             align-items: center;
         }
         
         .chart-controls button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .chart-controls button:hover {
             background: #0056b3;
         }
         
         .chart-controls button.active {
             background: #28a745;
         }
         
         .chart-controls select {
             padding: 6px 10px;
             border: 1px solid rgba(255, 255, 255, 0.5);
             border-radius: 4px;
             background: rgba(0, 0, 0, 0.1);
             color: white;
             font-size: 12px;
         }
         
         .chart-wrapper {
             position: relative;
             height: 400px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             padding: 10px;
         }
         
         .chart-legend {
             display: flex;
             flex-wrap: wrap;
             gap: 15px;
             margin-top: 10px;
             padding: 10px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 5px;
         }
         
         .legend-item {
             display: flex;
             align-items: center;
             gap: 5px;
             font-size: 12px;
             color: white;
         }
         
         .legend-color {
             width: 12px;
             height: 2px;
             border-radius: 1px;
         }
         
         /* äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿æ ·å¼ */
         .cross-points-panel {
             margin-top: 15px;
             padding: 15px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .cross-points-panel h4 {
             color: white;
             margin: 0 0 15px 0;
             font-size: 16px;
         }
         
         .cross-points-tabs {
             display: flex;
             gap: 10px;
             margin-bottom: 15px;
         }
         
         .cross-tab {
             padding: 8px 16px;
             background: rgba(255, 255, 255, 0.1);
             color: white;
             border: 1px solid rgba(255, 255, 255, 0.2);
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .cross-tab:hover {
             background: rgba(255, 255, 255, 0.2);
         }
         
         .cross-tab.active {
             background: #007bff;
             border-color: #007bff;
         }
         
         .cross-tab-content {
             display: none;
         }
         
         .cross-tab-content.active {
             display: block;
         }
         
         .cross-points-list {
             max-height: 200px;
             overflow-y: auto;
         }
         
         .cross-point-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 8px 12px;
             margin-bottom: 8px;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 4px;
             border-left: 3px solid;
             font-size: 12px;
         }
         
         .cross-point-item.golden-cross {
             border-left-color: #00ff00;
         }
         
         .cross-point-item.death-cross {
             border-left-color: #ff0000;
         }
         
         .cross-point-info {
             color: white;
         }
         
         .cross-point-price {
             font-weight: bold;
             color: #ffd700;
         }
         
         .cross-point-time {
             color: #ccc;
             font-size: 11px;
         }
    </style>
</head>
<body>
    <!-- åŠ¨æ€èƒŒæ™¯ -->
    <div class="animated-background">
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
    </div>
    
    <!-- è§†é¢‘èƒŒæ™¯ -->
    <video class="video-background" autoplay muted loop playsinline>
        <source src="/static/videos/background.mp4" type="video/mp4">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ ‡ç­¾ã€‚
    </video>
    <div class="video-overlay"></div>
    
    <div class="container">
        <div class="header">
            <h1>å¸ƒæ—å¸¦ç­–ç•¥æŒ‚å•ç³»ç»Ÿ</h1>
            <p>åŸºäºå¸ƒæ—å¸¦æŠ€æœ¯æŒ‡æ ‡çš„æ™ºèƒ½åŠ å¯†è´§å¸åˆ†æç³»ç»Ÿ</p>
        </div>
        
        <div class="help-text">
                            <strong>ç³»ç»Ÿè¯´æ˜ï¼š</strong>æœ¬ç³»ç»ŸåŸºäºå¸ƒæ—å¸¦æŠ€æœ¯æŒ‡æ ‡åˆ†æåŠ å¯†è´§å¸ä»·æ ¼èµ°åŠ¿ï¼Œæä¾›æ™ºèƒ½æŒ‚å•å»ºè®®ã€‚æ”¯æŒ<span id="totalSymbolsDisplay">130</span>ä¸ªå¸ç§ã€å¤šæ—¶é—´å‘¨æœŸã€å¤šäº¤æ˜“æ‰€æ•°æ®æºã€æŒä»“ç®¡ç†ç­‰åŠŸèƒ½ã€‚
        </div>

        <!-- ç³»ç»Ÿç»Ÿè®¡ -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="totalSymbols">130</div>
                <div class="stat-label">æ”¯æŒå¸ç§</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="analyzedCount">0</div>
                <div class="stat-label">å·²åˆ†æ</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="activeOrders">0</div>
                <div class="stat-label">æ´»è·ƒæŒ‚å•</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="totalPositions">0</div>
                <div class="stat-label">æŒä»“æ•°é‡</div>
            </div>
        </div>

        <!-- Tabå¯¼èˆª -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('analysis')">ğŸ“Š å¸ç§åˆ†æ</button>
            <button class="tab" onclick="showTab('intraday')">âš¡ æ—¥å†…äº¤æ˜“</button>
            <button class="tab" onclick="showTab('ultraShort')">ğŸš€ æ—¥å†…è¶…çŸ­</button>
            <button class="tab" onclick="showTab('logs')">ğŸ” æ—¥å¿—è¯Šæ–­</button>
            <button class="tab" onclick="showTab('orders')">ğŸ“‹ æŒ‚å•ç®¡ç†</button>
            <button class="tab" onclick="showTab('positions')">ğŸ’° åˆ†æ‰¹ä»“ä½</button>
            <button class="tab" onclick="showTab('management')">âš™ï¸ ç³»ç»Ÿç®¡ç†</button>
        </div>

        <!-- å¸ç§åˆ†æTab -->
        <div id="analysis" class="tab-content active">
            <h3>å¸ç§åˆ†æ</h3>
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeDefault()">åˆ†æå…¨éƒ¨<span id="analyzeButtonCount">130</span>ä¸ªå¸ç§</button>
                <button class="btn btn-info" onclick="showAddSymbolModal()">â• æ–°å¢å¸ç§</button>
                <button class="btn btn-warning" onclick="analyzeCustom()">åˆ†æè‡ªå®šä¹‰å¸ç§</button>
                <button class="btn" onclick="getSymbols()">è·å–å¸ç§åˆ—è¡¨</button>
            </div>
            <div class="form-group">
                <label>è‡ªå®šä¹‰å¸ç§ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼š</label>
                <textarea class="form-control" id="symbolsInput" rows="3" placeholder="ä¾‹å¦‚: BTC, ETH, ADA, DOT"></textarea>
            </div>
            <div class="form-group">
                <label><input type="checkbox" id="forceRefresh"> å¼ºåˆ¶åˆ·æ–°æ•°æ®</label>
            </div>
            <div id="analysisResults" class="results-container" style="display: none;">
                <h4>åˆ†æç»“æœ</h4>
                
                <!-- ç­›é€‰å’Œæ’åºæ§åˆ¶ -->
                <div class="filter-controls">
                    <div class="filter-group">
                        <label>æ—¶é—´çº§åˆ«:</label>
                        <select id="timeframeFilter" onchange="filterResults()">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="12h">12å°æ—¶</option>
                            <option value="1d">1å¤©</option>
                            <option value="3d">3å¤©</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>æ’åº:</label>
                        <select id="sortBy" onchange="sortResults()">
                            <option value="symbol">å¸ç§</option>
                            <option value="price">å½“å‰ä»·æ ¼</option>
                            <option value="orderPrice">æŒ‚å•ä»·æ ¼</option>
                            <option value="timeframe">æ—¶é—´çº§åˆ«</option>
                        </select>
                        <button id="sortOrder" onclick="toggleSortOrder()">â†‘</button>
                    </div>
                    <div class="filter-group">
                        <label>æœç´¢:</label>
                        <input type="text" id="searchSymbol" placeholder="æœç´¢å¸ç§..." onkeyup="filterResults()">
                    </div>
                </div>
                
                <!-- åˆ†é¡µæ§åˆ¶ -->
                <div class="pagination-controls">
                    <button onclick="changePage(-1)" id="prevPage">ä¸Šä¸€é¡µ</button>
                    <span id="pageInfo">ç¬¬ 1 é¡µï¼Œå…± 1 é¡µ</span>
                    <button onclick="changePage(1)" id="nextPage">ä¸‹ä¸€é¡µ</button>
                    <select id="pageSize" onchange="changePageSize()">
                        <option value="20">20æ¡/é¡µ</option>
                        <option value="50">50æ¡/é¡µ</option>
                        <option value="100">100æ¡/é¡µ</option>
                    </select>
                </div>
                
                <!-- ç»“æœè¡¨æ ¼ -->
                <div class="table-container">
                    <table id="analysisTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>å¸ç§</th>
                                <th>å½“å‰ä»·æ ¼</th>
                                <th>æŒ‚å•ä»·æ ¼</th>
                                <th>æ—¶é—´çº§åˆ«</th>
                                <th>çŠ¶æ€</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="analysisTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- æ—¥å†…äº¤æ˜“Tab -->
        <div id="intraday" class="tab-content">
            <h3>âš¡ æ—¥å†…äº¤æ˜“ä¿¡å·</h3>
            <div class="help-text">
                <strong>æ—¥å†…äº¤æ˜“è¯´æ˜ï¼š</strong>åŸºäº365å‘¨æœŸEMA/MAé”šç‚¹ç­–ç•¥ï¼Œä»·æ ¼åœ¨é”šç‚¹ä¸Šæ–¹ä¸ºå¤šå¤´ä¿¡å·ï¼Œä¸‹æ–¹ä¸ºç©ºå¤´ä¿¡å·ã€‚ä¼˜å…ˆæ˜¾ç¤º15åˆ†é’Ÿå’Œ1å°æ—¶ä¿¡å·ã€‚
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeIntradaySymbols()">åˆ†æä¸»è¦å¸ç§</button>
                <button class="btn btn-info" onclick="analyzeIntradayCustom()">åˆ†æè‡ªå®šä¹‰å¸ç§</button>
                <button class="btn btn-warning" onclick="getIntradaySignals()">è·å–ä¿¡å·æ±‡æ€»</button>
                <button class="btn btn-secondary" onclick="clearIntradayCache()">æ¸…é™¤ç¼“å­˜</button>
            </div>
            
            <div class="form-group">
                <label>è‡ªå®šä¹‰å¸ç§ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼š</label>
                <textarea class="form-control" id="intradaySymbolsInput" rows="2" placeholder="ä¾‹å¦‚: BTC, ETH, SOL, ADA"></textarea>
            </div>
            
            <div class="form-group">
                <label><input type="checkbox" id="intradayForceRefresh"> å¼ºåˆ¶åˆ·æ–°æ•°æ®</label>
            </div>
            
            <!-- ä¿¡å·æ±‡æ€»åŒºåŸŸ -->
            <div id="intradaySignals" class="results-container" style="display: none;">
                <h4>ä¿¡å·æ±‡æ€»ï¼ˆ15m + 1hï¼‰</h4>
                <div class="table-container">
                    <table id="intradaySignalsTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>å¸ç§</th>
                                <th>ç»¼åˆä¿¡å·</th>
                                <th>15åˆ†é’Ÿ</th>
                                <th>1å°æ—¶</th>
                                <th>ä¸€è‡´æ€§</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="intradaySignalsTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- è¯¦ç»†åˆ†æåŒºåŸŸ -->
            <div id="intradayDetails" class="results-container" style="display: none;">
                <h4>è¯¦ç»†åˆ†æç»“æœ</h4>
                
                <!-- ç­›é€‰æ§åˆ¶ -->
                <div class="filter-controls">
                    <div class="filter-group">
                        <label>æ—¶é—´å‘¨æœŸ:</label>
                        <select id="intradayTimeframeFilter" onchange="filterIntradayResults()">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="1m">1åˆ†é’Ÿ</option>
                            <option value="3m">3åˆ†é’Ÿ</option>
                            <option value="15m">15åˆ†é’Ÿ</option>
                            <option value="1h">1å°æ—¶</option>
                            <option value="2h">2å°æ—¶</option>
                            <option value="4h">4å°æ—¶</option>
                            <option value="6h">6å°æ—¶</option>
                            <option value="8h">8å°æ—¶</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>ä¿¡å·ç±»å‹:</label>
                        <select id="intradaySignalFilter" onchange="filterIntradayResults()">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="long">å¤šå¤´</option>
                            <option value="short">ç©ºå¤´</option>
                            <option value="mixed">æ··åˆ</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>æœç´¢:</label>
                        <input type="text" id="intradaySearchSymbol" placeholder="æœç´¢å¸ç§..." onkeyup="filterIntradayResults()">
                    </div>
                </div>
                
                <!-- è¯¦ç»†ç»“æœè¡¨æ ¼ -->
                <div class="table-container">
                    <table id="intradayDetailsTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>å¸ç§</th>
                                <th>æ—¶é—´å‘¨æœŸ</th>
                                <th>å½“å‰ä»·æ ¼</th>
                                <th>EMA365</th>
                                <th>MA365</th>
                                <th>é”šç‚¹</th>
                                <th>ä¿¡å·</th>
                                <th>å¼ºåº¦</th>
                                <th>åç¦»åº¦</th>
                            </tr>
                        </thead>
                        <tbody id="intradayDetailsTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- å›¾è¡¨åŒºåŸŸ -->
            <div id="chartSection" class="chart-container" style="display: none;">
                <div class="chart-header">
                    <div class="chart-title">ğŸ“ˆ EMAå¤šæ—¶é—´å‘¨æœŸå›¾è¡¨</div>
                    <div class="chart-controls">
                        <select id="chartSymbolSelect" onchange="updateChartSymbol()">
                            <option value="">é€‰æ‹©å¸ç§</option>
                        </select>
                        <select id="chartTimeframeSelect" onchange="updateChartTimeframe()">
                            <option value="5m">5åˆ†é’Ÿ</option>
                            <option value="15m">15åˆ†é’Ÿ</option>
                            <option value="1h">1å°æ—¶</option>
                        </select>
                        <button onclick="refreshChart()">ğŸ”„ åˆ·æ–°</button>
                        <button onclick="toggleChartVisibility()">ğŸ‘ï¸ æ˜¾ç¤º/éšè—</button>
                    </div>
                </div>
                
                <div class="chart-wrapper">
                    <canvas id="emaChart"></canvas>
                </div>
                
                <div class="chart-legend" id="chartLegend">
                    <!-- å›¾ä¾‹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
                
                <!-- äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿ -->
                <div class="cross-points-panel" id="crossPointsPanel" style="display: none;">
                    <h4>ğŸ¯ äº¤å‰ç‚¹ä½ä¿¡æ¯</h4>
                    <div class="cross-points-tabs">
                        <button class="cross-tab active" onclick="showCrossTab('price')">ä»·æ ¼äº¤å‰</button>
                        <button class="cross-tab" onclick="showCrossTab('indicator')">å‡çº¿äº¤å‰</button>
                    </div>
                    <div class="cross-points-content">
                        <div id="priceCrossPoints" class="cross-tab-content active">
                            <div class="cross-points-list" id="priceCrossList">
                                <!-- ä»·æ ¼äº¤å‰ç‚¹åˆ—è¡¨ -->
                            </div>
                        </div>
                        <div id="indicatorCrossPoints" class="cross-tab-content">
                            <div class="cross-points-list" id="indicatorCrossList">
                                <!-- å‡çº¿äº¤å‰ç‚¹åˆ—è¡¨ -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ—¥å†…è¶…çŸ­äº¤æ˜“Tab -->
        <div id="ultraShort" class="tab-content">
            <h3>ğŸš€ æ—¥å†…è¶…çŸ­äº¤æ˜“ç­–ç•¥</h3>
            <div class="help-text">
                <strong>è¶…çŸ­ç­–ç•¥è¯´æ˜ï¼š</strong>åŸºäº1å°æ—¶EMA365/MA365åŒºé—´çªç ´ï¼Œåœ¨åŒºé—´ä¸Šæ²¿åšç©ºï¼Œæ­¢ç›ˆç›®æ ‡ä¸º1åˆ†é’ŸEMA233ã€‚é€‚ç”¨äºå¿«é€Ÿè¿›å‡ºåœºäº¤æ˜“ã€‚
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeUltraShortSymbols()">åˆ†æè¶…çŸ­æœºä¼š (å¸å®‰å‰200)</button>
                <button class="btn btn-info" onclick="analyzeUltraShortCustom()">åˆ†æè‡ªå®šä¹‰å¸ç§</button>
                <button class="btn btn-secondary" onclick="getTopSymbols()">è·å–å¸ç§åˆ—è¡¨</button>
                <button class="btn btn-primary" onclick="validateSymbol()">éªŒè¯å¸ç§</button>
                <button class="btn btn-warning" onclick="clearUltraShortCache()">æ¸…é™¤ç¼“å­˜</button>
            </div>
            
            <div class="form-group">
                <label for="ultraShortSymbolsInput">è‡ªå®šä¹‰å¸ç§ (ç”¨é€—å·åˆ†éš”):</label>
                <input type="text" id="ultraShortSymbolsInput" placeholder="ä¾‹å¦‚: ETH, BTC, SOL" class="form-control">
            </div>
            
            <!-- è¶…çŸ­äº¤æ˜“ä¿¡å·è¡¨æ ¼ -->
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>å¸ç§</th>
                            <th>1håŒºé—´</th>
                            <th>å½“å‰ä»·æ ¼</th>
                            <th>äº¤æ˜“æœºä¼š</th>
                            <th>å…¥åœºä»·æ ¼</th>
                            <th>æ­¢ç›ˆç›®æ ‡</th>
                            <th>é£é™©æ”¶ç›Šæ¯”</th>
                            <th>æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="ultraShortSignalsTableBody">
                        <tr>
                            <td colspan="8" style="text-align: center; color: #666;">æš‚æ— è¶…çŸ­äº¤æ˜“ä¿¡å·</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- è¶…çŸ­äº¤æ˜“è¯¦æƒ… -->
            <div id="ultraShortDetails" class="details-container" style="display: none;">
                <h4>è¶…çŸ­äº¤æ˜“è¯¦æƒ…</h4>
                <div id="ultraShortDetailsContent"></div>
            </div>
        </div>

        <!-- æ—¥å¿—è¯Šæ–­Tab -->
        <div id="logs" class="tab-content">
            <h3>ğŸ” æ—¥å¿—è¯Šæ–­</h3>
            <div class="help-text">
                <strong>æ—¥å¿—è¯Šæ–­è¯´æ˜ï¼š</strong>å®æ—¶æ˜¾ç¤ºç³»ç»Ÿè¿è¡Œæ—¥å¿—ï¼Œä¾¿äºè°ƒè¯•å’Œé—®é¢˜è¯Šæ–­ã€‚åŒ…æ‹¬è¶…çŸ­äº¤æ˜“åˆ†æã€æ•°æ®è·å–ã€é”™è¯¯ä¿¡æ¯ç­‰ã€‚
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="startLogMonitoring()">å¼€å§‹ç›‘æ§æ—¥å¿—</button>
                <button class="btn btn-warning" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn btn-info" onclick="testUltraShortWithLogs()">æµ‹è¯•è¶…çŸ­äº¤æ˜“(å¸¦æ—¥å¿—)</button>
                <button class="btn btn-secondary" onclick="exportLogs()">å¯¼å‡ºæ—¥å¿—</button>
            </div>
            
            <div class="form-group">
                <label for="logLevelFilter">æ—¥å¿—çº§åˆ«è¿‡æ»¤:</label>
                <select id="logLevelFilter" class="form-control" onchange="filterLogs()">
                    <option value="all">å…¨éƒ¨</option>
                    <option value="INFO">INFO</option>
                    <option value="WARNING">WARNING</option>
                    <option value="ERROR">ERROR</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="logSearch">æœç´¢æ—¥å¿—:</label>
                <input type="text" id="logSearch" class="form-control" placeholder="è¾“å…¥å…³é”®è¯æœç´¢æ—¥å¿—..." onkeyup="searchLogs()">
            </div>
            
            <!-- æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="logs-container">
                <div class="logs-header">
                    <h4>å®æ—¶æ—¥å¿— <span id="logCount" class="log-count">(0æ¡)</span></h4>
                    <div class="log-controls">
                        <label>
                            <input type="checkbox" id="autoScroll" checked> è‡ªåŠ¨æ»šåŠ¨
                        </label>
                        <label>
                            <input type="checkbox" id="showTimestamp" checked> æ˜¾ç¤ºæ—¶é—´æˆ³
                        </label>
                    </div>
                </div>
                <div id="logsContent" class="logs-content">
                    <div class="log-entry info">
                        <span class="log-time">[ç³»ç»Ÿå¯åŠ¨]</span>
                        <span class="log-level">INFO</span>
                        <span class="log-message">æ—¥å¿—ç³»ç»Ÿå·²å°±ç»ªï¼Œç­‰å¾…æ—¥å¿—è¾“å‡º...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- æŒ‚å•ç®¡ç†Tab -->
        <div id="orders" class="tab-content">
            <h3>æŒ‚å•ç®¡ç†</h3>
            <div class="form-group">
                <button class="btn btn-success" onclick="createOrder()">åˆ›å»ºæŒ‚å•</button>
                <button class="btn btn-warning" onclick="refreshOrders()">åˆ·æ–°æŒ‚å•</button>
                <button class="btn btn-danger" onclick="cancelAllOrders()">å–æ¶ˆæ‰€æœ‰æŒ‚å•</button>
            </div>
            <div class="form-group">
                <label>æŒ‚å•è®¾ç½®ï¼š</label>
                <input type="text" class="form-control" id="orderSymbol" placeholder="å¸ç§ç¬¦å·ï¼Œå¦‚: BTC">
                <input type="number" class="form-control" id="orderPrice" placeholder="æŒ‚å•ä»·æ ¼" step="0.000001">
                <input type="number" class="form-control" id="orderAmount" placeholder="æŒ‚å•æ•°é‡" step="0.000001">
            </div>
            <div id="ordersList" class="results-container">
                <h4>å½“å‰æŒ‚å•</h4>
                <div id="ordersContent">
                    <p>æš‚æ— æŒ‚å•</p>
                </div>
            </div>
        </div>

        <!-- åˆ†æ‰¹ä»“ä½ç®¡ç†Tab -->
        <div id="positions" class="tab-content">
            <h3>åˆ†æ‰¹ä»“ä½ç®¡ç†</h3>
            <div class="form-group">
                <button class="btn btn-success" onclick="addPosition()">æ·»åŠ ä»“ä½</button>
                <button class="btn btn-warning" onclick="updatePositions()">æ›´æ–°ä»“ä½</button>
                <button class="btn btn-danger" onclick="closePosition()">å¹³ä»“</button>
            </div>
            <div class="form-group">
                <label>ä»“ä½ä¿¡æ¯ï¼š</label>
                <input type="text" class="form-control" id="positionSymbol" placeholder="å¸ç§ç¬¦å·">
                <input type="number" class="form-control" id="positionSize" placeholder="ä»“ä½å¤§å°" step="0.000001">
                <input type="number" class="form-control" id="positionPrice" placeholder="å¼€ä»“ä»·æ ¼" step="0.000001">
                <select class="form-control" id="positionType">
                    <option value="long">åšå¤š</option>
                    <option value="short">åšç©º</option>
                </select>
            </div>
            <div id="positionsList" class="results-container">
                <h4>å½“å‰æŒä»“</h4>
                <div id="positionsContent">
                    <p>æš‚æ— æŒä»“</p>
                </div>
            </div>
        </div>

        <!-- ç³»ç»Ÿç®¡ç†Tab -->
        <div id="management" class="tab-content">
            <h3>ç³»ç»Ÿç®¡ç†</h3>
            <div class="form-group">
                <button class="btn btn-warning" onclick="clearCache()">æ¸…é™¤ç¼“å­˜</button>
                <button class="btn" onclick="downloadCSV()">ä¸‹è½½CSVæŠ¥å‘Š</button>
                <button class="btn" onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
                <button class="btn" onclick="importData()">å¯¼å…¥æ•°æ®</button>
            </div>
            
            <div class="form-group">
                <h4>èƒŒæ™¯æ§åˆ¶</h4>
                <button class="btn btn-info" onclick="toggleVideoBackground()">åˆ‡æ¢èƒŒæ™¯æ¨¡å¼</button>
                <button class="btn btn-secondary" onclick="toggleBackground()">å¼€å…³èƒŒæ™¯</button>
                <label>èƒŒæ™¯é€æ˜åº¦: <input type="range" min="10" max="100" value="30" onchange="adjustVideoOpacity(this.value)"></label>
                <span id="opacityValue">30%</span>
            </div>
            <div class="form-group">
                <label>ç³»ç»Ÿè®¾ç½®ï¼š</label>
                <input type="number" class="form-control" id="refreshInterval" placeholder="åˆ·æ–°é—´éš”(ç§’)" value="30">
                <input type="number" class="form-control" id="maxPositions" placeholder="æœ€å¤§æŒä»“æ•°" value="10">
                <input type="number" class="form-control" id="stopLoss" placeholder="æ­¢æŸç™¾åˆ†æ¯”" value="5">
            </div>
            <div id="systemStatus" class="results-container">
                <h4>ç³»ç»ŸçŠ¶æ€</h4>
                <div id="statusContent">
                    <p>æ­£åœ¨åŠ è½½ç³»ç»ŸçŠ¶æ€...</p>
                </div>
            </div>
        </div>

        <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ -->
        <div id="statusArea"></div>
    </div>
    
    <!-- æ–°å¢å¸ç§æ¨¡æ€å¯¹è¯æ¡† -->
    <div id="addSymbolModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">æ–°å¢å¸ç§</span>
                <span class="close" onclick="closeAddSymbolModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>è¯·è¾“å…¥è¦æ–°å¢çš„å¸ç§ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼š</label>
                    <textarea class="form-control" id="newSymbolsInput" rows="4" placeholder="ä¾‹å¦‚: BTC, ETH, ADA, DOT, LINK, UNI"></textarea>
                </div>
                <div class="form-group">
                    <p style="color: #ffc107; font-size: 14px;">
                        ğŸ’¡ æç¤ºï¼šæ–°å¢çš„å¸ç§å°†è¢«ä¿å­˜åˆ°ç³»ç»Ÿä¸­ï¼Œä¸‹æ¬¡åˆ†ææ—¶ä¼šåŒ…å«è¿™äº›å¸ç§ã€‚
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeAddSymbolModal()">å–æ¶ˆ</button>
                <button class="btn btn-success" onclick="addNewSymbols()">ç¡®è®¤æ·»åŠ </button>
            </div>
        </div>
    </div>

         <script>
                   let currentResults = [];
          let orders = [];
          let positions = [];
          
          // åˆ†é¡µå’Œç­›é€‰ç›¸å…³å˜é‡
          let currentPage = 1;
          let pageSize = 20;
          let filteredResults = [];
          let sortOrder = 'asc';
          
          // å¸ç§ç®¡ç†ç›¸å…³å˜é‡
          let totalSymbols = 130; // é»˜è®¤å¸ç§æ•°é‡
          
          // æ—¥å†…äº¤æ˜“ç›¸å…³å˜é‡
          let intradayResults = [];
          let intradaySignals = [];
          let filteredIntradayResults = [];
          
          // å›¾è¡¨ç›¸å…³å˜é‡
          let emaChart = null;
          let currentChartSymbol = '';
          let currentChartTimeframe = '5m';
          let chartData = null;

        // æ˜¾ç¤ºTab
        function showTab(tabName) {
            // éšè—æ‰€æœ‰tabå†…å®¹
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // ç§»é™¤æ‰€æœ‰tabçš„activeç±»
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // æ˜¾ç¤ºé€‰ä¸­çš„tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

                 // åˆ†æé»˜è®¤å¸ç§
         async function analyzeDefault() {
             showStatus(`æ­£åœ¨åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§...`, 'success');
            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: [],
                        force_refresh: document.getElementById('forceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    currentResults = data.results;
                    showAnalysisResults(data.results);
                    showStatus(`åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                    updateStats();
                } else {
                    showStatus('åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åˆ†æè‡ªå®šä¹‰å¸ç§
        async function analyzeCustom() {
            const symbols = document.getElementById('symbolsInput').value.trim();
            if (!symbols) {
                showStatus('è¯·è¾“å…¥è¦åˆ†æçš„å¸ç§', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            showStatus(`æ­£åœ¨åˆ†æ ${symbolList.length} ä¸ªè‡ªå®šä¹‰å¸ç§...`, 'success');
            
            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: symbolList,
                        force_refresh: document.getElementById('forceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    currentResults = data.results;
                    showAnalysisResults(data.results);
                    showStatus(`åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                    updateStats();
                } else {
                    showStatus('åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

                 // æ˜¾ç¤ºåˆ†æç»“æœ
         function showAnalysisResults(results) {
             const resultsContainer = document.getElementById('analysisResults');
             
             if (results.length === 0) {
                 document.getElementById('analysisTableBody').innerHTML = '<tr><td colspan="6" style="text-align: center;">æ²¡æœ‰æ‰¾åˆ°ç»“æœ</td></tr>';
             } else {
                 // ä¸ºæ¯ä¸ªç»“æœæ·»åŠ æ—¶é—´çº§åˆ«
                 const resultsWithTimeframe = results.map(result => ({
                     ...result,
                     timeframe: getRandomTimeframe() // æ¨¡æ‹Ÿæ—¶é—´çº§åˆ«ï¼Œå®é™…åº”è¯¥ä»åç«¯è·å–
                 }));
                 
                 currentResults = resultsWithTimeframe;
                 filteredResults = [...resultsWithTimeframe];
                 
                 // é‡ç½®åˆ†é¡µ
                 currentPage = 1;
                 
                 // æ¸²æŸ“è¡¨æ ¼
                 renderTable();
                 updatePagination();
             }
             
             resultsContainer.style.display = 'block';
         }
         
         // æ¨¡æ‹Ÿè·å–æ—¶é—´çº§åˆ«ï¼ˆå®é™…åº”è¯¥ä»åç«¯è·å–ï¼‰
         function getRandomTimeframe() {
             const timeframes = ['12h', '1d', '3d'];
             return timeframes[Math.floor(Math.random() * timeframes.length)];
         }
         
         // æ¸²æŸ“è¡¨æ ¼
         function renderTable() {
             const tbody = document.getElementById('analysisTableBody');
             const startIndex = (currentPage - 1) * pageSize;
             const endIndex = startIndex + pageSize;
             const pageData = filteredResults.slice(startIndex, endIndex);
             
             if (pageData.length === 0) {
                 tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">æ²¡æœ‰æ•°æ®</td></tr>';
                 return;
             }
             
             let html = '';
             pageData.forEach(result => {
                 const symbol = result.symbol.replace('USDT', '');
                 const price = result.current_price ? result.current_price.toFixed(6) : 'N/A';
                 const orderPrice = result.order_price || 'N/A';
                 const status = result.status || 'æœªçŸ¥';
                 const timeframe = result.timeframe || '1d';
                 
                 // çŠ¶æ€æ ·å¼
                 let statusClass = 'status-hold';
                 let statusText = status;
                 if (status.toLowerCase().includes('buy')) {
                     statusClass = 'status-buy';
                     statusText = 'ä¹°å…¥';
                 } else if (status.toLowerCase().includes('sell')) {
                     statusClass = 'status-sell';
                     statusText = 'å–å‡º';
                 }
                 
                 html += `
                     <tr>
                         <td><strong>${symbol}</strong></td>
                         <td>${price}</td>
                         <td>${orderPrice}</td>
                         <td>${timeframe}</td>
                         <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                         <td>
                             <button class="action-btn action-btn-buy" onclick="createOrderFromResult('${symbol}', ${price})">ä¹°å…¥</button>
                             <button class="action-btn action-btn-sell" onclick="createOrderFromResult('${symbol}', ${price}, 'sell')">å–å‡º</button>
                         </td>
                     </tr>
                 `;
             });
             
             tbody.innerHTML = html;
         }

                 // åˆ†é¡µåŠŸèƒ½
         function updatePagination() {
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const pageInfo = document.getElementById('pageInfo');
             const prevBtn = document.getElementById('prevPage');
             const nextBtn = document.getElementById('nextPage');
             
             pageInfo.textContent = `ç¬¬ ${currentPage} é¡µï¼Œå…± ${totalPages} é¡µ (å…± ${filteredResults.length} æ¡è®°å½•)`;
             
             prevBtn.disabled = currentPage <= 1;
             nextBtn.disabled = currentPage >= totalPages;
         }
         
         function changePage(delta) {
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const newPage = currentPage + delta;
             
             if (newPage >= 1 && newPage <= totalPages) {
                 currentPage = newPage;
                 renderTable();
                 updatePagination();
             }
         }
         
         function changePageSize() {
             pageSize = parseInt(document.getElementById('pageSize').value);
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // æ’åºåŠŸèƒ½
         function sortResults() {
             const sortBy = document.getElementById('sortBy').value;
             
             filteredResults.sort((a, b) => {
                 let aVal, bVal;
                 
                 switch (sortBy) {
                     case 'symbol':
                         aVal = a.symbol.toLowerCase();
                         bVal = b.symbol.toLowerCase();
                         break;
                     case 'price':
                         aVal = a.current_price || 0;
                         bVal = b.current_price || 0;
                         break;
                     case 'orderPrice':
                         aVal = a.order_price || 0;
                         bVal = b.order_price || 0;
                         break;
                     case 'timeframe':
                         aVal = a.timeframe || '';
                         bVal = b.timeframe || '';
                         break;
                     default:
                         return 0;
                 }
                 
                 if (sortOrder === 'asc') {
                     return aVal > bVal ? 1 : -1;
                 } else {
                     return aVal < bVal ? 1 : -1;
                 }
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         function toggleSortOrder() {
             const sortOrderBtn = document.getElementById('sortOrder');
             sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
             sortOrderBtn.textContent = sortOrder === 'asc' ? 'â†‘' : 'â†“';
             sortResults();
         }
         
         // ç­›é€‰åŠŸèƒ½
         function filterResults() {
             const timeframeFilter = document.getElementById('timeframeFilter').value;
             const searchTerm = document.getElementById('searchSymbol').value.toLowerCase();
             
             filteredResults = currentResults.filter(result => {
                 // æ—¶é—´çº§åˆ«ç­›é€‰
                 if (timeframeFilter !== 'all' && result.timeframe !== timeframeFilter) {
                     return false;
                 }
                 
                 // æœç´¢ç­›é€‰
                 if (searchTerm && !result.symbol.toLowerCase().includes(searchTerm)) {
                     return false;
                 }
                 
                 return true;
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // ä»åˆ†æç»“æœåˆ›å»ºæŒ‚å•
         function createOrderFromResult(symbol, price, type = 'buy') {
             document.getElementById('orderSymbol').value = symbol;
             document.getElementById('orderPrice').value = price;
             document.getElementById('orderAmount').value = '0.001'; // é»˜è®¤æ•°é‡
             
             // åˆ‡æ¢åˆ°æŒ‚å•ç®¡ç†Tab
             showTab('orders');
             
             showStatus(`å·²å‡†å¤‡åˆ›å»º${type === 'buy' ? 'ä¹°å…¥' : 'å–å‡º'}æŒ‚å•: ${symbol}`, 'success');
         }
         
         // è·å–å¸ç§åˆ—è¡¨
         async function getSymbols() {
            try {
                const response = await fetch('/get_default_symbols');
                const data = await response.json();
                showStatus(`å½“å‰å¸ç§åˆ—è¡¨ï¼š${data.count} ä¸ªå¸ç§`, 'success');
            } catch (error) {
                showStatus('è·å–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åˆ›å»ºæŒ‚å•
        function createOrder() {
            const symbol = document.getElementById('orderSymbol').value;
            const price = document.getElementById('orderPrice').value;
            const amount = document.getElementById('orderAmount').value;
            
            if (!symbol || !price || !amount) {
                showStatus('è¯·å¡«å†™å®Œæ•´çš„æŒ‚å•ä¿¡æ¯', 'error');
                return;
            }
            
            const order = {
                symbol: symbol,
                price: parseFloat(price),
                amount: parseFloat(amount),
                status: 'æ´»è·ƒ'
            };
            
            orders.push(order);
            updateOrdersList();
            showStatus('æŒ‚å•åˆ›å»ºæˆåŠŸ', 'success');
            updateStats();
        }

        // åˆ·æ–°æŒ‚å•
        function refreshOrders() {
            showStatus('æŒ‚å•åˆ—è¡¨å·²åˆ·æ–°', 'success');
        }

        // å–æ¶ˆæ‰€æœ‰æŒ‚å•
        function cancelAllOrders() {
            orders = [];
            updateOrdersList();
            showStatus('æ‰€æœ‰æŒ‚å•å·²å–æ¶ˆ', 'success');
            updateStats();
        }

        // æ›´æ–°æŒ‚å•åˆ—è¡¨
        function updateOrdersList() {
            const content = document.getElementById('ordersContent');
            if (orders.length === 0) {
                content.innerHTML = '<p>æš‚æ— æŒ‚å•</p>';
            } else {
                let html = '';
                orders.forEach(order => {
                    html += `
                        <div class="order-item">
                            <strong>${order.symbol}</strong> - ä»·æ ¼: ${order.price} | æ•°é‡: ${order.amount} | çŠ¶æ€: ${order.status}
                        </div>
                    `;
                });
                content.innerHTML = html;
            }
        }

        // æ·»åŠ ä»“ä½
        function addPosition() {
            const symbol = document.getElementById('positionSymbol').value;
            const size = document.getElementById('positionSize').value;
            const price = document.getElementById('positionPrice').value;
            const type = document.getElementById('positionType').value;
            
            if (!symbol || !size || !price) {
                showStatus('è¯·å¡«å†™å®Œæ•´çš„ä»“ä½ä¿¡æ¯', 'error');
                return;
            }
            
            const position = {
                symbol: symbol,
                size: parseFloat(size),
                price: parseFloat(price),
                type: type,
                currentPrice: parseFloat(price) * (1 + (Math.random() - 0.5) * 0.1), // æ¨¡æ‹Ÿå½“å‰ä»·æ ¼
                pnl: 0
            };
            
            // è®¡ç®—ç›ˆäº
            if (type === 'long') {
                position.pnl = ((position.currentPrice - position.price) / position.price * 100).toFixed(2);
            } else {
                position.pnl = ((position.price - position.currentPrice) / position.price * 100).toFixed(2);
            }
            
            positions.push(position);
            updatePositionsList();
            showStatus('ä»“ä½æ·»åŠ æˆåŠŸ', 'success');
            updateStats();
        }

        // æ›´æ–°ä»“ä½
        function updatePositions() {
            positions.forEach(position => {
                position.currentPrice = position.price * (1 + (Math.random() - 0.5) * 0.1);
                if (position.type === 'long') {
                    position.pnl = ((position.currentPrice - position.price) / position.price * 100).toFixed(2);
                } else {
                    position.pnl = ((position.price - position.currentPrice) / position.price * 100).toFixed(2);
                }
            });
            updatePositionsList();
            showStatus('ä»“ä½å·²æ›´æ–°', 'success');
        }

        // å¹³ä»“
        function closePosition() {
            if (positions.length > 0) {
                positions.pop();
                updatePositionsList();
                showStatus('ä»“ä½å·²å¹³ä»“', 'success');
                updateStats();
            } else {
                showStatus('æ²¡æœ‰å¯å¹³ä»“çš„ä»“ä½', 'error');
            }
        }

        // æ›´æ–°ä»“ä½åˆ—è¡¨
        function updatePositionsList() {
            const content = document.getElementById('positionsContent');
            if (positions.length === 0) {
                content.innerHTML = '<p>æš‚æ— æŒä»“</p>';
            } else {
                let html = '';
                positions.forEach(position => {
                    const pnlColor = position.pnl >= 0 ? 'green' : 'red';
                    html += `
                        <div class="position-item">
                            <strong>${position.symbol}</strong> - ç±»å‹: ${position.type === 'long' ? 'åšå¤š' : 'åšç©º'} | 
                            å¤§å°: ${position.size} | å¼€ä»“ä»·: ${position.price} | 
                            å½“å‰ä»·: ${position.currentPrice.toFixed(2)} | 
                            ç›ˆäº: <span style="color: ${pnlColor}">${position.pnl}%</span>
                        </div>
                    `;
                });
                content.innerHTML = html;
            }
        }

        // æ¸…é™¤ç¼“å­˜
        async function clearCache() {
            try {
                const response = await fetch('/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('ç¼“å­˜å·²æ¸…é™¤', 'success');
                } else {
                    showStatus('æ¸…é™¤å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ä¸‹è½½CSV
        async function downloadCSV() {
            if (currentResults.length === 0) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„æ•°æ®ï¼Œè¯·å…ˆè¿›è¡Œåˆ†æ', 'error');
                return;
            }

            try {
                const response = await fetch('/download_csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: currentResults
                    })
                });

                const data = await response.json();
                if (data.success) {
                    const blob = new Blob([data.csv_data], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = data.filename;
                    link.click();
                    showStatus('CSVæ–‡ä»¶ä¸‹è½½æˆåŠŸ', 'success');
                } else {
                    showStatus('ä¸‹è½½å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å¯¼å‡ºæ•°æ®
        function exportData() {
            const data = {
                orders: orders,
                positions: positions,
                results: currentResults
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'bollinger_data.json';
            link.click();
            showStatus('æ•°æ®å¯¼å‡ºæˆåŠŸ', 'success');
        }

        // å¯¼å…¥æ•°æ®
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.orders) orders = data.orders;
                        if (data.positions) positions = data.positions;
                        if (data.results) currentResults = data.results;
                        
                        updateOrdersList();
                        updatePositionsList();
                        updateStats();
                        showStatus('æ•°æ®å¯¼å…¥æˆåŠŸ', 'success');
                    } catch (error) {
                        showStatus('æ•°æ®å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStats() {
            document.getElementById('analyzedCount').textContent = currentResults.length;
            document.getElementById('activeOrders').textContent = orders.length;
            document.getElementById('totalPositions').textContent = positions.length;
        }

                 // æ˜¾ç¤ºçŠ¶æ€
         function showStatus(message, type) {
             const statusArea = document.getElementById('statusArea');
             statusArea.innerHTML = `<div class="status ${type}">${message}</div>`;
         }
         
         // æ–°å¢å¸ç§ç›¸å…³å‡½æ•°
         function showAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'block';
             document.getElementById('newSymbolsInput').value = '';
             document.getElementById('newSymbolsInput').focus();
         }
         
         function closeAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'none';
         }
         
         async function addNewSymbols() {
             const symbolsInput = document.getElementById('newSymbolsInput').value.trim();
             if (!symbolsInput) {
                 showStatus('è¯·è¾“å…¥è¦æ–°å¢çš„å¸ç§', 'error');
                 return;
             }
             
             const symbolList = symbolsInput.split(',').map(s => s.trim()).filter(s => s);
             if (symbolList.length === 0) {
                 showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å¸ç§', 'error');
                 return;
             }
             
             try {
                 const response = await fetch('/add_symbols', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         symbols: symbolList
                     })
                 });
                 
                 const data = await response.json();
                 if (data.success) {
                     // æ›´æ–°å¸ç§æ•°é‡
                     totalSymbols = data.total_symbols;
                     
                     // æ›´æ–°é¡µé¢æ˜¾ç¤ºçš„å¸ç§æ•°é‡
                     document.getElementById('totalSymbols').textContent = totalSymbols;
                     
                     // æ›´æ–°åˆ†ææŒ‰é’®æ–‡æœ¬
                     const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                     analyzeBtn.textContent = `åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§`;
                     
                     closeAddSymbolModal();
                     showStatus(`æˆåŠŸæ–°å¢ ${symbolList.length} ä¸ªå¸ç§ï¼Œå½“å‰æ€»è®¡ ${totalSymbols} ä¸ªå¸ç§`, 'success');
                     
                     // åˆ·æ–°é¡µé¢
                     setTimeout(() => {
                         location.reload();
                     }, 2000);
                 } else {
                     showStatus('æ–°å¢å¸ç§å¤±è´¥: ' + data.error, 'error');
                 }
             } catch (error) {
                 showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
             }
         }
         
         // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
         window.onclick = function(event) {
             const modal = document.getElementById('addSymbolModal');
             if (event.target === modal) {
                 closeAddSymbolModal();
             }
         }
         
         // æ›´æ–°å¸ç§æ•°é‡
         async function updateSymbolCount() {
             try {
                 const response = await fetch('/get_default_symbols');
                 const data = await response.json();
                 
                 totalSymbols = data.count;
                 
                 // æ›´æ–°æ‰€æœ‰æ˜¾ç¤ºå¸ç§æ•°é‡çš„åœ°æ–¹
                 document.getElementById('totalSymbols').textContent = totalSymbols;
                 document.getElementById('totalSymbolsDisplay').textContent = totalSymbols;
                 document.getElementById('analyzeButtonCount').textContent = totalSymbols;
                 
                 // æ›´æ–°åˆ†ææŒ‰é’®æ–‡æœ¬
                 const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                 if (analyzeBtn) {
                     analyzeBtn.textContent = `åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§`;
                 }
                 
                 console.log(`å½“å‰å¸ç§æ•°é‡: ${totalSymbols}`);
             } catch (error) {
                 console.error('è·å–å¸ç§æ•°é‡å¤±è´¥:', error);
             }
         }

        // è§†é¢‘èƒŒæ™¯æ§åˆ¶
        let videoElement = null;
        
        function initVideoBackground() {
            videoElement = document.querySelector('.video-background');
            
            if (videoElement) {
                console.log('æ‰¾åˆ°è§†é¢‘å…ƒç´ ï¼Œå¼€å§‹åˆå§‹åŒ–...');
                
                // æ£€æŸ¥è§†é¢‘æº
                console.log('è§†é¢‘æº:', videoElement.src);
                console.log('è§†é¢‘å½“å‰çŠ¶æ€:', videoElement.readyState);
                
                videoElement.addEventListener('loadeddata', function() {
                    console.log('è§†é¢‘èƒŒæ™¯åŠ è½½å®Œæˆ');
                    showStatus('è§†é¢‘èƒŒæ™¯åŠ è½½å®Œæˆ', 'success');
                });
                
                videoElement.addEventListener('canplay', function() {
                    console.log('è§†é¢‘å¯ä»¥æ’­æ”¾');
                    showStatus('è§†é¢‘èƒŒæ™¯å¯ä»¥æ’­æ”¾', 'success');
                });
                
                videoElement.addEventListener('error', function(e) {
                    console.log('è§†é¢‘èƒŒæ™¯åŠ è½½å¤±è´¥:', e);
                    showStatus('è§†é¢‘èƒŒæ™¯åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŠ¨ç”»èƒŒæ™¯', 'warning');
                    const animatedBg = document.querySelector('.animated-background');
                    if (animatedBg) {
                        animatedBg.style.display = 'block';
                    }
                });
                
                // å¼ºåˆ¶åŠ è½½è§†é¢‘
                videoElement.load();
            } else {
                console.log('æœªæ‰¾åˆ°è§†é¢‘å…ƒç´ ');
                showStatus('æœªæ‰¾åˆ°è§†é¢‘å…ƒç´ ', 'error');
            }
        }
        
        function toggleVideoBackground() {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const overlay = document.querySelector('.video-overlay');
            
            if (video.style.display === 'none' || video.style.display === '') {
                // åˆ‡æ¢åˆ°è§†é¢‘èƒŒæ™¯
                video.style.display = 'block';
                animatedBg.style.display = 'none';
                overlay.style.display = 'block';
                showStatus('å·²åˆ‡æ¢åˆ°è§†é¢‘èƒŒæ™¯', 'success');
            } else {
                // åˆ‡æ¢åˆ°åŠ¨ç”»èƒŒæ™¯
                video.style.display = 'none';
                animatedBg.style.display = 'block';
                overlay.style.display = 'block';
                showStatus('å·²åˆ‡æ¢åˆ°åŠ¨ç”»èƒŒæ™¯', 'info');
            }
        }
        
        function adjustVideoOpacity(value) {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const opacity = value / 100;
            
            if (video) video.style.opacity = opacity;
            if (animatedBg) animatedBg.style.opacity = opacity;
            
            document.getElementById('opacityValue').textContent = value + '%';
            showStatus(`èƒŒæ™¯é€æ˜åº¦å·²è°ƒæ•´ä¸º ${value}%`, 'info');
        }
        
        function toggleBackground() {
            const overlay = document.querySelector('.video-overlay');
            if (overlay.style.display === 'none') {
                overlay.style.display = 'block';
                showStatus('èƒŒæ™¯å·²å¯ç”¨', 'success');
            } else {
                overlay.style.display = 'none';
                showStatus('èƒŒæ™¯å·²ç¦ç”¨', 'info');
            }
        }
        
                 // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
         document.addEventListener('DOMContentLoaded', function() {
             console.log('å¸ƒæ—å¸¦ç­–ç•¥ç³»ç»Ÿå·²åŠ è½½å®Œæˆ');
             showStatus('ç³»ç»Ÿå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹åˆ†æ', 'success');
             updateStats();
             updateSystemStatus();
             
             // è·å–å½“å‰å¸ç§æ•°é‡
             updateSymbolCount();
            
            // åˆå§‹åŒ–è§†é¢‘èƒŒæ™¯
            initVideoBackground();
            
            // åˆå§‹åŒ–å›¾è¡¨
            initChart();
            initChartSymbolSelect();
            
            // åˆå§‹åŒ–åŠ¨ç”»èƒŒæ™¯ï¼ˆé»˜è®¤éšè—ï¼‰
            const animatedBg = document.querySelector('.animated-background');
            if (animatedBg) {
                animatedBg.style.display = 'none';
            }
            
            // å®šæœŸæ›´æ–°ç³»ç»ŸçŠ¶æ€
            setInterval(updateSystemStatus, 30000); // æ¯30ç§’æ›´æ–°ä¸€æ¬¡
            setInterval(updateStats, 10000); // æ¯10ç§’æ›´æ–°ä¸€æ¬¡ç»Ÿè®¡
        });

        // æ›´æ–°ç³»ç»ŸçŠ¶æ€
        function updateSystemStatus() {
            const statusContent = document.getElementById('statusContent');
            const now = new Date();
            const startTime = new Date(now.getTime() - 2 * 60 * 60 * 1000); // 2å°æ—¶å‰
            const uptime = Math.floor((now - startTime) / (1000 * 60)); // åˆ†é’Ÿ
            
            statusContent.innerHTML = `
                <p>ç¼“å­˜çŠ¶æ€: æ­£å¸¸</p>
                <p>APIè¿æ¥: æ­£å¸¸</p>
                <p>æ•°æ®æ›´æ–°: ${now.getMinutes()}åˆ†é’Ÿå‰</p>
                <p>ç³»ç»Ÿè¿è¡Œæ—¶é—´: ${uptime}åˆ†é’Ÿ</p>
                <p>æœ€åæ›´æ–°: ${now.toLocaleTimeString()}</p>
            `;
        }
        
        // ==================== æ—¥å†…äº¤æ˜“ç›¸å…³å‡½æ•° ====================
        
        // åˆ†æä¸»è¦å¸ç§çš„æ—¥å†…äº¤æ˜“ä¿¡å·
        async function analyzeIntradaySymbols() {
            const mainSymbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'];
            showStatus(`æ­£åœ¨åˆ†æä¸»è¦å¸ç§æ—¥å†…äº¤æ˜“ä¿¡å·...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: mainSymbols,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`æ—¥å†…äº¤æ˜“ä¿¡å·åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('æ—¥å†…äº¤æ˜“åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // åˆ†æè‡ªå®šä¹‰å¸ç§çš„æ—¥å†…äº¤æ˜“ä¿¡å·
        async function analyzeIntradayCustom() {
            const symbols = document.getElementById('intradaySymbolsInput').value.trim();
            if (!symbols) {
                showStatus('è¯·è¾“å…¥è¦åˆ†æçš„å¸ç§', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            showStatus(`æ­£åœ¨åˆ†æ ${symbolList.length} ä¸ªè‡ªå®šä¹‰å¸ç§æ—¥å†…äº¤æ˜“ä¿¡å·...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: symbolList,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`æ—¥å†…äº¤æ˜“ä¿¡å·åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('æ—¥å†…äº¤æ˜“åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // è·å–ä¿¡å·æ±‡æ€»
        async function getIntradaySignals() {
            showStatus('æ­£åœ¨è·å–æ—¥å†…äº¤æ˜“ä¿¡å·æ±‡æ€»...', 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'],
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`ä¿¡å·æ±‡æ€»è·å–å®Œæˆï¼Œå…± ${data.total} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('è·å–ä¿¡å·æ±‡æ€»å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æ˜¾ç¤ºæ—¥å†…äº¤æ˜“ä¿¡å·
        function showIntradaySignals(signals) {
            const signalsContainer = document.getElementById('intradaySignals');
            const tbody = document.getElementById('intradaySignalsTableBody');
            
            if (signals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">æ²¡æœ‰æ‰¾åˆ°ä¿¡å·</td></tr>';
            } else {
                let html = '';
                signals.forEach(signal => {
                    const symbol = signal.symbol.replace('USDT', '');
                    const overallSignal = signal.overall_signal;
                    const consistency = signal.signal_consistency;
                    
                    // è·å–15åˆ†é’Ÿå’Œ1å°æ—¶ä¿¡å·
                    const signal15m = signal.priority_signals['15m'] || {};
                    const signal1h = signal.priority_signals['1h'] || {};
                    
                    // ä¿¡å·æ ·å¼
                    let signalClass = 'status-hold';
                    let signalText = 'æœªçŸ¥';
                    if (overallSignal === 'long') {
                        signalClass = 'status-buy';
                        signalText = 'å¤šå¤´';
                    } else if (overallSignal === 'short') {
                        signalClass = 'status-sell';
                        signalText = 'ç©ºå¤´';
                    } else if (overallSignal === 'mixed') {
                        signalClass = 'status-hold';
                        signalText = 'æ··åˆ';
                    }
                    
                    // 15åˆ†é’Ÿä¿¡å·
                    let signal15mText = 'æ— ';
                    let signal15mClass = 'status-hold';
                    if (signal15m.signal) {
                        signal15mText = signal15m.signal;
                        signal15mClass = signal15m.signal_type === 'long' ? 'status-buy' : 'status-sell';
                    }
                    
                    // 1å°æ—¶ä¿¡å·
                    let signal1hText = 'æ— ';
                    let signal1hClass = 'status-hold';
                    if (signal1h.signal) {
                        signal1hText = signal1h.signal;
                        signal1hClass = signal1h.signal_type === 'long' ? 'status-buy' : 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td><span class="status-badge ${signalClass}">${signalText}</span></td>
                            <td><span class="status-badge ${signal15mClass}">${signal15mText}</span></td>
                            <td><span class="status-badge ${signal1hClass}">${signal1hText}</span></td>
                            <td>${consistency}</td>
                            <td>
                                <button class="action-btn action-btn-buy" onclick="viewIntradayDetails('${symbol}')">è¯¦ç»†</button>
                                <button class="action-btn action-btn-sell" onclick="showChart('${symbol}')">å›¾è¡¨</button>
                            </td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
            }
            
            signalsContainer.style.display = 'block';
        }
        
        // æŸ¥çœ‹è¯¦ç»†åˆ†æ
        async function viewIntradayDetails(symbol) {
            showStatus(`æ­£åœ¨è·å– ${symbol} çš„è¯¦ç»†åˆ†æ...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_symbol_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradayResults = [data.result];
                    showIntradayDetails(data.result);
                    showStatus(`${symbol} è¯¦ç»†åˆ†æå®Œæˆ`, 'success');
                } else {
                    showStatus('è·å–è¯¦ç»†åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æ˜¾ç¤ºè¯¦ç»†åˆ†æç»“æœ
        function showIntradayDetails(result) {
            const detailsContainer = document.getElementById('intradayDetails');
            const tbody = document.getElementById('intradayDetailsTableBody');
            
            if (!result.timeframes || Object.keys(result.timeframes).length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">æ²¡æœ‰æ‰¾åˆ°è¯¦ç»†æ•°æ®</td></tr>';
            } else {
                let html = '';
                Object.entries(result.timeframes).forEach(([timeframe, data]) => {
                    const symbol = data.symbol.replace('USDT', '');
                    const price = data.current_price ? data.current_price.toFixed(6) : 'N/A';
                    const ema365 = data.ema365 ? data.ema365.toFixed(6) : 'N/A';
                    const ma365 = data.ma365 ? data.ma365.toFixed(6) : 'N/A';
                    const anchor = data.anchor_point ? data.anchor_point.toFixed(6) : 'N/A';
                    const signal = data.signal || 'æœªçŸ¥';
                    const strength = data.strength || 'å¼±';
                    const deviation = data.deviation || 0;
                    
                    // ä¿¡å·æ ·å¼
                    let signalClass = 'status-hold';
                    if (data.signal_type === 'long') {
                        signalClass = 'status-buy';
                    } else if (data.signal_type === 'short') {
                        signalClass = 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${timeframe}</td>
                            <td>${price}</td>
                            <td>${ema365}</td>
                            <td>${ma365}</td>
                            <td>${anchor}</td>
                            <td><span class="status-badge ${signalClass}">${signal}</span></td>
                            <td>${strength}</td>
                            <td>${deviation}%</td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
                filteredIntradayResults = Object.values(result.timeframes);
            }
            
            detailsContainer.style.display = 'block';
        }
        
        // ç­›é€‰æ—¥å†…äº¤æ˜“ç»“æœ
        function filterIntradayResults() {
            const timeframeFilter = document.getElementById('intradayTimeframeFilter').value;
            const signalFilter = document.getElementById('intradaySignalFilter').value;
            const searchTerm = document.getElementById('intradaySearchSymbol').value.toLowerCase();
            
            if (!intradayResults.length) return;
            
            const result = intradayResults[0];
            if (!result.timeframes) return;
            
            filteredIntradayResults = Object.values(result.timeframes).filter(data => {
                // æ—¶é—´å‘¨æœŸç­›é€‰
                if (timeframeFilter !== 'all' && data.timeframe !== timeframeFilter) {
                    return false;
                }
                
                // ä¿¡å·ç±»å‹ç­›é€‰
                if (signalFilter !== 'all' && data.signal_type !== signalFilter) {
                    return false;
                }
                
                // æœç´¢ç­›é€‰
                if (searchTerm && !data.symbol.toLowerCase().includes(searchTerm)) {
                    return false;
                }
                
                return true;
            });
            
            // é‡æ–°æ¸²æŸ“è¡¨æ ¼
            const tbody = document.getElementById('intradayDetailsTableBody');
            if (filteredIntradayResults.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">æ²¡æœ‰åŒ¹é…çš„æ•°æ®</td></tr>';
            } else {
                let html = '';
                filteredIntradayResults.forEach(data => {
                    const symbol = data.symbol.replace('USDT', '');
                    const price = data.current_price ? data.current_price.toFixed(6) : 'N/A';
                    const ema365 = data.ema365 ? data.ema365.toFixed(6) : 'N/A';
                    const ma365 = data.ma365 ? data.ma365.toFixed(6) : 'N/A';
                    const anchor = data.anchor_point ? data.anchor_point.toFixed(6) : 'N/A';
                    const signal = data.signal || 'æœªçŸ¥';
                    const strength = data.strength || 'å¼±';
                    const deviation = data.deviation || 0;
                    
                    // ä¿¡å·æ ·å¼
                    let signalClass = 'status-hold';
                    if (data.signal_type === 'long') {
                        signalClass = 'status-buy';
                    } else if (data.signal_type === 'short') {
                        signalClass = 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${data.timeframe}</td>
                            <td>${price}</td>
                            <td>${ema365}</td>
                            <td>${ma365}</td>
                            <td>${anchor}</td>
                            <td><span class="status-badge ${signalClass}">${signal}</span></td>
                            <td>${strength}</td>
                            <td>${deviation}%</td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
            }
        }
        
        // æ¸…é™¤æ—¥å†…äº¤æ˜“ç¼“å­˜
        async function clearIntradayCache() {
            try {
                const response = await fetch('/intraday/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('æ—¥å†…äº¤æ˜“ç¼“å­˜å·²æ¸…é™¤', 'success');
                } else {
                    showStatus('æ¸…é™¤ç¼“å­˜å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // ==================== æ—¥å†…è¶…çŸ­äº¤æ˜“ç›¸å…³å‡½æ•° ====================
        
        // åˆ†æä¸»è¦å¸ç§çš„è¶…çŸ­äº¤æ˜“ä¿¡å·
        async function analyzeUltraShortSymbols() {
            showStatus(`æ­£åœ¨è·å–å¸å®‰å‰200ä¸ªå¸ç§...`, 'success');
            
            try {
                // é¦–å…ˆè·å–å¸å®‰å‰200ä¸ªå¸ç§
                const symbolsResponse = await fetch('/ultra_short/get_top_symbols', {
                    method: 'GET'
                });
                
                const symbolsData = await symbolsResponse.json();
                if (!symbolsData.success) {
                    showStatus('è·å–å¸ç§åˆ—è¡¨å¤±è´¥: ' + symbolsData.error, 'error');
                    return;
                }
                
                const symbols = symbolsData.symbols;
                showStatus(`è·å–åˆ° ${symbols.length} ä¸ªå¸ç§ï¼Œå¼€å§‹åˆ†æè¶…çŸ­äº¤æ˜“ä¿¡å·...`, 'success');
                
                // åˆ†æè¶…çŸ­äº¤æ˜“ä¿¡å·
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: symbols })
                });

                const data = await response.json();
                if (data.success) {
                    showUltraShortSignals(data.signals);
                    showStatus(`è¶…çŸ­äº¤æ˜“ä¿¡å·åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('è¶…çŸ­äº¤æ˜“åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // åˆ†æè‡ªå®šä¹‰å¸ç§çš„è¶…çŸ­äº¤æ˜“ä¿¡å·
        async function analyzeUltraShortCustom() {
            const symbols = document.getElementById('ultraShortSymbolsInput').value.trim();
            if (!symbols) {
                showStatus('è¯·è¾“å…¥è¦åˆ†æçš„å¸ç§', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            showStatus(`æ­£åœ¨åˆ†æ ${symbolList.length} ä¸ªè‡ªå®šä¹‰å¸ç§è¶…çŸ­äº¤æ˜“ä¿¡å·...`, 'success');
            
            try {
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: symbolList })
                });

                const data = await response.json();
                if (data.success) {
                    showUltraShortSignals(data.signals);
                    showStatus(`è¶…çŸ­äº¤æ˜“ä¿¡å·åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${data.total} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('è¶…çŸ­äº¤æ˜“åˆ†æå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æ˜¾ç¤ºè¶…çŸ­äº¤æ˜“ä¿¡å·
        function showUltraShortSignals(signals) {
            const tbody = document.getElementById('ultraShortSignalsTableBody');
            
            if (signals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666;">æš‚æ— è¶…çŸ­äº¤æ˜“ä¿¡å·</td></tr>';
                return;
            }
            
            let html = '';
            signals.forEach(signal => {
                let opportunityClass = 'warning';
                let opportunityText = signal.trading_opportunity;
                
                if (signal.trading_opportunity === 'åšç©ºæœºä¼š') {
                    opportunityClass = 'danger';
                } else if (signal.trading_opportunity === 'åšå¤šæœºä¼š') {
                    opportunityClass = 'success';
                } else if (signal.trading_opportunity.includes('åšç©ºæœºä¼š') && signal.trading_opportunity.includes('ä¸€èˆ¬')) {
                    opportunityClass = 'info';
                } else if (signal.trading_opportunity.includes('åšå¤šæœºä¼š') && signal.trading_opportunity.includes('ä¸€èˆ¬')) {
                    opportunityClass = 'info';
                } else if (signal.trading_opportunity.includes('åšç©ºæœºä¼š')) {
                    opportunityClass = 'secondary';
                } else if (signal.trading_opportunity.includes('åšå¤šæœºä¼š')) {
                    opportunityClass = 'secondary';
                }
                
                // è®¡ç®—æ½œåœ¨æ”¶ç›Š
                let potentialProfit = 0;
                if (signal.entry_price > 0) {
                    if (signal.trading_opportunity.includes('åšç©º')) {
                        potentialProfit = signal.entry_price - signal.profit_target;
                    } else if (signal.trading_opportunity.includes('åšå¤š')) {
                        potentialProfit = signal.profit_target - signal.entry_price;
                    }
                }
                
                html += `
                    <tr>
                        <td><strong>${signal.symbol}</strong></td>
                        <td>${signal.interval_low} - ${signal.interval_high}</td>
                        <td>${signal.current_price}</td>
                        <td><span class="status-${opportunityClass}">${opportunityText}</span></td>
                        <td><strong>${signal.entry_price || '-'}</strong></td>
                        <td><strong>${signal.profit_target}</strong></td>
                        <td>${signal.risk_reward_ratio}</td>
                        <td>
                            <button class="btn btn-sm btn-info" onclick="showUltraShortDetails('${signal.symbol}')">è¯¦æƒ…</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }
        
        // æ˜¾ç¤ºè¶…çŸ­äº¤æ˜“è¯¦æƒ…
        async function showUltraShortDetails(symbol) {
            try {
                const response = await fetch('/ultra_short/get_signal_details', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });

                const data = await response.json();
                if (data.success) {
                    const detailsContainer = document.getElementById('ultraShortDetails');
                    const detailsContent = document.getElementById('ultraShortDetailsContent');
                    
                    const latest1h = data.chart_data['1h'];
                    const latest1m = data.chart_data['1m'];
                    
                    detailsContent.innerHTML = `
                        <div class="signal-details">
                            <h5>${symbol} è¶…çŸ­äº¤æ˜“è¯¦æƒ…</h5>
                            <div class="details-grid">
                                <div class="detail-item">
                                    <label>1å°æ—¶EMA365:</label>
                                    <span>${latest1h.ema365[latest1h.ema365.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>1å°æ—¶MA365:</label>
                                    <span>${latest1h.ma365[latest1h.ma365.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>1åˆ†é’ŸEMA233:</label>
                                    <span>${latest1m.ema233[latest1m.ema233.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>å½“å‰ä»·æ ¼:</label>
                                    <span>${latest1h.prices[latest1h.prices.length - 1] || 'N/A'}</span>
                                </div>
                            </div>
                            <div class="trading-signals">
                                <h6>äº¤æ˜“ä¿¡å·ï¼š</h6>
                                <div class="signal-item">
                                    <span class="signal-label">åšç©ºä¿¡å·:</span>
                                    <span class="signal-value">å½“ä»·æ ¼ > ${Math.max(latest1h.ema365[latest1h.ema365.length - 1] || 0, latest1h.ma365[latest1h.ma365.length - 1] || 0).toFixed(2)}</span>
                                </div>
                                <div class="signal-item">
                                    <span class="signal-label">åšå¤šä¿¡å·:</span>
                                    <span class="signal-value">å½“ä»·æ ¼ < ${Math.min(latest1h.ema365[latest1h.ema365.length - 1] || 0, latest1h.ma365[latest1h.ma365.length - 1] || 0).toFixed(2)}</span>
                                </div>
                                <div class="signal-item">
                                    <span class="signal-label">æ­¢ç›ˆç›®æ ‡:</span>
                                    <span class="signal-value">${latest1m.ema233[latest1m.ema233.length - 1] || 'N/A'}</span>
                                </div>
                            </div>
                            <div class="strategy-explanation">
                                <h6>ç­–ç•¥è¯´æ˜ï¼š</h6>
                                <p>1. <strong>åšç©ºç­–ç•¥:</strong> å½“ä»·æ ¼çªç ´1å°æ—¶EMA365/MA365åŒºé—´ä¸Šæ²¿æ—¶ï¼Œåœ¨åŒºé—´ä¸Šæ²¿åšç©º</p>
                                <p>2. <strong>åšå¤šç­–ç•¥:</strong> å½“ä»·æ ¼è·Œç ´1å°æ—¶EMA365/MA365åŒºé—´ä¸‹æ²¿æ—¶ï¼Œåœ¨åŒºé—´ä¸‹æ²¿åšå¤š</p>
                                <p>3. <strong>æ­¢ç›ˆç›®æ ‡:</strong> ç»Ÿä¸€è®¾ç½®ä¸º1åˆ†é’ŸEMA233ä½ç½®</p>
                                <p>4. <strong>é£é™©æ§åˆ¶:</strong> é£é™©æ”¶ç›Šæ¯”åº”å¤§äº1.5æ‰è€ƒè™‘å…¥åœº</p>
                            </div>
                        </div>
                    `;
                    
                    detailsContainer.style.display = 'block';
                } else {
                    showStatus('è·å–è¯¦æƒ…å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // è·å–å¸å®‰å‰200ä¸ªå¸ç§åˆ—è¡¨
        async function getTopSymbols() {
            showStatus('æ­£åœ¨è·å–å¸å®‰å‰200ä¸ªå¸ç§...', 'success');
            
            try {
                const response = await fetch('/ultra_short/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                if (data.success) {
                    const symbols = data.symbols;
                    const top10 = data.top_10;
                    
                    showStatus(`æˆåŠŸè·å– ${symbols.length} ä¸ªå¸ç§ï¼Œå‰10ä¸ª: ${top10.join(', ')}`, 'success');
                    
                    // æ˜¾ç¤ºå¸ç§åˆ—è¡¨
                    const symbolsList = symbols.join(', ');
                    document.getElementById('ultraShortSymbolsInput').value = symbolsList;
                    
                    // æ˜¾ç¤ºå¸ç§ç»Ÿè®¡ä¿¡æ¯
                    const detailsContainer = document.getElementById('ultraShortDetails');
                    const detailsContent = document.getElementById('ultraShortDetailsContent');
                    
                    detailsContent.innerHTML = `
                        <div class="signal-details">
                            <h5>å¸å®‰å‰200ä¸ªUSDTäº¤æ˜“å¯¹</h5>
                            <div class="details-grid">
                                <div class="detail-item">
                                    <label>æ€»å¸ç§æ•°é‡:</label>
                                    <span>${symbols.length}</span>
                                </div>
                                <div class="detail-item">
                                    <label>å‰10ä¸ªå¸ç§:</label>
                                    <span>${top10.join(', ')}</span>
                                </div>
                            </div>
                            <div class="strategy-explanation">
                                <h6>è¯´æ˜ï¼š</h6>
                                <p>1. æŒ‰24å°æ—¶äº¤æ˜“é‡æ’åºï¼Œå–å‰200ä¸ªUSDTäº¤æ˜“å¯¹</p>
                                <p>2. æ•°æ®å®æ—¶ä»å¸å®‰APIè·å–</p>
                                <p>3. ç‚¹å‡»"åˆ†æè¶…çŸ­æœºä¼š"æŒ‰é’®å¼€å§‹åˆ†æè¿™äº›å¸ç§</p>
                            </div>
                        </div>
                    `;
                    
                    detailsContainer.style.display = 'block';
                } else {
                    showStatus('è·å–å¸ç§åˆ—è¡¨å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // éªŒè¯å¸ç§
        async function validateSymbol() {
            const symbol = document.getElementById('ultraShortSymbolsInput').value.trim();
            if (!symbol) {
                showStatus('è¯·è¾“å…¥è¦éªŒè¯çš„å¸ç§', 'error');
                return;
            }
            
            showStatus(`æ­£åœ¨éªŒè¯å¸ç§ ${symbol}...`, 'success');
            
            try {
                const response = await fetch('/ultra_short/validate_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                if (data.success) {
                    const status = data.is_valid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ';
                    const color = data.is_valid ? 'success' : 'error';
                    showStatus(`å¸ç§ ${symbol} éªŒè¯ç»“æœ: ${status} (æ ‡å‡†åŒ–: ${data.normalized_symbol}, æ•°æ®é‡: ${data.data_count})`, color);
                } else {
                    showStatus('éªŒè¯å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('éªŒè¯è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æ¸…é™¤è¶…çŸ­äº¤æ˜“ç¼“å­˜
        async function clearUltraShortCache() {
            try {
                const response = await fetch('/ultra_short/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('è¶…çŸ­äº¤æ˜“ç¼“å­˜å·²æ¸…é™¤', 'success');
                } else {
                    showStatus('æ¸…é™¤ç¼“å­˜å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // ==================== æ—¥å¿—è¯Šæ–­ç›¸å…³å‡½æ•° ====================
        
        let logMonitoringInterval = null;
        let allLogs = [];
        
        // å¼€å§‹ç›‘æ§æ—¥å¿—
        async function startLogMonitoring() {
            if (logMonitoringInterval) {
                clearInterval(logMonitoringInterval);
            }
            
            showStatus('å¼€å§‹ç›‘æ§æ—¥å¿—...', 'success');
            addLogEntry('INFO', 'å¼€å§‹ç›‘æ§ç³»ç»Ÿæ—¥å¿—');
            
            // ç«‹å³è·å–ä¸€æ¬¡æ—¥å¿—
            await fetchLogs();
            
            // æ¯2ç§’è·å–ä¸€æ¬¡æ–°æ—¥å¿—
            logMonitoringInterval = setInterval(fetchLogs, 2000);
        }
        
        // è·å–æ—¥å¿—
        async function fetchLogs() {
            try {
                const response = await fetch('/logs/get_logs?limit=50');
                const data = await response.json();
                
                if (data.success) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ—¥å¿—
                    const newLogs = data.logs.filter(log => 
                        !allLogs.some(existingLog => 
                            existingLog.timestamp === log.timestamp && 
                            existingLog.message === log.message
                        )
                    );
                    
                    // æ·»åŠ æ–°æ—¥å¿—
                    newLogs.forEach(log => {
                        allLogs.push(log);
                        addLogEntry(log.level, log.message, log.timestamp);
                    });
                    
                    // é™åˆ¶æ—¥å¿—æ•°é‡
                    if (allLogs.length > 500) {
                        allLogs = allLogs.slice(-500);
                    }
                    
                    updateLogCount();
                }
            } catch (error) {
                console.error('è·å–æ—¥å¿—å¤±è´¥:', error);
            }
        }
        
        // æ·»åŠ æ—¥å¿—æ¡ç›®
        function addLogEntry(level, message, timestamp = null) {
            const logsContent = document.getElementById('logsContent');
            const time = timestamp || new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${level.toLowerCase()}`;
            
            const showTimestamp = document.getElementById('showTimestamp').checked;
            const timeStr = showTimestamp ? `[${time}]` : '';
            
            logEntry.innerHTML = `
                <span class="log-time">${timeStr}</span>
                <span class="log-level">${level}</span>
                <span class="log-message">${message}</span>
            `;
            
            logsContent.appendChild(logEntry);
            
            // è‡ªåŠ¨æ»šåŠ¨
            if (document.getElementById('autoScroll').checked) {
                logsContent.scrollTop = logsContent.scrollHeight;
            }
        }
        
        // æ›´æ–°æ—¥å¿—è®¡æ•°
        function updateLogCount() {
            const logCount = document.getElementById('logCount');
            logCount.textContent = `(${allLogs.length}æ¡)`;
        }
        
        // æ¸…ç©ºæ—¥å¿—
        async function clearLogs() {
            try {
                const response = await fetch('/logs/clear_logs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    allLogs = [];
                    document.getElementById('logsContent').innerHTML = '';
                    addLogEntry('INFO', 'æ—¥å¿—å·²æ¸…ç©º');
                    updateLogCount();
                    showStatus('æ—¥å¿—å·²æ¸…ç©º', 'success');
                }
            } catch (error) {
                showStatus('æ¸…ç©ºæ—¥å¿—å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æµ‹è¯•è¶…çŸ­äº¤æ˜“(å¸¦æ—¥å¿—)
        async function testUltraShortWithLogs() {
            addLogEntry('INFO', 'å¼€å§‹æµ‹è¯•è¶…çŸ­äº¤æ˜“åˆ†æ...');
            
            try {
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: ['BTC', 'ETH', 'DOT'] })
                });
                
                const data = await response.json();
                if (data.success) {
                    addLogEntry('INFO', `è¶…çŸ­äº¤æ˜“æµ‹è¯•å®Œæˆï¼Œå…±åˆ†æ ${data.total} ä¸ªå¸ç§`);
                    showStatus('è¶…çŸ­äº¤æ˜“æµ‹è¯•å®Œæˆ', 'success');
                } else {
                    addLogEntry('ERROR', `è¶…çŸ­äº¤æ˜“æµ‹è¯•å¤±è´¥: ${data.error}`);
                    showStatus('è¶…çŸ­äº¤æ˜“æµ‹è¯•å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                addLogEntry('ERROR', `è¶…çŸ­äº¤æ˜“æµ‹è¯•å¼‚å¸¸: ${error.message}`);
                showStatus('æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // å¯¼å‡ºæ—¥å¿—
        async function exportLogs() {
            try {
                const levelFilter = document.getElementById('logLevelFilter').value;
                const searchTerm = document.getElementById('logSearch').value;
                
                let url = '/logs/export_logs?';
                if (levelFilter !== 'all') url += `level=${levelFilter}&`;
                if (searchTerm) url += `search=${encodeURIComponent(searchTerm)}&`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url2 = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url2;
                    a.download = `logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url2);
                    
                    showStatus(`æ—¥å¿—å·²å¯¼å‡ºï¼Œå…± ${data.count} æ¡`, 'success');
                }
            } catch (error) {
                showStatus('å¯¼å‡ºæ—¥å¿—å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // è¿‡æ»¤æ—¥å¿—
        function filterLogs() {
            const levelFilter = document.getElementById('logLevelFilter').value;
            const searchTerm = document.getElementById('logSearch').value.toLowerCase();
            const logEntries = document.querySelectorAll('.log-entry');
            
            logEntries.forEach(entry => {
                const level = entry.querySelector('.log-level').textContent;
                const message = entry.querySelector('.log-message').textContent.toLowerCase();
                
                let show = true;
                
                if (levelFilter !== 'all' && level !== levelFilter) {
                    show = false;
                }
                
                if (searchTerm && !message.includes(searchTerm)) {
                    show = false;
                }
                
                entry.style.display = show ? 'block' : 'none';
            });
        }
        
        // æœç´¢æ—¥å¿—
        function searchLogs() {
            filterLogs();
        }
        
        // ==================== å›¾è¡¨ç›¸å…³å‡½æ•° ====================
        
        // ä»·æ ¼æ ‡ç­¾æ’ä»¶
        const priceLabelsPlugin = {
            id: 'priceLabels',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                const datasets = chart.data.datasets;
                
                datasets.forEach((dataset, datasetIndex) => {
                    if (dataset.label && (dataset.label.startsWith('ä»·æ ¼:') || dataset.label.includes('ä¿¡å·:'))) {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        const data = dataset.data;
                        
                        data.forEach((point, index) => {
                            if (meta.data[index]) {
                                const element = meta.data[index];
                                const x = element.x;
                                const y = element.y;
                                
                                ctx.save();
                                
                                if (dataset.label.startsWith('ä»·æ ¼:')) {
                                    // ç»˜åˆ¶ä»·æ ¼æ ‡ç­¾
                                    const price = dataset.label.replace('ä»·æ ¼: ', '').split(' (')[0];
                                    const signalDesc = dataset.label.includes('(') ? 
                                        dataset.label.split('(')[1].replace(')', '') : '';
                                    
                                    // ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²æˆ–é»˜è®¤é¢œè‰²
                                    const labelBg = dataset.labelBg || 'rgba(0, 0, 0, 0.7)';
                                    const labelColor = dataset.labelColor || '#ffd700';
                                    
                                    // è®¡ç®—æ–‡æœ¬å®½åº¦
                                    ctx.font = 'bold 12px Arial';
                                    const priceWidth = ctx.measureText(price).width;
                                    const descWidth = signalDesc ? ctx.measureText(signalDesc).width : 0;
                                    const maxWidth = Math.max(priceWidth, descWidth);
                                    
                                    // ç»˜åˆ¶èƒŒæ™¯
                                    ctx.fillStyle = labelBg;
                                    ctx.fillRect(x - maxWidth/2 - 5, y - 25, maxWidth + 10, 20);
                                    
                                    // ç»˜åˆ¶ä»·æ ¼æ–‡æœ¬
                                    ctx.fillStyle = labelColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(price, x, y - 12);
                                    
                                    // ç»˜åˆ¶ä¿¡å·æè¿°ï¼ˆå¦‚æœæœ‰ï¼‰
                                    if (signalDesc) {
                                        ctx.font = '10px Arial';
                                        ctx.fillText(signalDesc, x, y - 2);
                                    }
                                } else if (dataset.label.includes('ä¿¡å·:')) {
                                    // ç»˜åˆ¶ä¿¡å·æè¿°
                                    const signalText = dataset.label.split('ä¿¡å·: ')[1];
                                    const isBuy = dataset.label.includes('ä¹°å…¥');
                                    const bgColor = isBuy ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                                    const textColor = '#ffffff';
                                    
                                    // è®¡ç®—æ–‡æœ¬å®½åº¦
                                    ctx.font = 'bold 10px Arial';
                                    const textWidth = ctx.measureText(signalText).width;
                                    
                                    // ç»˜åˆ¶èƒŒæ™¯
                                    ctx.fillStyle = bgColor;
                                    ctx.fillRect(x - textWidth/2 - 5, y - 25, textWidth + 10, 18);
                                    
                                    // ç»˜åˆ¶æ–‡æœ¬
                                    ctx.fillStyle = textColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(signalText, x, y - 12);
                                }
                                
                                ctx.restore();
                            }
                        });
                    }
                });
            }
        };
        
        // æ³¨å†Œæ’ä»¶
        Chart.register(priceLabelsPlugin);
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const ctx = document.getElementById('emaChart').getContext('2d');
            
            emaChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false // ä½¿ç”¨è‡ªå®šä¹‰å›¾ä¾‹
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1
                        },
                        // æ·»åŠ ä»·æ ¼æ ‡ç­¾æ’ä»¶
                        priceLabels: {
                            enabled: true,
                            color: '#ffd700',
                            fontSize: 12,
                            fontWeight: 'bold',
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            padding: 4,
                            borderRadius: 4
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'MM-dd HH:mm'
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white'
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white',
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // è·å–å›¾è¡¨æ•°æ®
        async function getChartData(symbol, timeframe = '5m') {
            if (!symbol) {
                showStatus('è¯·é€‰æ‹©å¸ç§', 'error');
                return null;
            }
            
            showStatus(`æ­£åœ¨è·å– ${symbol} å›¾è¡¨æ•°æ®...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_chart_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        base_timeframe: timeframe,
                        limit: 200
                    })
                });

                const data = await response.json();
                if (data.success) {
                    chartData = data;
                    showStatus(`${symbol} å›¾è¡¨æ•°æ®è·å–æˆåŠŸ`, 'success');
                    return data;
                } else {
                    showStatus('è·å–å›¾è¡¨æ•°æ®å¤±è´¥: ' + data.error, 'error');
                    return null;
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
                return null;
            }
        }
        
        // æ›´æ–°å›¾è¡¨
        function updateChart(data) {
            if (!data || !emaChart) return;
            
            const baseData = data.base_data;
            const timeframeData = data.timeframe_data;
            const crossPoints = data.cross_points;
            
            // å‡†å¤‡æ—¶é—´æ ‡ç­¾
            const labels = baseData.timestamps.map(ts => new Date(ts));
            
            // å®šä¹‰é¢œè‰²
            const colors = {
                '1m': '#ff6b6b',    // çº¢è‰²
                '2m': '#4ecdc4',    // é’è‰²
                '3m': '#45b7d1',    // è“è‰²
                '5m': '#96ceb4',    // ç»¿è‰²
                'ema89': '#feca57', // é»„è‰²
                'ema144': '#ff6b9d', // ç²‰çº¢è‰²
                'ema233': '#ff9ff3', // ç²‰è‰²
                'ema365': '#54a0ff', // è“è‰²
                'ma89': '#feca57',  // é»„è‰²ï¼ˆè™šçº¿ï¼‰
                'ma144': '#ff6b9d', // ç²‰çº¢è‰²ï¼ˆè™šçº¿ï¼‰
                'ma233': '#ff9ff3', // ç²‰è‰²ï¼ˆè™šçº¿ï¼‰
                'ma365': '#54a0ff'  // è“è‰²ï¼ˆè™šçº¿ï¼‰
            };
            
            // å‡†å¤‡æ•°æ®é›†
            const datasets = [];
            
            // æ·»åŠ ä»·æ ¼çº¿ï¼ˆå¢åŠ ç²—åº¦ï¼‰
            datasets.push({
                label: 'ä»·æ ¼',
                data: baseData.prices.map((price, index) => ({
                    x: labels[index],
                    y: price
                })),
                borderColor: '#ffffff',
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 3, // ä»2å¢åŠ åˆ°3
                pointRadius: 0,
                tension: 0.1
            });
            
            // æ·»åŠ å¤šæ—¶é—´å‘¨æœŸEMA365
            Object.entries(timeframeData).forEach(([timeframe, values]) => {
                if (values && values.some(v => v !== null)) {
                    datasets.push({
                        label: `${timeframe} EMA365`,
                        data: values.map((value, index) => ({
                            x: labels[index],
                            y: value
                        })).filter(point => point.y !== null),
                        borderColor: colors[timeframe],
                        backgroundColor: colors[timeframe] + '20',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1
                    });
                }
            });
            
            // æ·»åŠ EMA89, EMA144, EMA233, EMA365
            if (baseData.ema89 && baseData.ema89.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA89',
                    data: baseData.ema89.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema89,
                    backgroundColor: colors.ema89 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema144 && baseData.ema144.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA144',
                    data: baseData.ema144.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema144,
                    backgroundColor: colors.ema144 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema233 && baseData.ema233.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA233',
                    data: baseData.ema233.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema233,
                    backgroundColor: colors.ema233 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema365 && baseData.ema365.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA365',
                    data: baseData.ema365.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema365,
                    backgroundColor: colors.ema365 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            // æ·»åŠ MA89, MA144, MA233, MA365ï¼ˆè™šçº¿ï¼‰
            if (baseData.ma89 && baseData.ma89.some(v => v !== null)) {
                datasets.push({
                    label: 'MA89',
                    data: baseData.ma89.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma89,
                    backgroundColor: colors.ma89 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // è™šçº¿æ ·å¼
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma144 && baseData.ma144.some(v => v !== null)) {
                datasets.push({
                    label: 'MA144',
                    data: baseData.ma144.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma144,
                    backgroundColor: colors.ma144 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // è™šçº¿æ ·å¼
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma233 && baseData.ma233.some(v => v !== null)) {
                datasets.push({
                    label: 'MA233',
                    data: baseData.ma233.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma233,
                    backgroundColor: colors.ma233 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // è™šçº¿æ ·å¼
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma365 && baseData.ma365.some(v => v !== null)) {
                datasets.push({
                    label: 'MA365',
                    data: baseData.ma365.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma365,
                    backgroundColor: colors.ma365 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // è™šçº¿æ ·å¼
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            // å¤„ç†äº¤å‰ç‚¹ä½ï¼Œæ·»åŠ ä»·æ ¼æ ‡ç­¾å’Œä¹°å–ä¿¡å·
            if (crossPoints) {
                // åˆå¹¶æ‰€æœ‰äº¤å‰ç‚¹å¹¶æŒ‰æ—¶é—´æ’åº
                const allCrosses = [];
                
                if (crossPoints.price_crosses) {
                    crossPoints.price_crosses.forEach(cross => {
                        allCrosses.push({
                            ...cross,
                            type: 'price_cross',
                            displayPrice: cross.price
                        });
                    });
                }
                
                if (crossPoints.indicator_crosses) {
                    crossPoints.indicator_crosses.forEach(cross => {
                        allCrosses.push({
                            ...cross,
                            type: 'indicator_cross',
                            displayPrice: cross.price
                        });
                    });
                }
                
                // æŒ‰æ—¶é—´æ’åº
                allCrosses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // å¤„ç†é‡å çš„ä»·æ ¼æ ‡ç­¾
                const filteredCrosses = filterOverlappingPrices(allCrosses, data.base_data);
                
                // æ·»åŠ ä»·æ ¼æ ‡ç­¾
                filteredCrosses.forEach(cross => {
                    // æ ¹æ®ä¿¡å·ç±»å‹è®¾ç½®æ ‡ç­¾é¢œè‰²
                    let labelColor = '#ffd700'; // é»˜è®¤é‡‘è‰²
                    let labelBg = 'rgba(0, 0, 0, 0.7)';
                    
                    if (cross.signalType === 'sell') {
                        labelColor = '#ff6b6b'; // çº¢è‰²
                        labelBg = 'rgba(255, 0, 0, 0.8)';
                    } else if (cross.signalType === 'buy') {
                        labelColor = '#51cf66'; // ç»¿è‰²
                        labelBg = 'rgba(0, 255, 0, 0.8)';
                    }
                    
                    datasets.push({
                        label: `ä»·æ ¼: ${cross.displayPrice} (${cross.signalDescription})`,
                        data: [{
                            x: new Date(cross.timestamp),
                            y: cross.displayPrice
                        }],
                        borderColor: 'transparent',
                        backgroundColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: false,
                        pointStyle: 'circle',
                        labelColor: labelColor,
                        labelBg: labelBg
                    });
                });
                
                // æ·»åŠ ä¹°å–ä¿¡å·
                const tradingSignals = generateTradingSignals(crossPoints);
                tradingSignals.forEach(signal => {
                    const isStrongSignal = signal.description.includes('å¤šå¤´æ’åˆ—') || signal.description.includes('ç©ºå¤´æ’åˆ—');
                    const isVolumeConfirmed = signal.volume_confirmed;
                    
                    // æ ¹æ®ä¿¡å·å¼ºåº¦å’Œæˆäº¤é‡ç¡®è®¤ç¡®å®šæ˜¾ç¤ºæ ·å¼
                    let signalSize, signalColor, signalStyle;
                    
                    if (isVolumeConfirmed && isStrongSignal) {
                        // å¼ºä¿¡å· + æˆäº¤é‡ç¡®è®¤
                        signalSize = 14;
                        signalColor = signal.type === 'buy' ? '#00ff00' : '#ff0000';
                        signalStyle = 'solid';
                    } else if (isVolumeConfirmed || isStrongSignal) {
                        // å•ä¸€ç¡®è®¤
                        signalSize = 10;
                        signalColor = signal.type === 'buy' ? '#90ee90' : '#ffa0a0';
                        signalStyle = 'solid';
                    } else {
                        // æ— ç¡®è®¤
                        signalSize = 8;
                        signalColor = signal.type === 'buy' ? '#d0f0d0' : '#ffd0d0';
                        signalStyle = 'dashed';
                    }
                    
                    const signalLabel = `${signal.type === 'buy' ? 'ä¹°å…¥' : 'å–å‡º'}ä¿¡å·: ${signal.description}${isVolumeConfirmed ? ' âœ“' : ''}`;
                    
                    datasets.push({
                        label: signalLabel,
                        data: [{
                            x: new Date(signal.timestamp),
                            y: signal.price
                        }],
                        borderColor: signalColor,
                        backgroundColor: signalColor,
                        borderWidth: signalSize > 10 ? 4 : 3,
                        pointRadius: signalSize,
                        pointHoverRadius: signalSize + 4,
                        showLine: false,
                        pointStyle: signal.type === 'buy' ? 'triangle' : 'triangleDown',
                        borderDash: signalStyle === 'dashed' ? [5, 5] : []
                    });
                });
            }
            
            // æ›´æ–°å›¾è¡¨æ•°æ®
            emaChart.data.labels = labels;
            emaChart.data.datasets = datasets;
            emaChart.update();
            
            // æ›´æ–°å›¾ä¾‹
            updateChartLegend(datasets);
            
            // æ›´æ–°äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿
            updateCrossPointsInfo(crossPoints);
        }
        
        // æ›´æ–°å›¾è¡¨å›¾ä¾‹
        function updateChartLegend(datasets) {
            const legendContainer = document.getElementById('chartLegend');
            let html = '';
            
            datasets.forEach(dataset => {
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${dataset.borderColor}"></div>
                        <span>${dataset.label}</span>
                    </div>
                `;
            });
            
            legendContainer.innerHTML = html;
        }
        
        // æ˜¾ç¤ºå›¾è¡¨
        function showChart(symbol) {
            currentChartSymbol = symbol;
            const chartSection = document.getElementById('chartSection');
            chartSection.style.display = 'block';
            
            // æ›´æ–°å¸ç§é€‰æ‹©å™¨
            const symbolSelect = document.getElementById('chartSymbolSelect');
            symbolSelect.value = symbol;
            
            // è·å–å›¾è¡¨æ•°æ®å¹¶æ›´æ–°
            getChartData(symbol, currentChartTimeframe).then(data => {
                if (data) {
                    updateChart(data);
                }
            });
        }
        
        // æ›´æ–°å›¾è¡¨å¸ç§
        function updateChartSymbol() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const symbol = symbolSelect.value;
            
            if (symbol) {
                currentChartSymbol = symbol;
                getChartData(symbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // æ›´æ–°å›¾è¡¨æ—¶é—´å‘¨æœŸ
        function updateChartTimeframe() {
            const timeframeSelect = document.getElementById('chartTimeframeSelect');
            const timeframe = timeframeSelect.value;
            
            if (currentChartSymbol) {
                currentChartTimeframe = timeframe;
                getChartData(currentChartSymbol, timeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // åˆ·æ–°å›¾è¡¨
        function refreshChart() {
            if (currentChartSymbol) {
                getChartData(currentChartSymbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©å¸ç§', 'error');
            }
        }
        
        // åˆ‡æ¢å›¾è¡¨æ˜¾ç¤º/éšè—
        function toggleChartVisibility() {
            const chartSection = document.getElementById('chartSection');
            if (chartSection.style.display === 'none') {
                chartSection.style.display = 'block';
                if (currentChartSymbol) {
                    refreshChart();
                }
            } else {
                chartSection.style.display = 'none';
            }
        }
        
        // åˆå§‹åŒ–å¸ç§é€‰æ‹©å™¨
        function initChartSymbolSelect() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const mainSymbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'];
            
            mainSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                symbolSelect.appendChild(option);
            });
        }
        
        // æ›´æ–°äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿
        function updateCrossPointsInfo(crossPoints) {
            const panel = document.getElementById('crossPointsPanel');
            const priceList = document.getElementById('priceCrossList');
            const indicatorList = document.getElementById('indicatorCrossList');
            
            if (!crossPoints || (!crossPoints.price_crosses.length && !crossPoints.indicator_crosses.length)) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            // æ›´æ–°ä»·æ ¼äº¤å‰ç‚¹åˆ—è¡¨
            priceList.innerHTML = '';
            if (crossPoints.price_crosses && crossPoints.price_crosses.length > 0) {
                crossPoints.price_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>ä»·æ ¼ Ã— ${cross.indicator}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    priceList.appendChild(item);
                });
            } else {
                priceList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">æš‚æ— ä»·æ ¼äº¤å‰ç‚¹</div>';
            }
            
            // æ›´æ–°å‡çº¿äº¤å‰ç‚¹åˆ—è¡¨
            indicatorList.innerHTML = '';
            if (crossPoints.indicator_crosses && crossPoints.indicator_crosses.length > 0) {
                crossPoints.indicator_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>${cross.indicator1} Ã— ${cross.indicator2}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    indicatorList.appendChild(item);
                });
            } else {
                indicatorList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">æš‚æ— å‡çº¿äº¤å‰ç‚¹</div>';
            }
        }
        
        // åˆ‡æ¢äº¤å‰ç‚¹ä½æ ‡ç­¾é¡µ
        function showCrossTab(tabType) {
            // æ›´æ–°æ ‡ç­¾æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('.cross-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabType === 'price') {
                document.getElementById('priceCrossPoints').classList.add('active');
            } else {
                document.getElementById('indicatorCrossPoints').classList.add('active');
            }
        }
        
        // åˆ†æå±€éƒ¨é¡¶åº•æ’åˆ—
        function analyzeLocalTopBottom(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000 // 1åˆ†é’Ÿå†…
                );
                
                if (crossIndex < 10 || crossIndex >= chartData.prices.length - 10) {
                    return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
                }
                
                // è·å–äº¤å‰ç‚¹å‰åçš„ä»·æ ¼æ•°æ®
                const beforePrices = chartData.prices.slice(Math.max(0, crossIndex - 10), crossIndex);
                const afterPrices = chartData.prices.slice(crossIndex, Math.min(chartData.prices.length, crossIndex + 10));
                const currentPrice = chartData.prices[crossIndex];
                
                // åˆ†æEMAæ’åˆ—
                const ema89 = chartData.ema89[crossIndex];
                const ema144 = chartData.ema144[crossIndex];
                const ema233 = chartData.ema233[crossIndex];
                const ema365 = chartData.ema365[crossIndex];
                
                // åˆ¤æ–­EMAæ’åˆ—
                const isBullishArrangement = ema89 > ema144 && ema144 > ema233 && ema233 > ema365;
                const isBearishArrangement = ema89 < ema144 && ema144 < ema233 && ema233 < ema365;
                
                // åˆ†æä»·æ ¼ä½ç½®
                const beforeMax = Math.max(...beforePrices.filter(p => p !== null));
                const beforeMin = Math.min(...beforePrices.filter(p => p !== null));
                const afterMax = Math.max(...afterPrices.filter(p => p !== null));
                const afterMin = Math.min(...afterPrices.filter(p => p !== null));
                
                // åˆ¤æ–­å±€éƒ¨é¡¶åº•
                let isLocalTop = false;
                let isLocalBottom = false;
                let confidence = 0;
                
                // å±€éƒ¨é¡¶éƒ¨åˆ¤æ–­ï¼šä»·æ ¼åœ¨äº¤å‰ç‚¹é™„è¿‘è¾¾åˆ°å±€éƒ¨é«˜ç‚¹ï¼Œä¸”EMAæ’åˆ—åç©º
                if (currentPrice >= beforeMax * 0.98 && currentPrice >= afterMax * 0.98) {
                    if (isBearishArrangement || ema89 < ema233) {
                        isLocalTop = true;
                        confidence = 0.8;
                    }
                }
                
                // å±€éƒ¨åº•éƒ¨åˆ¤æ–­ï¼šä»·æ ¼åœ¨äº¤å‰ç‚¹é™„è¿‘è¾¾åˆ°å±€éƒ¨ä½ç‚¹ï¼Œä¸”EMAæ’åˆ—åå¤š
                if (currentPrice <= beforeMin * 1.02 && currentPrice <= afterMin * 1.02) {
                    if (isBullishArrangement || ema89 > ema233) {
                        isLocalBottom = true;
                        confidence = 0.8;
                    }
                }
                
                return { isLocalTop, isLocalBottom, confidence, emaArrangement: isBullishArrangement ? 'bullish' : 'bearish' };
                
            } catch (error) {
                console.error('åˆ†æå±€éƒ¨é¡¶åº•å¤±è´¥:', error);
                return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
            }
        }
        
        // å¤„ç†é‡å çš„ä»·æ ¼æ ‡ç­¾
        function filterOverlappingPrices(crosses, chartData) {
            if (crosses.length === 0) return [];
            
            const filtered = [];
            const minDistance = 0.02; // æœ€å°è·ç¦»ï¼ˆ2%ï¼‰
            
            for (let i = 0; i < crosses.length; i++) {
                const current = crosses[i];
                let shouldAdd = true;
                
                // åˆ†æå±€éƒ¨é¡¶åº•
                const topBottomAnalysis = analyzeLocalTopBottom(current, chartData);
                
                // æ ¹æ®åˆ†æç»“æœè°ƒæ•´æ˜¾ç¤ºä»·æ ¼
                if (topBottomAnalysis.isLocalTop && topBottomAnalysis.confidence > 0.6) {
                    // å±€éƒ¨é¡¶éƒ¨ï¼šæ˜¾ç¤ºæœ€é«˜ä»·æ ¼ï¼Œé€‚åˆåšç©º
                    current.displayPrice = getLocalMaxPrice(current, chartData);
                    current.signalType = 'sell';
                    current.signalDescription = 'å±€éƒ¨é¡¶éƒ¨ï¼Œé€‚åˆåšç©º';
                } else if (topBottomAnalysis.isLocalBottom && topBottomAnalysis.confidence > 0.6) {
                    // å±€éƒ¨åº•éƒ¨ï¼šæ˜¾ç¤ºåŸä»·æ ¼ï¼Œé€‚åˆåšå¤š
                    current.displayPrice = current.price;
                    current.signalType = 'buy';
                    current.signalDescription = 'å±€éƒ¨åº•éƒ¨ï¼Œé€‚åˆåšå¤š';
                } else {
                    // ä¸­æ€§ï¼šæ˜¾ç¤ºåŸä»·æ ¼
                    current.displayPrice = current.price;
                    current.signalType = 'neutral';
                    current.signalDescription = 'ä¸­æ€§ä¿¡å·';
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å·²æ·»åŠ çš„ç‚¹å¤ªè¿‘
                for (let j = 0; j < filtered.length; j++) {
                    const existing = filtered[j];
                    const priceDiff = Math.abs(current.displayPrice - existing.displayPrice) / existing.displayPrice;
                    const timeDiff = Math.abs(new Date(current.timestamp) - new Date(existing.timestamp)) / (1000 * 60 * 60); // å°æ—¶
                    
                    // å¦‚æœä»·æ ¼å’Œæ—¶é—´éƒ½å¾ˆæ¥è¿‘ï¼Œåˆ™è·³è¿‡
                    if (priceDiff < minDistance && timeDiff < 24) {
                        shouldAdd = false;
                        break;
                    }
                }
                
                if (shouldAdd) {
                    filtered.push(current);
                }
            }
            
            return filtered;
        }
        
        // è·å–å±€éƒ¨æœ€é«˜ä»·æ ¼
        function getLocalMaxPrice(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000
                );
                
                if (crossIndex < 5 || crossIndex >= chartData.prices.length - 5) {
                    return cross.price;
                }
                
                // è·å–äº¤å‰ç‚¹å‰å10ä¸ªç‚¹çš„ä»·æ ¼
                const startIndex = Math.max(0, crossIndex - 10);
                const endIndex = Math.min(chartData.prices.length, crossIndex + 10);
                const localPrices = chartData.prices.slice(startIndex, endIndex).filter(p => p !== null);
                
                return Math.max(...localPrices);
            } catch (error) {
                console.error('è·å–å±€éƒ¨æœ€é«˜ä»·æ ¼å¤±è´¥:', error);
                return cross.price;
            }
        }
        
        // ç”Ÿæˆä¹°å–ä¿¡å·
        function generateTradingSignals(crossPoints) {
            const signals = [];
            
            if (!crossPoints || !crossPoints.indicator_crosses) {
                return signals;
            }
            
            // åˆ†æEMAæ’åˆ—å’Œäº¤å‰ç‚¹
            const emaCrosses = crossPoints.indicator_crosses.filter(cross => 
                cross.indicator1.includes('EMA') && cross.indicator2.includes('EMA')
            );
            
            // æŒ‰æ—¶é—´æ’åº
            emaCrosses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // åˆ†ææ¯ä¸ªäº¤å‰ç‚¹
            emaCrosses.forEach(cross => {
                const { indicator1, indicator2, type, timestamp, price } = cross;
                
                // ä¹°å…¥ä¿¡å·æ¡ä»¶
                if (isBuySignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'buy');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'buy',
                        description: getBuySignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
                
                // å–å‡ºä¿¡å·æ¡ä»¶
                if (isSellSignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'sell');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'sell',
                        description: getSellSignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
            });
            
            return signals;
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºä¹°å…¥ä¿¡å·
        function isBuySignal(indicator1, indicator2, type, crossPoints) {
            // æ¡ä»¶1ï¼šEMA89çªç ´EMA144/233/365ï¼Œå½¢æˆå¤šå¤´æ’åˆ—
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'golden_cross') {
                    return true; // EMA89ä¸Šç©¿å…¶ä»–EMA
                }
            }
            
            // æ¡ä»¶2ï¼šå¸‚åœºå›è°ƒè‡³EMA233æˆ–EMA144ï¼Œæ”¯æ’‘åå¼¹
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === 'ä»·æ ¼') {
                if (type === 'golden_cross') {
                    return true; // ä»·æ ¼ä»ä¸‹æ–¹çªç ´EMAæ”¯æ’‘ä½
                }
            }
            
            return false;
        }
        
        // æ£€æŸ¥æˆäº¤é‡ç¡®è®¤
        function checkVolumeConfirmation(cross, signalType) {
            if (cross.volume_confirmation) {
                const volConf = cross.volume_confirmation;
                if (signalType === 'buy') {
                    // ä¹°å…¥ä¿¡å·éœ€è¦æˆäº¤é‡å¢åŠ ç¡®è®¤
                    return volConf.confirmed && volConf.volume_ratio > 1.2;
                } else {
                    // å–å‡ºä¿¡å·æˆäº¤é‡å˜åŒ–ç¡®è®¤
                    return volConf.confirmed && (volConf.volume_ratio > 1.1 || volConf.volume_ratio < 0.8);
                }
            }
            return false; // æ²¡æœ‰æˆäº¤é‡æ•°æ®æ—¶é»˜è®¤ä¸ç¡®è®¤
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºå–å‡ºä¿¡å·
        function isSellSignal(indicator1, indicator2, type, crossPoints) {
            // æ¡ä»¶1ï¼šEMA89è·Œç ´EMA144/233/365ï¼Œå½¢æˆç©ºå¤´æ’åˆ—
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'death_cross') {
                    return true; // EMA89ä¸‹ç©¿å…¶ä»–EMA
                }
            }
            
            // æ¡ä»¶2ï¼šå¸‚åœºå›è°ƒè‡³EMA233æˆ–EMA144ï¼Œæœªçªç ´ï¼Œå½¢æˆä¸‹è¡Œå‹åŠ›
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === 'ä»·æ ¼') {
                if (type === 'death_cross') {
                    return true; // ä»·æ ¼ä»ä¸Šæ–¹è·Œç ´EMAé˜»åŠ›ä½
                }
            }
            
            return false;
        }
        
        // è·å–ä¹°å…¥ä¿¡å·æè¿°
        function getBuySignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89çªç ´${indicator2}ï¼Œå¤šå¤´æ’åˆ—å½¢æˆ`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `ä»·æ ¼çªç ´${indicator1}æ”¯æ’‘ä½ï¼Œåå¼¹ä¿¡å·`;
            }
            return 'ä¹°å…¥ä¿¡å·';
        }
        
        // è·å–å–å‡ºä¿¡å·æè¿°
        function getSellSignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89è·Œç ´${indicator2}ï¼Œç©ºå¤´æ’åˆ—å½¢æˆ`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `ä»·æ ¼è·Œç ´${indicator1}é˜»åŠ›ä½ï¼Œä¸‹è¡Œå‹åŠ›`;
            }
            return 'å–å‡ºä¿¡å·';
        }
    </script>
</body>
</html>
