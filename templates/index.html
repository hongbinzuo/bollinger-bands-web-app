<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸ƒæ—å¸¦ç­–ç•¥ç³»ç»Ÿ</title>
    <!-- Chart.js å›¾è¡¨åº“ - ä¸»é¡µé¢ä½¿ç”¨ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" onerror="console.error('Chart.jsåŠ è½½å¤±è´¥')"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js" onerror="console.error('Chart.jsé€‚é…å™¨åŠ è½½å¤±è´¥')"></script>
    <!-- Favicon to avoid 404 noise -->
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <!-- Lightweight Charts æœ¬åœ°é™æ€åº“ï¼ˆç”¨äºKçº¿ç»˜åˆ¶Tabï¼‰ -->
    <script src="/static/vendor/lightweight-charts/lightweight-charts.standalone.production.min.js"></script>
    
    <script>
        // æ˜¾ç¤ºTabå‡½æ•° - éœ€è¦åœ¨HTMLä¹‹å‰å®šä¹‰
        // ç¡®ä¿å…¨å±€å¯ç”¨ï¼Œé¿å…ä½œç”¨åŸŸé—®é¢˜
        window.showTab = function(tabName, event) {
            // éšè—æ‰€æœ‰tabå†…å®¹
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // ç§»é™¤æ‰€æœ‰tabçš„activeç±»
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // æ˜¾ç¤ºé€‰ä¸­çš„tab
            const targetContent = document.getElementById(tabName);
            if (targetContent) {
                targetContent.classList.add('active');
            }
            
            // æ·»åŠ activeç±»åˆ°ç‚¹å‡»çš„tab
            if (event && event.target) {
                event.target.classList.add('active');
            }
            // å¦‚æœåˆ‡åˆ°Kçº¿ç»˜åˆ¶ï¼Œåˆå§‹åŒ–ä¸€æ¬¡
            try {
                if (tabName === 'klineDraw' && window.KLINE && typeof KLINE.init === 'function') {
                    KLINE.init();
                }
            } catch (e) { console.warn('KLINE init error', e); }
        }
        
        // æ˜¾ç¤ºäº¤å‰ç‚¹Tabå‡½æ•°
        window.showCrossTab = function(tabType, event) {
            // æ›´æ–°æ ‡ç­¾æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('.cross-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabType === 'price') {
                document.getElementById('priceCrossPoints').classList.add('active');
            } else {
                document.getElementById('indicatorCrossPoints').classList.add('active');
            }
        }
        
        // å¤šæ—¶é—´æ¡†æ¶ç›¸å…³å‡½æ•° - éœ€è¦åœ¨HTMLä¹‹å‰å®šä¹‰
        async function analyzeMultiTimeframeSymbols() {
            try {
                // è·å–ç­–ç•¥ç±»å‹
                const strategyType = document.getElementById('strategyTypeSelect').value;
                showStatus(`æ­£åœ¨è·å–å‰500ä¸ªå¸ç§ (ç­–ç•¥: ${strategyType === 'original' ? 'åŸç­–ç•¥' : 'ä¿®æ”¹ç­–ç•¥'})...`, 'info');
                
                // ä½¿ç”¨å®‰å…¨çš„fetchå‡½æ•°
                const response = await safeFetch('/multi_timeframe/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`æˆåŠŸè·å– ${data.count} ä¸ªå¸ç§`, 'success');
                    
                    // è®¾ç½®å…¨å±€å˜é‡
                    if (typeof allSymbols === 'undefined') {
                        window.allSymbols = [];
                    }
                    allSymbols = data.symbols;
                    
                    // é‡ç½®åˆ†é¡µå’Œç¼“å­˜
                    if (typeof currentPage === 'undefined') {
                        window.currentPage = 1;
                    }
                    currentPage = 1;
                    
                    // ã€ä¿®å¤ã€‘é‡ç½®ä¿¡å·ç¼“å­˜å’Œåˆ†æçŠ¶æ€ï¼Œå¼ºåˆ¶é‡æ–°åˆ†æ
                    allCachedSignals = [];
                    analysisProgress = {
                        total: 0,
                        analyzed: 0,
                        isAnalyzing: false
                    };
                    
                    // å¼€å§‹åˆ†æï¼Œä¼ é€’ç­–ç•¥ç±»å‹
                    await analyzeCurrentPage(strategyType);
                } else {
                    showStatus(`è·å–å¸ç§å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('analyzeMultiTimeframeSymbols error:', error);
                showStatus(`è·å–å¸ç§å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        async function getMultiTimeframeTopSymbols() {
            try {
                showStatus('æ­£åœ¨è·å–å‰500ä¸ªå¸ç§...', 'info');
                
                // ä½¿ç”¨å®‰å…¨çš„fetchå‡½æ•°
                const response = await safeFetch('/multi_timeframe/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`æˆåŠŸè·å– ${data.count} ä¸ªå¸ç§`, 'success');
                    
                    // è®¾ç½®å…¨å±€å˜é‡
                    if (typeof allSymbols === 'undefined') {
                        window.allSymbols = [];
                    }
                    allSymbols = data.symbols;
                    
                    // æ˜¾ç¤ºå¸ç§åˆ—è¡¨
                    let symbolsHtml = '<h4>å‰50ä¸ªå¸ç§:</h4><ul>';
                    data.symbols.slice(0, 50).forEach((symbol, index) => {
                        symbolsHtml += `<li>${index + 1}. ${symbol}</li>`;
                    });
                    symbolsHtml += '</ul>';
                    symbolsHtml += `<p><strong>æ€»è®¡: ${data.count} ä¸ªå¸ç§</strong></p>`;
                    symbolsHtml += '<p><em>ç°åœ¨å¯ä»¥ç‚¹å‡»"åˆ†æå‰500å¸ç§"æŒ‰é’®å¼€å§‹åˆ†æ</em></p>';
                    
                    document.getElementById('multiTimeframeResults').innerHTML = symbolsHtml;
                } else {
                    showStatus(`è·å–å¸ç§å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('getMultiTimeframeTopSymbols error:', error);
                showStatus(`è·å–å¸ç§å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        function clearMultiTimeframeCache() {
            // æ¸…é™¤ç¼“å­˜å’Œé‡ç½®çŠ¶æ€
            allCachedSignals = [];
            analysisProgress = {
                total: 0,
                analyzed: 0,
                isAnalyzing: false
            };
            currentPage = 1;
            totalPages = 0;
            updatePaginationControls();
            
            // æ¸…ç©ºæ˜¾ç¤ºåŒºåŸŸ
            const resultsDiv = document.getElementById('multiTimeframeResults');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<p>ç¼“å­˜å·²æ¸…é™¤ï¼Œè¯·é‡æ–°å¼€å§‹åˆ†æ</p>';
            }
            
            showStatus('å¤šæ—¶é—´æ¡†æ¶ç¼“å­˜å·²æ¸…é™¤', 'success');
        }
        
        // ã€æ–°å¢ã€‘åˆ†é¡µåŠŸèƒ½æµ‹è¯•
        function testPagination() {
            console.log('å¼€å§‹æµ‹è¯•åˆ†é¡µåŠŸèƒ½...');
            console.log(`å½“å‰çŠ¶æ€: ç¬¬${currentPage}é¡µï¼Œå…±${totalPages}é¡µ`);
            console.log(`ç¼“å­˜ä¿¡å·æ•°é‡: ${allCachedSignals.length}`);
            
            if (allCachedSignals.length === 0) {
                showStatus('è¯·å…ˆåˆ†æå¸ç§ä»¥è·å–ä¿¡å·æ•°æ®', 'warning');
                return;
            }
            
            // æµ‹è¯•æ˜¾ç¤ºç¬¬ä¸€é¡µ
            currentPage = 1;
            displayCurrentPageSignals(50);
            updatePaginationControls();
            
            showStatus(`åˆ†é¡µæµ‹è¯•: æ˜¾ç¤ºç¬¬${currentPage}é¡µ (å…±${totalPages}é¡µ)`, 'info');
            
            // 2ç§’åæµ‹è¯•ä¸‹ä¸€é¡µ
            if (totalPages > 1) {
                setTimeout(() => {
                    currentPage = 2;
                    displayCurrentPageSignals(50);
                    updatePaginationControls();
                    showStatus(`åˆ†é¡µæµ‹è¯•: åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
                    
                    // å†2ç§’åå›åˆ°ç¬¬ä¸€é¡µ
                    setTimeout(() => {
                        currentPage = 1;
                        displayCurrentPageSignals(50);
                        updatePaginationControls();
                        showStatus('åˆ†é¡µæµ‹è¯•å®Œæˆ: å›åˆ°ç¬¬1é¡µ', 'success');
                    }, 2000);
                }, 2000);
            }
        }
        
        // ã€æ–°å¢ã€‘è‡ªåŠ¨æµ‹è¯•åŠŸèƒ½
        async function runAutoTest() {
            showStatus('å¼€å§‹è¿è¡Œè‡ªåŠ¨æµ‹è¯•...', 'info');
            
            try {
                // æµ‹è¯•1: è·å–å¸ç§åˆ—è¡¨
                showStatus('æµ‹è¯•1: è·å–å¸ç§åˆ—è¡¨...', 'info');
                const symbolsResponse = await safeFetch('/multi_timeframe/get_top_symbols');
                const symbolsData = await symbolsResponse.json();
                
                if (!symbolsData.success) {
                    throw new Error(`è·å–å¸ç§å¤±è´¥: ${symbolsData.error}`);
                }
                
                const testSymbols = symbolsData.symbols.slice(0, 3); // åªæµ‹è¯•å‰3ä¸ªå¸ç§
                showStatus(`[PASS] æµ‹è¯•1é€šè¿‡: è·å–åˆ° ${symbolsData.symbols.length} ä¸ªå¸ç§ï¼Œæµ‹è¯•ç”¨ ${testSymbols.length} ä¸ª`, 'success');
                
                // æµ‹è¯•2: å•å¸ç§åˆ†æ
                showStatus(`æµ‹è¯•2: å•å¸ç§åˆ†æ ${testSymbols[0]}...`, 'info');
                const singleResponse = await safeFetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    body: JSON.stringify({ symbol: testSymbols[0] })
                });
                const singleData = await singleResponse.json();
                
                if (!singleData.success) {
                    throw new Error(`å•å¸ç§åˆ†æå¤±è´¥: ${singleData.error}`);
                }
                
                showStatus(`[PASS] æµ‹è¯•2é€šè¿‡: åˆ†æäº† ${singleData.total_timeframes_analyzed} ä¸ªæ—¶é—´æ¡†æ¶`, 'success');
                
                // æµ‹è¯•3: å°æ‰¹é‡åˆ†æ
                showStatus(`æµ‹è¯•3: æ‰¹é‡åˆ†æ ${testSymbols.length} ä¸ªå¸ç§...`, 'info');
                const batchResponse = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbols: testSymbols,
                        page: 1,
                        page_size: 50
                    })
                });
                const batchData = await batchResponse.json();
                
                if (!batchData.success) {
                    throw new Error(`æ‰¹é‡åˆ†æå¤±è´¥: ${batchData.error}`);
                }
                
                const signals = batchData.signals || [];
                showStatus(`[PASS] æµ‹è¯•3é€šè¿‡: ç”Ÿæˆ ${signals.length} ä¸ªä¿¡å·`, 'success');
                
                // æµ‹è¯•4: åˆ†é¡µåŠŸèƒ½
                showStatus('æµ‹è¯•4: åˆ†é¡µåŠŸèƒ½...', 'info');
                const pagination = batchData.pagination || {};
                if (pagination.total_pages > 1) {
                    // æµ‹è¯•ç¬¬2é¡µ
                    const page2Response = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                        method: 'POST',
                        body: JSON.stringify({
                            symbols: testSymbols,
                            page: 2,
                            page_size: 10
                        })
                    });
                    const page2Data = await page2Response.json();
                    
                    if (page2Data.success) {
                        showStatus(`[PASS] æµ‹è¯•4é€šè¿‡: åˆ†é¡µåŠŸèƒ½æ­£å¸¸ï¼Œç¬¬2é¡µæœ‰ ${page2Data.signals.length} ä¸ªä¿¡å·`, 'success');
                    } else {
                        showStatus(`[WARN] æµ‹è¯•4è­¦å‘Š: ç¬¬2é¡µè·å–å¤±è´¥`, 'warning');
                    }
                } else {
                    showStatus(`[PASS] æµ‹è¯•4é€šè¿‡: åˆ†é¡µä¿¡æ¯æ­£ç¡® (æ€»è®¡ ${pagination.total_pages} é¡µ)`, 'success');
                }
                
                // æµ‹è¯•5: é”™è¯¯å¤„ç†
                showStatus('æµ‹è¯•5: é”™è¯¯å¤„ç†...', 'info');
                const errorResponse = await safeFetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    body: JSON.stringify({ symbol: 'INVALIDCOIN12345' })
                });
                const errorData = await errorResponse.json();
                
                // é”™è¯¯å¤„ç†åº”è¯¥è¿”å›æˆåŠŸä½†ç»“æœå¯èƒ½ä¸ºç©ºæˆ–åŒ…å«é”™è¯¯
                showStatus('[PASS] æµ‹è¯•5é€šè¿‡: é”™è¯¯å¤„ç†æ­£å¸¸', 'success');
                
                // å…¨éƒ¨æµ‹è¯•å®Œæˆ
                showStatus('[SUCCESS] æ‰€æœ‰è‡ªåŠ¨æµ‹è¯•é€šè¿‡ï¼ç³»ç»Ÿå·¥ä½œæ­£å¸¸', 'success');
                
            } catch (error) {
                console.error('è‡ªåŠ¨æµ‹è¯•å¤±è´¥:', error);
                showStatus(`[FAIL] è‡ªåŠ¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // é€šç”¨å·¥å…·å‡½æ•°
        // showStatuså‡½æ•°å·²åœ¨åé¢å®šä¹‰ï¼Œè¿™é‡Œåˆ é™¤é‡å¤å®šä¹‰
        
        // è¿æ¥çŠ¶æ€ç›‘æ§
        let connectionStatus = 'connected';
        let lastHeartbeat = Date.now();
        
        // å¿ƒè·³æ£€æµ‹å‡½æ•°
        async function checkConnection() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/health', { 
                    method: 'HEAD',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    connectionStatus = 'connected';
                    lastHeartbeat = Date.now();
                    return true;
                }
                return false;
            } catch (error) {
                // é™é»˜å¤„ç†è¿æ¥æ£€æµ‹å¤±è´¥ï¼Œé¿å…æ§åˆ¶å°å™ªéŸ³
                if (error.name !== 'AbortError') {
                    console.warn('è¿æ¥æ£€æµ‹å¤±è´¥:', error.message);
                }
                connectionStatus = 'disconnected';
                return false;
            }
        }
        
        // å®šæœŸå¿ƒè·³æ£€æµ‹ï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
        let heartbeatInterval = null;
        function startHeartbeat() {
            if (!heartbeatInterval) {
                heartbeatInterval = setInterval(async () => {
                    const now = Date.now();
                    if (now - lastHeartbeat > 60000) { // 60ç§’æ— å¿ƒè·³
                        await checkConnection();
                    }
                }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
            }
        }
        
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }
        
        // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶æ§åˆ¶å¿ƒè·³
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopHeartbeat();
            } else {
                startHeartbeat();
                checkConnection(); // é¡µé¢æ¢å¤æ—¶ç«‹å³æ£€æŸ¥ä¸€æ¬¡
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶å¯åŠ¨å¿ƒè·³
        if (!document.hidden) {
            startHeartbeat();
        }
        
        // å…¨å±€é”™è¯¯å¤„ç†ï¼ˆè¿‡æ»¤ç¬¬ä¸‰æ–¹è„šæœ¬å™ªéŸ³/ç©ºé”™è¯¯ï¼‰
        window.addEventListener('error', function(event) {
            const src = String((event && (event.filename || (event.error && event.error.stack) || '')) || '');
            const msg = String((event && (event.message || (event.error && event.error.message))) || '');
            // å¿½ç•¥æœªçŸ¥/ç©ºé”™è¯¯ä¸ç¬¬ä¸‰æ–¹æ³¨å…¥è„šæœ¬ï¼ˆå¦‚ qk-content.js/lockdownï¼‰
            if (!msg || /(qk-content\.js|lockdown-install\.js|SES_UNCAUGHT_EXCEPTION)/.test(src + ' ' + msg)) {
                return;
            }
            console.error('Global error:', event.error || msg);
            if (msg.includes('port closed') || msg.includes('runtime.lastError') || msg.includes('message port closed')) {
                connectionStatus = 'error';
                showStatus('æ£€æµ‹åˆ°è¿æ¥é—®é¢˜ï¼Œæ­£åœ¨å°è¯•è‡ªåŠ¨æ¢å¤...', 'warning');
                setTimeout(async () => {
                    const recovered = await checkConnection();
                    showStatus(recovered ? 'è¿æ¥å·²æ¢å¤' : 'è¿æ¥æ¢å¤å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', recovered ? 'success' : 'error');
                }, 2000);
            }
        });
        
        // å¤„ç†æœªæ•è·çš„Promiseé”™è¯¯ï¼ˆè¿‡æ»¤ç¬¬ä¸‰æ–¹/ç©ºé”™è¯¯ï¼‰
        window.addEventListener('unhandledrejection', function(event) {
            const reason = event && event.reason;
            const msg = String((reason && (reason.message || reason)) || '');
            if (!msg || /(qk-content\.js|lockdown-install\.js|SES_UNCAUGHT_EXCEPTION)/.test(msg)) {
                return;
            }
            console.error('Unhandled promise rejection:', reason);
            if (msg.includes('port closed') || msg.includes('runtime.lastError') || msg.includes('message port closed')) {
                connectionStatus = 'error';
                showStatus('æ£€æµ‹åˆ°è¿æ¥é—®é¢˜ï¼Œæ­£åœ¨å°è¯•è‡ªåŠ¨æ¢å¤...', 'warning');
                setTimeout(async () => {
                    const recovered = await checkConnection();
                    showStatus(recovered ? 'è¿æ¥å·²æ¢å¤' : 'è¿æ¥æ¢å¤å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', recovered ? 'success' : 'error');
                }, 2000);
            }
        });
        
        // è¿æ¥çŠ¶æ€æ£€æµ‹
        let connectionRetryCount = 0;
        const maxRetries = 3;
        
        // æ£€æµ‹æµè§ˆå™¨æ‰©å±•å†²çª
        let extensionDetected = false;
        function detectExtensionConflicts() {
            if (extensionDetected !== null && extensionDetected !== undefined) {
                return extensionDetected;
            }
            
            const hasExtensions = window.chrome && window.chrome.runtime;
            extensionDetected = hasExtensions;
            
            if (hasExtensions) {
                console.warn('æ£€æµ‹åˆ°æµè§ˆå™¨æ‰©å±•ï¼Œå¯èƒ½å­˜åœ¨æ¶ˆæ¯ç«¯å£å†²çª');
            }
            return hasExtensions;
        }
        
        // æ˜¾ç¤ºæ‰©å±•å†²çªæç¤º
        function showExtensionConflictWarning() {
            const warningDiv = document.createElement('div');
            warningDiv.id = 'extensionWarning';
            warningDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                color: #856404;
                padding: 15px;
                border-radius: 5px;
                z-index: 10000;
                max-width: 300px;
                font-size: 14px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            `;
            warningDiv.innerHTML = `
                <strong>âš ï¸ æµè§ˆå™¨æ‰©å±•å†²çªæ£€æµ‹</strong><br>
                æ£€æµ‹åˆ°æµè§ˆå™¨æ‰©å±•ï¼Œå¯èƒ½å¯¼è‡´è¿æ¥é—®é¢˜ã€‚<br>
                å»ºè®®ï¼š<br>
                1. ä½¿ç”¨æ— ç—•æ¨¡å¼<br>
                2. ç¦ç”¨å¹¿å‘Šæ‹¦æˆªå™¨<br>
                3. ç¦ç”¨å…¶ä»–å¯èƒ½å¹²æ‰°çš„æ‰©å±•<br>
                <button onclick="this.parentElement.remove()" style="margin-top:10px;padding:5px 10px;background:#007bff;color:white;border:none;border-radius:3px;cursor:pointer;">çŸ¥é“äº†</button>
            `;
            document.body.appendChild(warningDiv);
            
            // 5ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                if (warningDiv.parentElement) {
                    warningDiv.remove();
                }
            }, 10000);
        }
        
        // é¡µé¢åŠ è½½æ—¶æ£€æµ‹æ‰©å±•å†²çª
        if (detectExtensionConflicts()) {
            showExtensionConflictWarning();
        }
        
        // æ™ºèƒ½è¶…æ—¶é…ç½®
        function getTimeoutForUrl(url) {
            if (url.includes('/multi_timeframe/analyze_multiple_symbols')) {
                return 600000; // 10åˆ†é’Ÿ - å¤šå¸ç§åˆ†æ
            } else if (url.includes('/analyze') || url.includes('/signals')) {
                return 300000; // 5åˆ†é’Ÿ - åˆ†æè¯·æ±‚
            } else if (url.includes('/health')) {
                return 5000; // 5ç§’ - å¥åº·æ£€æŸ¥
            } else {
                return 60000; // 1åˆ†é’Ÿ - é»˜è®¤è¯·æ±‚
            }
        }
        
        // å®‰å…¨çš„fetchåŒ…è£…å‡½æ•°
        async function safeFetch(url, options = {}) {
            const timeout = getTimeoutForUrl(url);
            let attempt = 0;
            const maxAttempts = 3;
            
            // æ›´æ–°å¿ƒè·³æ—¶é—´æˆ³
            lastHeartbeat = Date.now();
            
            while (attempt < maxAttempts) {
                attempt++;
                
                try {
                    // åˆ›å»ºAbortControllerç”¨äºè¶…æ—¶æ§åˆ¶
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal,
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache',
                            ...options.headers
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    connectionRetryCount = 0; // é‡ç½®é‡è¯•è®¡æ•°
                    
                    if (!response.ok) {
                        let errorMessage = `HTTP error! status: ${response.status}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error) {
                                errorMessage += ` - ${errorData.error}`;
                            }
                        } catch (e) {
                            // å¿½ç•¥JSONè§£æé”™è¯¯
                        }
                        throw new Error(errorMessage);
                    }
                    
                    return response;
                    
                } catch (error) {
                    console.error(`Safe fetch error (attempt ${attempt}/${maxAttempts}):`, error);
                    
                    // å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯
                    if (attempt === maxAttempts) {
                        if (error.name === 'AbortError') {
                            throw new Error(`è¯·æ±‚è¶…æ—¶ (${timeout/1000}ç§’)ï¼Œè¯·ç¨åé‡è¯•`);
                        }
                        throw error;
                    }
                    
                    // å¤„ç†æ¶ˆæ¯ç«¯å£å…³é—­é”™è¯¯
                    if (error.message.includes('port closed') || 
                        error.message.includes('runtime.lastError') ||
                        error.message.includes('message port closed') ||
                        error.message.includes('The message port closed')) {
                        
                        console.warn(`è¿æ¥ä¸­æ–­ï¼Œç­‰å¾…é‡è¯• (${attempt}/${maxAttempts})`);
                        showStatus(`è¿æ¥ä¸­æ–­ï¼Œæ­£åœ¨é‡è¯• (${attempt}/${maxAttempts})...`, 'warning');
                        
                        // æŒ‡æ•°é€€é¿é‡è¯•
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    // å…¶ä»–é”™è¯¯ä¹Ÿè¿›è¡Œé‡è¯•
                    if (error.name === 'AbortError') {
                        console.warn(`è¯·æ±‚è¶…æ—¶ï¼Œç­‰å¾…é‡è¯• (${attempt}/${maxAttempts})`);
                        showStatus(`è¯·æ±‚è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯• (${attempt}/${maxAttempts})...`, 'warning');
                        
                        const delay = Math.min(1000 * attempt, 3000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    // å…¶ä»–é”™è¯¯ç›´æ¥æŠ›å‡º
                    throw error;
                }
            }
        }
        
        // åˆ†æç›¸å…³å‡½æ•°
        async function analyzeDefault() {
            showStatus('æ­£åœ¨åˆ†æå…¨éƒ¨å¸ç§...', 'success');
            // å®ç°åˆ†æé€»è¾‘
        }
        
        function showAddSymbolModal() {
            document.getElementById('addSymbolModal').style.display = 'block';
        }
        
        function closeAddSymbolModal() {
            document.getElementById('addSymbolModal').style.display = 'none';
        }
        
        function analyzeCustom() {
            showStatus('è‡ªå®šä¹‰åˆ†æåŠŸèƒ½', 'info');
        }
        
        function getSymbols() {
            showStatus('è·å–å¸ç§åˆ—è¡¨åŠŸèƒ½', 'info');
        }
        
        function toggleSortOrder() {
            showStatus('åˆ‡æ¢æ’åºåŠŸèƒ½', 'info');
        }
        
        function changePage(direction) {
            if (direction === -1 && currentPage > 1) {
                currentPage--;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
            } else if (direction === 1 && currentPage < totalPages) {
                currentPage++;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
            }
        }
        
        // æ—¥å†…äº¤æ˜“ç›¸å…³å‡½æ•°ï¼ˆå·²ç§»é™¤ï¼‰
        
        // å›¾è¡¨ç›¸å…³å‡½æ•°
        function refreshChart() {
            showStatus('åˆ·æ–°å›¾è¡¨', 'info');
        }
        
        function toggleChartVisibility() {
            showStatus('åˆ‡æ¢å›¾è¡¨æ˜¾ç¤º', 'info');
        }
        
        // è¶…çŸ­äº¤æ˜“ç›¸å…³å‡½æ•°
        // å¤šæ—¶é—´æ¡†æ¶ç›¸å…³å‡½æ•°
        function validateMultiTimeframeSymbol() {
            showStatus('éªŒè¯å¤šæ—¶é—´æ¡†æ¶å¸ç§', 'info');
        }
        
        function analyzeCustomMultiTimeframeSymbols() {
            showStatus('è‡ªå®šä¹‰å¤šæ—¶é—´æ¡†æ¶åˆ†æ', 'info');
        }
        
        function applyMultiTimeframeFilter() {
            showStatus('åº”ç”¨å¤šæ—¶é—´æ¡†æ¶è¿‡æ»¤', 'info');
        }
        
        function changePageSize() {
            const newPageSize = parseInt(document.getElementById('pageSizeSelect').value);
            if (newPageSize !== 50) {
                showStatus('æ¯é¡µä¿¡å·æ•°é‡ç°åœ¨å›ºå®šä¸º50ä¸ªï¼Œè¯·ä½¿ç”¨åˆ†é¡µæŒ‰é’®æµè§ˆ', 'info');
            }
        }
        
        function previousPage() {
            changePage(-1);
        }
        
        function nextPage() {
            changePage(1);
        }
        
        // æ—¥å¿—ç›¸å…³å‡½æ•°
        function startLogMonitoring() {
            showStatus('å¼€å§‹ç›‘æ§æ—¥å¿—', 'info');
        
        
        function clearLogs() {
            showStatus('æ¸…ç©ºæ—¥å¿—', 'info');
        }
        
        }
        
        function exportLogs() {
            showStatus('å¯¼å‡ºæ—¥å¿—', 'info');
        }
        
        // è®¢å•ç›¸å…³å‡½æ•°
        
        // ç³»ç»Ÿç®¡ç†ç›¸å…³å‡½æ•°
        function clearCache() {
            showStatus('æ¸…é™¤ç¼“å­˜', 'info');
        }
        
        function downloadCSV() {
            showStatus('ä¸‹è½½CSVæŠ¥å‘Š', 'info');
        }
        
        function exportData() {
            showStatus('å¯¼å‡ºæ•°æ®', 'info');
        }
        
        function importData() {
            showStatus('å¯¼å…¥æ•°æ®', 'info');
        }
        
        // æ–æ³¢è§„å¾‹ç ”ç©¶ç›¸å…³å‡½æ•°
        // æ–æ³¢æ¦‚ç‡é¢„æµ‹ç›¸å…³å‡½æ•°

        // æ–æ³¢æ¦‚ç‡åˆ†æä¸»å‡½æ•°
        // æ‰¹é‡æ–æ³¢åˆ†æ
        // æ˜¾ç¤ºæ–æ³¢æ¦‚ç‡ç»“æœ
        // æ˜¾ç¤ºæ‰¹é‡åˆ†æç»“æœ
        // ç»˜åˆ¶æ–æ³¢æ¦‚ç‡å›¾è¡¨
        // ç»˜åˆ¶ä¸‹è¡Œæ–æ³¢æ¦‚ç‡å›¾è¡¨
        // å®æ—¶æ–æ³¢åˆ†æç›¸å…³å‡½æ•°
        let realtimeFibChart = null;
        let realtimeMonitoringInterval = null;

        // å®æ—¶æ–æ³¢åˆ†æä¸»å‡½æ•°
        async function runRealtimeFibonacciAnalysis() {
            try {
                const symbol = document.getElementById('realtimeSymbol').value;
                const timeframe = document.getElementById('realtimeTimeframe').value;
                const algo = document.getElementById('realtimeFibAlgo') ? document.getElementById('realtimeFibAlgo').value : 'cycle';
                const swing = {
                    lookback_days: parseInt(document.getElementById('realtimeFibLookback')?.value || '420'),
                    pivot: parseInt(document.getElementById('realtimeFibPivot')?.value || '10'),
                    min_separation_days: parseInt(document.getElementById('realtimeFibSep')?.value || '10'),
                    min_move_pct: parseFloat(document.getElementById('realtimeFibMinMove')?.value || '0.1'),
                    fallback_pivot: parseInt(document.getElementById('realtimeFibFallbackPivot')?.value || '5'),
                    orientation: (document.getElementById('fibOrientation')?.value || 'low_to_high'),
                };

                showStatus(`å¼€å§‹å®æ—¶åˆ†æ ${symbol} çš„æ–æ³¢æ‰©å±•ä½...`, 'info');

                const response = await fetch('/realtime-fib/api/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        timeframe: timeframe,
                        algo: algo,
                        swing: {
                            ...swing,
                            anchor: {
                                high_date: document.getElementById('fibAnchorHighDate')?.value || null,
                                high_price: (function(){ const v=document.getElementById('fibAnchorHighPrice')?.value; return v===''? null: parseFloat(v); })(),
                                low_date: document.getElementById('fibAnchorLowDate')?.value || null,
                                low_price: (function(){ const v=document.getElementById('fibAnchorLowPrice')?.value; return v===''? null: parseFloat(v); })(),
                            }
                        },
                        include_series: true
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayRealtimeFibonacciResults(data.result);
                    drawRealtimeFibonacciChart(data.result);
                    showStatus(`å®æ—¶æ–æ³¢åˆ†æå®Œæˆ`, 'success');
                } else {
                    showStatus(`åˆ†æå¤±è´¥: ${data.error}`, 'error');
                }

            } catch (error) {
                console.error('å®æ—¶æ–æ³¢åˆ†æé”™è¯¯:', error);
                showStatus(`å®æ—¶æ–æ³¢åˆ†æå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å–æ¶ˆå®æ—¶ç›‘æ§ï¼šè¯¥åŠŸèƒ½å·²å…³é—­ï¼Œä¿æŒå›¾è¡¨ç¨³å®š
        function startRealtimeMonitoring() { showStatus('å®æ—¶ç›‘æ§å·²å…³é—­ï¼ˆå›¾è¡¨ä¿æŒç¨³å®šï¼‰', 'info'); }

        // æ˜¾ç¤ºå®æ—¶æ–æ³¢åˆ†æç»“æœ
        function displayRealtimeFibonacciResults(result) {
            const resultsDiv = document.getElementById('realtimeFibResults');
            
            const cp = Number(result.current_price || 0);
            const rLow = Number(result.recent_low || 0);
            const rHigh = Number(result.recent_high || 0);
            let html = `
                <div class="info-box">
                    <h4>âš¡ ${result.symbol} å®æ—¶æ–æ³¢åˆ†æ</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>å½“å‰ä»·æ ¼:</strong> ${cp ? cp.toFixed(6) : '-'}
                        </div>
                        <div class="stat-item">
                            <strong>æœ€è¿‘é«˜ç‚¹:</strong> ${rHigh ? rHigh.toFixed(6) : '-'}
                        </div>
                        <div class="stat-item">
                            <strong>æœ€è¿‘ä½ç‚¹:</strong> ${rLow ? rLow.toFixed(6) : '-'}
                        </div>
                    </div>
                </div>
            `;

            // æ˜¾ç¤ºå½“å‰æ–æ³¢ä½ç½®
            if (result.position) {
                const pos = result.position;
                html += `
                    <div class="fib-position-container">
                        <h4>ğŸ“ å½“å‰æ–æ³¢ä½ç½®</h4>
                        <div class="fib-position-info">
                            <div class="position-item">
                                <strong>å½“å‰æ¯”ä¾‹:</strong> ${(Number(pos.ratio || 0)).toFixed(3)}
                            </div>
                            <div class="position-item">
                                <strong>æœ€è¿‘ä½ç‚¹:</strong> ${(Number(pos.nearest_level || 0)).toFixed(3)}
                            </div>
                            <div class="position-item">
                                <strong>ä½ç‚¹ä»·æ ¼:</strong> ${pos.nearest_price ? Number(pos.nearest_price).toFixed(6) : '-'}
                            </div>
                        </div>
                    </div>
                `;

                // ç®€åŒ–æ˜¾ç¤ºï¼šåªå±•ç¤ºæœ€è¿‘ä½ç‚¹ï¼Œä¸å±•ç¤ºä¸Šä¸‹æ–¹åˆ—è¡¨
            }

            // æ˜¾ç¤ºè¿‘æœŸå˜åŒ–åˆ†æ
            if (result.recent_analysis) {
                const recent = result.recent_analysis;
                html += `
                    <div class="recent-analysis-container">
                        <h4>ğŸ“Š è¿‘æœŸå˜åŒ–åˆ†æ (${recent.time_hours.toFixed(1)}å°æ—¶)</h4>
                        <div class="recent-stats-grid">
                            <div class="stat-item">
                                <strong>ä»·æ ¼å˜åŒ–:</strong> ${(recent.price_change * 100).toFixed(2)}%
                            </div>
                            <div class="stat-item">
                                <strong>å˜åŒ–é€Ÿåº¦:</strong> ${(recent.price_velocity * 100).toFixed(2)}%/å°æ—¶
                            </div>
                            <div class="stat-item">
                                <strong>é‡èƒ½æ³¢åŠ¨:</strong> ${(recent.volume_volatility * 100).toFixed(1)}%
                            </div>
                            <div class="stat-item">
                                <strong>å¤šç©ºæ¯”ä¾‹:</strong> ${(recent.bullish_ratio * 100).toFixed(1)}% å¤šå¤´
                            </div>
                            <div class="stat-item">
                                <strong>å¤šå¤´å¼ºåº¦:</strong> ${recent.bullish_strength.toFixed(0)}
                            </div>
                            <div class="stat-item">
                                <strong>ç©ºå¤´å¼ºåº¦:</strong> ${recent.bearish_strength.toFixed(0)}
                            </div>
                        </div>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;
        }

        // ç»˜åˆ¶å®æ—¶æ–æ³¢å›¾è¡¨
        function drawRealtimeFibonacciChart(result) {
            const ctx = document.getElementById('realtimeFibChart').getContext('2d');
            if (realtimeFibChart) realtimeFibChart.destroy();

            const series = Array.isArray(result.series) ? result.series : [];
            const labels = series.map(p => new Date(p.t).toLocaleDateString());
            const closes = series.map(p => p.close);

            // æ–æ³¢ä½æ°´å¹³çº¿ä½œä¸ºå¤šæ¡ line æ•°æ®é›†
            const fibDatasets = [];
            const levels = Object.keys(result.fib_levels).map(parseFloat).sort((a,b)=>a-b);
            for (const lv of levels) {
                const y = result.fib_levels[lv];
                fibDatasets.push({
                    type: 'line',
                    label: `${lv}`,
                    data: Array(labels.length).fill(y),
                    borderColor: 'rgba(200,200,200,0.35)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: false,
                    borderDash: lv===0.5?[]:[5,5]
                });
            }

            // å½“å‰ä»·æ ¼çº¿
            const cp = Number(result.current_price || 0);
            if (cp) {
                fibDatasets.push({
                    type: 'line',
                    label: 'å½“å‰ä»·æ ¼',
                    data: Array(labels.length).fill(cp),
                    borderColor: 'rgba(76,175,80,0.8)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false
                });
            }

            // Kçº¿æ›¿ä»£ï¼šæ”¶ç›˜ä»·æŠ˜çº¿ï¼ˆæ— éœ€é¢å¤–æ’ä»¶ï¼‰
            const priceLine = {
                type: 'line',
                label: 'æ”¶ç›˜ä»·',
                data: closes,
                borderColor: 'rgba(52,152,219,0.9)',
                borderWidth: 1.5,
                pointRadius: 0,
                fill: false
            };

            // å³ä¾§æ–‡å­—æ ‡ç­¾æ’ä»¶ï¼ˆæ˜¾ç¤ºå„æ–æ³¢ä½çš„ä»·æ ¼å’Œæ ‡ç­¾ï¼‰
            const rightLabelPlugin = {
                id: 'rightLabels',
                afterDraw(chart, args, opts) {
                    const {ctx, scales} = chart;
                    const yScale = scales.y;
                    ctx.save();
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#ccc';
                    for (const lv of levels) {
                        const y = result.fib_levels[lv];
                        const py = yScale.getPixelForValue(y);
                        const text = `${lv} (${Number(y).toFixed(2)})`;
                        ctx.fillText(text, chart.chartArea.right - 4, py - 2);
                    }
                    // å½“å‰ä»·æ ¼
                    if (cp) {
                        const py = yScale.getPixelForValue(cp);
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText(`P (${cp.toFixed(2)})`, chart.chartArea.right - 4, py - 2);
                    }
                    ctx.restore();
                }
            };
            // Swingæ ‡è®°
            const swingMarkers = {
                id: 'swingMarkers',
                afterDraw(chart){
                    if (!result.recent_low_ts || !result.recent_high_ts) return;
                    const {ctx, chartArea, scales} = chart; const xScale = scales.x; const yScale = scales.y;
                    const labelsArr = labels;
                    function idxByTs(ts){
                        const dstr = new Date(ts).toLocaleDateString();
                        let idx = labelsArr.indexOf(dstr);
                        if (idx >= 0) return idx;
                        let best=0,bestDiff=1e18; for (let i=0;i<labelsArr.length;i++){ const diff=Math.abs(new Date(labelsArr[i]).getTime()-ts); if(diff<bestDiff){best=i;bestDiff=diff;} } return best;
                    }
                    function drawMarker(ts, price, color, text){
                        const idx = idxByTs(ts); const x = xScale.getPixelForValue(labelsArr[idx]); const y = yScale.getPixelForValue(price);
                        ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x, chartArea.top); ctx.lineTo(x, chartArea.bottom); ctx.stroke(); ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.font='12px sans-serif'; ctx.textAlign='left'; ctx.fillStyle='#fff'; ctx.fillText(text, x+6, y-6); ctx.restore();
                    }
                    drawMarker(result.recent_low_ts, result.recent_low, '#f1c40f', `ä½ç‚¹(0) ${new Date(result.recent_low_ts).toLocaleDateString()} ${Number(result.recent_low).toFixed(2)}`);
                    drawMarker(result.recent_high_ts, result.recent_high, '#e74c3c', `é«˜ç‚¹(1) ${new Date(result.recent_high_ts).toLocaleDateString()} ${Number(result.recent_high).toFixed(2)}`);
                }
            };

            realtimeFibChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [priceLine, ...fibDatasets]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: `${result.symbol} æ–æ³¢å›¾è¡¨` },
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: true },
                        y: { display: true }
                    }
                },
                plugins: [rightLabelPlugin, swingMarkers]
            });
        }
        function exportFibChartPng(){
            const canvas = document.getElementById('realtimeFibChart');
            try {
                const url = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url; a.download = `${document.getElementById('realtimeSymbol').value}_${document.getElementById('realtimeTimeframe').value}_fib.png`;
                document.body.appendChild(a); a.click(); a.remove();
            } catch (e){ console.error('å¯¼å‡ºå¤±è´¥', e); }
        }

        // ======= å®æ—¶æ–æ³¢ æ‰«æåˆ—è¡¨ =======
        let realtimeFibQuery = { page: 1, totalPages: 1 };

        function readRealtimeFibQueryFromUI() {
            const sort = document.getElementById('realtimeFibSort').value;
            const [sort_by, sort_dir] = sort.split('-');
            return {
                source: document.getElementById('realtimeFibSource').value,
                limit: parseInt(document.getElementById('realtimeFibLimit').value) || 1000,
                timeframe: document.getElementById('realtimeFibScanTf').value,
                only_extension: document.getElementById('realtimeFibOnlyExt').checked,
                min_ratio: (function(){ const v = document.getElementById('realtimeFibMinRatio').value; return v === '' ? null : parseFloat(v); })(),
                sort_by, sort_dir,
                page: 1,
                page_size: parseInt(document.getElementById('realtimeFibPageSize').value) || 50,
                algo: (document.getElementById('realtimeFibAlgo')?.value || 'cycle'),
                swing: {
                    lookback_days: parseInt(document.getElementById('realtimeFibLookback')?.value || '420'),
                    pivot: parseInt(document.getElementById('realtimeFibPivot')?.value || '10'),
                    min_separation_days: parseInt(document.getElementById('realtimeFibSep')?.value || '10'),
                    min_move_pct: parseFloat(document.getElementById('realtimeFibMinMove')?.value || '0.1'),
                    fallback_pivot: parseInt(document.getElementById('realtimeFibFallbackPivot')?.value || '5'),
                },
                max_workers: parseInt(document.getElementById('realtimeFibMaxWorkers')?.value || '8'),
                batch_size: parseInt(document.getElementById('realtimeFibBatchSize')?.value || '50'),
                throttle_sec: parseFloat(document.getElementById('realtimeFibThrottle')?.value || '0.2'),
            };
        }

        async function scanRealtimeFibList() {
            try {
                realtimeFibQuery = readRealtimeFibQueryFromUI();
                showStatus(`å¼€å§‹æ‰«æ ${realtimeFibQuery.source.toUpperCase()} å‰ ${realtimeFibQuery.limit} ä¸ªäº¤æ˜“å¯¹...`, 'info');
                const resp = await fetch('/realtime-fib/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(realtimeFibQuery)
                });
                const data = await resp.json();
                if (!data.success) {
                    showStatus('æ‰«æå¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'), 'error');
                    return;
                }
                realtimeFibQuery.page = data.pagination?.page || 1;
                realtimeFibQuery.page_size = data.pagination?.page_size || realtimeFibQuery.page_size;
                realtimeFibQuery.totalPages = data.pagination?.total_pages || 1;
                renderRealtimeFibList(data.rows, data.source, data.timeframe);
                updateRealtimeFibPager();
                showStatus(`æ‰«æå®Œæˆï¼Œå…± ${data.total} æ¡`, 'success');
            } catch (e) {
                console.error('æ‰«æå¤±è´¥', e);
                showStatus('æ‰«æå¤±è´¥: ' + e.message, 'error');
            }
        }

        function updateRealtimeFibPager() {
            const el = document.getElementById('realtimeFibPageInfo');
            if (el) el.textContent = `ç¬¬ ${realtimeFibQuery.page || 1} / ${realtimeFibQuery.totalPages || 1} é¡µ`;
        }

        async function applyRealtimeFibSortFilter() {
            const q = readRealtimeFibQueryFromUI();
            realtimeFibQuery = q;
            await scanRealtimeFibGoToPage(1);
        }

        async function scanRealtimeFibGoToPage(page) {
            try {
                realtimeFibQuery.page = Math.max(1, page);
                const resp = await fetch('/realtime-fib/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(realtimeFibQuery)
                });
                const data = await resp.json();
                if (!data.success) return;
                realtimeFibQuery.page = data.pagination?.page || realtimeFibQuery.page;
                realtimeFibQuery.totalPages = data.pagination?.total_pages || 1;
                renderRealtimeFibList(data.rows, data.source, data.timeframe);
                updateRealtimeFibPager();
            } catch (e) {
                showStatus('åˆ†é¡µåŠ è½½å¤±è´¥: ' + e.message, 'error');
            }
        }

        function realtimeFibPrevPage() { if ((realtimeFibQuery.page || 1) > 1) scanRealtimeFibGoToPage((realtimeFibQuery.page || 1) - 1); }
        function realtimeFibNextPage() { scanRealtimeFibGoToPage((realtimeFibQuery.page || 1) + 1); }

        function renderRealtimeFibList(rows, source, timeframe) {
            const el = document.getElementById('realtimeFibList');
            if (!rows || rows.length === 0) {
                el.innerHTML = '<p>æš‚æ— æ•°æ®</p>';
                return;
            }
            let html = `
                <table class="results-table">
                  <thead>
                    <tr>
                      <th>äº¤æ˜“å¯¹</th>
                      <th>è¶‹åŠ¿</th>
                      <th>å½“å‰ä»·æ ¼</th>
                      <th>æœ€è¿‘ä½ç‚¹</th>
                      <th>æœ€è¿‘é«˜ç‚¹</th>
                      <th>æ–æ³¢æ¯”ä¾‹</th>
                      <th>æœ€è¿‘ä½ç‚¹</th>
                      <th>ä½ç‚¹ä»·æ ¼</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            for (const r of rows.slice(0, 1000)) {
                const ratio = (r.ratio !== null && r.ratio !== undefined) ? Number(r.ratio).toFixed(3) : '-';
                const near = (r.nearest_level !== null && r.nearest_level !== undefined) ? Number(r.nearest_level).toFixed(3) : '-';
                const nearPrice = (r.nearest_price !== null && r.nearest_price !== undefined) ? Number(r.nearest_price).toFixed(6) : '-';
                html += `
                  <tr>
                    <td>${r.symbol}</td>
                    <td>${r.trend || '-'}</td>
                    <td>${Number(r.current_price).toFixed(6)}</td>
                    <td>${Number(r.recent_low).toFixed(6)}</td>
                    <td>${Number(r.recent_high).toFixed(6)}</td>
                    <td>${ratio}</td>
                    <td>${near}</td>
                    <td>${nearPrice}</td>
                  </tr>`;
            }
            html += '</tbody></table>';
            el.innerHTML = html;
        }
        
        function toggleVideoBackground() {
            showStatus('åˆ‡æ¢èƒŒæ™¯æ¨¡å¼', 'info');
        }
        
        function toggleBackground() {
            showStatus('å¼€å…³èƒŒæ™¯', 'info');
        }
        
        function addNewSymbols() {
            showStatus('æ·»åŠ æ–°å¸ç§', 'info');
        }
        
        // è¯¦æƒ…æŸ¥çœ‹å‡½æ•°ï¼ˆå·²ç§»é™¤æ—¥å†…è¯¦æƒ…ï¼‰
        
        function showChart(symbol) {
            showStatus(`æ˜¾ç¤º${symbol}å›¾è¡¨`, 'info');
        }
        
        function showMultiTimeframeDetails(symbol, timeframe) {
            showStatus(`æŸ¥çœ‹${symbol} ${timeframe}å¤šæ—¶é—´æ¡†æ¶è¯¦æƒ…`, 'info');
        }
        
        function showSignalDetails(symbol, timeframe, condition, description) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h3>ä¿¡å·è¯¦æƒ… - ${symbol} (${timeframe})</h3>
                    <div class="signal-details">
                        <div class="detail-item">
                            <strong>ä¿¡å·æ¡ä»¶:</strong>
                            <p>${condition}</p>
                        </div>
                        <div class="detail-item">
                            <strong>è¯¦ç»†æè¿°:</strong>
                            <p>${description}</p>
                        </div>
                        <div class="detail-item">
                            <strong>å¸ç§:</strong> ${symbol}
                        </div>
                        <div class="detail-item">
                            <strong>æ—¶é—´æ¡†æ¶:</strong> ${timeframe}
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å…³é—­</button>
                    </div>
                </div>
            `;
            
            // æ·»åŠ æ ·å¼
            const style = document.createElement('style');
            style.textContent = `
                .signal-details {
                    margin: 20px 0;
                }
                .detail-item {
                    margin: 15px 0;
                    padding: 10px;
                    background: #f8f9fa;
                    border-radius: 5px;
                }
                .detail-item strong {
                    color: #007bff;
                }
                .detail-item p {
                    margin: 5px 0 0 0;
                    color: #333;
                    line-height: 1.5;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(modal);
            
            // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
            modal.onclick = function(e) {
                if (e.target === modal) {
                    modal.remove();
                    style.remove();
                }
            };
        }
        
        // ã€ä¿®å¤è¶…æ—¶é—®é¢˜ã€‘æ¸è¿›å¼åˆ†æ + ä¿¡å·ç¼“å­˜
        let allCachedSignals = [];
        let analysisProgress = {
            total: 0,
            analyzed: 0,
            isAnalyzing: false
        };
        
        // å¤šæ—¶é—´æ¡†æ¶åˆ†é¡µç›¸å…³å‡½æ•°
        async function analyzeCurrentPage(strategyType = 'original') {
            if (typeof allSymbols === 'undefined' || allSymbols.length === 0) {
                showStatus('è¯·å…ˆè·å–å¸ç§åˆ—è¡¨', 'error');
                return;
            }
            
            try {
                const signalsPerPage = 50; // æ¯é¡µæ˜¾ç¤º50ä¸ªä¿¡å·
                
                // å¦‚æœè¿˜æ²¡æœ‰å¼€å§‹åˆ†æï¼Œå¯åŠ¨æ¸è¿›å¼åˆ†æ
                if (!analysisProgress.isAnalyzing && analysisProgress.analyzed === 0) {
                    await startProgressiveAnalysis(strategyType);
                }
                
                // ä»ç¼“å­˜ä¸­è·å–å½“å‰é¡µçš„ä¿¡å·
                displayCurrentPageSignals(signalsPerPage);
                
            } catch (error) {
                console.error('analyzeCurrentPage error:', error);
                handleAnalysisError(error);
            }
        }
        
        // æ¸è¿›å¼åˆ†æå‡½æ•°
        async function startProgressiveAnalysis(strategyType = 'original') {
            analysisProgress.isAnalyzing = true;
            analysisProgress.total = allSymbols.length;
            analysisProgress.analyzed = 0;
            allCachedSignals = [];
            
            const batchSize = 20; // æ¯æ‰¹åˆ†æ20ä¸ªå¸ç§
            const totalBatches = Math.ceil(allSymbols.length / batchSize);
            
            showStatus(`å¼€å§‹æ¸è¿›å¼åˆ†æ ${allSymbols.length} ä¸ªå¸ç§...`, 'info');
            
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * batchSize;
                const endIdx = Math.min(startIdx + batchSize, allSymbols.length);
                const batchSymbols = allSymbols.slice(startIdx, endIdx);
                
                showStatus(`æ­£åœ¨åˆ†æç¬¬${batchIndex + 1}/${totalBatches}æ‰¹å¸ç§ (${startIdx + 1}-${endIdx})...`, 'info');
                
                try {
                    const response = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                        method: 'POST',
                        body: JSON.stringify({
                            symbols: batchSymbols,
                            page: 1,
                            page_size: 999999, // è·å–è¿™æ‰¹å¸ç§çš„æ‰€æœ‰ä¿¡å·
                            strategy_type: strategyType
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // å°†æ–°ä¿¡å·æ·»åŠ åˆ°ç¼“å­˜ä¸­
                        const newSignals = data.signals || [];
                        allCachedSignals = allCachedSignals.concat(newSignals);
                        analysisProgress.analyzed = endIdx;
                        
                        // æ›´æ–°è¿›åº¦
                        const progress = Math.round((analysisProgress.analyzed / analysisProgress.total) * 100);
                        console.log(`æ‰¹æ¬¡ ${batchIndex + 1} å®Œæˆï¼Œæ–°å¢ ${newSignals.length} ä¸ªä¿¡å·ï¼Œæ€»è®¡ ${allCachedSignals.length} ä¸ªä¿¡å·`);
                        
                        // å®æ—¶æ›´æ–°æ˜¾ç¤º
                        updateTotalPagesAndDisplay();
                        
                        showStatus(`è¿›åº¦: ${progress}% (${analysisProgress.analyzed}/${analysisProgress.total}) - å·²è·å¾— ${allCachedSignals.length} ä¸ªä¿¡å·`, 'info');
                        
                        // æ·»åŠ çŸ­æš‚å»¶è¿Ÿé¿å…APIé™åˆ¶
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                    } else {
                        console.error(`æ‰¹æ¬¡ ${batchIndex + 1} åˆ†æå¤±è´¥:`, data.error);
                        showStatus(`æ‰¹æ¬¡ ${batchIndex + 1} åˆ†æå¤±è´¥: ${data.error}`, 'warning');
                    }
                    
                } catch (batchError) {
                    console.error(`æ‰¹æ¬¡ ${batchIndex + 1} è¯·æ±‚å¤±è´¥:`, batchError);
                    showStatus(`æ‰¹æ¬¡ ${batchIndex + 1} è¯·æ±‚å¤±è´¥: ${batchError.message}`, 'warning');
                }
            }
            
            analysisProgress.isAnalyzing = false;
            showStatus(`åˆ†æå®Œæˆï¼æ€»å…±ç”Ÿæˆ ${allCachedSignals.length} ä¸ªä¿¡å·`, 'success');
            updateTotalPagesAndDisplay();
        }
        
        // æ›´æ–°æ€»é¡µæ•°å¹¶æ˜¾ç¤ºå½“å‰é¡µ
        function updateTotalPagesAndDisplay() {
            const signalsPerPage = 50;
            totalPages = Math.ceil(allCachedSignals.length / signalsPerPage);
            updatePaginationControls();
            displayCurrentPageSignals(signalsPerPage);
        }
        
        // æ˜¾ç¤ºå½“å‰é¡µä¿¡å·
        function displayCurrentPageSignals(signalsPerPage) {
            const startIdx = (currentPage - 1) * signalsPerPage;
            const endIdx = startIdx + signalsPerPage;
            const pageSignals = allCachedSignals.slice(startIdx, endIdx);
            
            console.log(`æ˜¾ç¤ºä¿¡å·èŒƒå›´: ${startIdx}-${endIdx}, å…±${pageSignals.length}ä¸ªä¿¡å·`);
            
            // ã€ä¿®å¤ã€‘ç»Ÿä¸€åˆ†é¡µé€»è¾‘ï¼Œç›´æ¥æ›´æ–°è¡¨æ ¼æ˜¾ç¤º
            updateSignalDisplay(pageSignals);
            
            if (pageSignals.length > 0) {
                showStatus(`ç¬¬${currentPage}é¡µæ˜¾ç¤ºå®Œæˆ: æ˜¾ç¤º${pageSignals.length}ä¸ªä¿¡å· (æ€»è®¡${allCachedSignals.length}ä¸ªä¿¡å·)`, 'success');
            }
        }
        
        // ã€æ–°å¢ã€‘ç»Ÿä¸€çš„ä¿¡å·æ˜¾ç¤ºå‡½æ•°
        function updateSignalDisplay(signals) {
            const tbody = document.getElementById('multiTimeframeSignalsTableBody');
            if (!tbody) return;
            
            if (!signals || signals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #666;">å½“å‰é¡µæš‚æ— ä¿¡å·</td></tr>';
                return;
            }
            
            let html = '';
            signals.forEach((signal, index) => {
                const rowClass = signal.signal_type === 'long' ? 'signal-long' : 'signal-short';
                const profitClass = signal.profit_pct >= 0 ? 'profit-positive' : 'profit-negative';
                
                html += `
                    <tr class="${rowClass}">
                        <td>${signal.symbol}</td>
                        <td>${signal.timeframe}</td>
                        <td class="trend-${signal.trend}">${signal.trend}</td>
                        <td class="signal-type-${signal.signal_type}">${signal.signal_type}</td>
                        <td>${parseFloat(signal.entry_price).toFixed(6)}</td>
                        <td>${signal.take_profit > 0 ? parseFloat(signal.take_profit).toFixed(6) : 'N/A'}</td>
                        <td class="${profitClass}">${signal.profit_pct.toFixed(2)}%</td>
                        <td>${signal.signal_time}</td>
                        <td class="condition-cell" title="${signal.description || 'æ— æè¿°'}">${signal.condition}</td>
                        <td class="actions">
                            <button class="btn-detail" onclick="showSignalDetails('${signal.symbol}', '${signal.timeframe}', '${signal.condition}', '${signal.description || ''}')">è¯¦æƒ…</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }
        
        // å¤„ç†åˆ†æé”™è¯¯
        function handleAnalysisError(error) {
            let errorMessage = error.message;
            if (error.message.includes('500')) {
                errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œå·²åˆ‡æ¢åˆ°æ¸è¿›å¼åˆ†ææ¨¡å¼';
            } else if (error.message.includes('timeout') || error.message.includes('è¶…æ—¶')) {
                errorMessage = 'è¯·æ±‚è¶…æ—¶ï¼Œå·²ä¼˜åŒ–ä¸ºå°æ‰¹é‡åˆ†æ';
            } else if (error.message.includes('port closed')) {
                errorMessage = 'è¿æ¥ä¸­æ–­ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
            }
            
            showStatus(`åˆ†æå¤±è´¥: ${errorMessage}`, 'error');
        }
        
        function updatePaginationControls() {
            const paginationControls = document.getElementById('paginationControls');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (paginationControls) {
                paginationControls.style.display = 'block';
            }
            
            if (pageInfo) {
                pageInfo.textContent = `ç¬¬${currentPage}é¡µï¼Œå…±${totalPages}é¡µ (${allCachedSignals.length}ä¸ªä¿¡å·)`;
            }
            
            if (prevBtn) {
                prevBtn.disabled = currentPage <= 1;
            }
            
            if (nextBtn) {
                nextBtn.disabled = currentPage >= totalPages;
            }
        }
        
        function showMultiTimeframeSignals(signals, minProfit = 0) {
            const resultsDiv = document.getElementById('multiTimeframeResults');
            if (!resultsDiv) return;
            
            let filteredSignals = signals;
            if (minProfit > 0) {
                filteredSignals = signals.filter(signal => 
                    signal.profit_pct >= minProfit
                );
            }
            
            if (filteredSignals.length === 0) {
                resultsDiv.innerHTML = '<p>æš‚æ— ç¬¦åˆæ¡ä»¶çš„ä¿¡å·</p>';
                return;
            }
            
            let html = '<h4>å¤šæ—¶é—´æ¡†æ¶ä¿¡å·:</h4>';
            html += '<table class="table"><tr><th>å¸ç§</th><th>æ—¶é—´æ¡†æ¶</th><th>ä¿¡å·ç±»å‹</th><th>æ”¶ç›Šç‡</th><th>å…¥åœºä»·æ ¼</th><th>æ­¢ç›ˆä»·æ ¼</th></tr>';
            
            filteredSignals.forEach(signal => {
                const profitClass = signal.profit_pct >= 0 ? 'success' : 'error';
                html += `<tr>
                    <td>${signal.symbol}</td>
                    <td>${signal.timeframe}</td>
                    <td>${signal.signal_type}</td>
                    <td class="${profitClass}">${signal.profit_pct}%</td>
                    <td>${signal.entry_price}</td>
                    <td>${signal.take_profit_price || 'N/A'}</td>
                </tr>`;
            });
            
            html += '</table>';
            resultsDiv.innerHTML = html;
        }
    </script>
    <script>
    // Kçº¿ç»˜åˆ¶ï¼ˆå†…åµŒï¼‰é€»è¾‘ï¼Œå°è£…åˆ° KLINE å‘½åç©ºé—´ï¼Œé¿å…ä¸ç°æœ‰è„šæœ¬å†²çª
    window.KLINE = (function(){
      let chart, series;
      let supports = [], resistances = [], sLabels = [], rLabels = [];
      // æ–°å¢ï¼šå¼€ä»“ä¸æ­¢ç›ˆ
      let entries = [], tps = [];
      let linesS = [], linesR = [], linesE = [], linesTP = [];
      let autoTimer = null;
      let drag = { on:false, kind:null, idx:-1, last:0 };
      let dragTip;

      function el(id){ return document.getElementById(id); }
      function status(msg, type){ const s = el('kd_status'); if(!s) return; s.textContent = msg; s.style.color = (type==='error'?'#ef4444':'#9aa1b2'); }
      function fmt(v){ v=Number(v); if(!isFinite(v)) return ''; if(v>=100) return v.toFixed(2); if(v>=1) return v.toFixed(4); if(v>=0.01) return v.toFixed(6); return v.toFixed(8); }
      function snap(v){ const x=Math.abs(v); let step=0.0001; if(x>=10000) step=5; else if(x>=1000) step=1; else if(x>=100) step=0.5; else if(x>=10) step=0.1; else if(x>=1) step=0.01; else if(x>=0.1) step=0.001; return Math.round(v/step)*step; }
      function sortDedup(kind){ const eps=1e-8; if(kind==='support'){ let pairs=supports.map((p,i)=>({p,label:sLabels[i]||''})).sort((a,b)=>a.p-b.p); const out=[],labs=[]; pairs.forEach(it=>{ if(out.length===0||Math.abs(it.p-out[out.length-1])>eps){ out.push(it.p); labs.push(it.label);} }); supports=out; sLabels=labs; } else { let pairs=resistances.map((p,i)=>({p,label:rLabels[i]||''})).sort((a,b)=>a.p-b.p); const out=[],labs=[]; pairs.forEach(it=>{ if(out.length===0||Math.abs(it.p-out[out.length-1])>eps){ out.push(it.p); labs.push(it.label);} }); resistances=out; rLabels=labs; } }

      function ensureChart(){
        // Create chart once and wire all interactions
        if (chart) return;
        if (!window.LightweightCharts) { status('Kçº¿åº“æœªåŠ è½½', 'error'); return; }
        const box = el('kd_chart');
        // FIX: the CrosshairMode enum requires a dot access; previous code had a syntax error here
        chart = LightweightCharts.createChart(box, {
          layout: { background: { color: '#0f111a' }, textColor: '#e5e5e5' },
          crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
          rightPriceScale: { borderVisible: false },
          timeScale: { borderVisible: false },
          grid: { vertLines: { color: '#1f2335' }, horzLines: { color: '#1f2335' } }
        });
        series = chart.addCandlestickSeries({
          upColor: '#26a69a', downColor: '#ef5350', wickUpColor: '#26a69a', wickDownColor: '#ef5350', borderVisible: false
        });
        setTimeout(resize, 0);
        if (window.ResizeObserver) { new ResizeObserver(resize).observe(box); } else { window.addEventListener('resize', resize); }
        chart.subscribeClick(param => {
          if (!param || !param.point) return;
          const mode = el('kd_clickMode').value;
          if (mode === 'none') return;
          if (mode === 'text') { addAnnoAt(param.point.x, param.point.y, 'åŒå‡»ç¼–è¾‘'); updateTemplateText(); return; }
          const price = series.coordinateToPrice(param.point.y);
          if (!price || isNaN(price)) return;
          addLevel(mode, price);
        });
        // è¦†ç›–å±‚ï¼šæ–‡æœ¬æ¨¡å¼ä¸‹æ‹¦æˆªç‚¹å‡»ï¼Œç¡®ä¿å¯ç‚¹å‡»æ·»åŠ 
        let overlay = box.querySelector('#kd_textOverlay');
        if (!overlay) {
          // High z-index and explicit pointer-events to defeat hostile overlays from injected scripts
          overlay = document.createElement('div');
          overlay.id = 'kd_textOverlay';
          overlay.style.cssText = 'position:absolute; inset:0; z-index:100000; display:none; cursor:text; background:transparent; pointer-events:auto;';
          box.appendChild(overlay);
          overlay.addEventListener('click', (e) => {
            const mode = el('kd_clickMode').value; if (mode !== 'text') return;
            const r = overlay.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
            addAnnoAt(x, y, 'åŒå‡»ç¼–è¾‘'); updateTemplateText(); e.stopPropagation();
          });
        }
        // å…œåº•ï¼šå®¹å™¨ç‚¹å‡»ä¹Ÿèƒ½æ·»åŠ æ–‡æœ¬ï¼ˆé¿å…è®¢é˜…åªå“åº”ç»˜å›¾åŒºï¼‰
        box.addEventListener('click', (e) => {
          const mode = el('kd_clickMode').value; if (mode !== 'text') return;
          // ignore clicks on existing annotation nodes
          if (e.target && e.target.classList && e.target.classList.contains('kd-anno')) return;
          const r = box.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
          addAnnoAt(x, y, 'åŒå‡»ç¼–è¾‘'); updateTemplateText();
        });
        dragTip = document.createElement('div'); dragTip.style.cssText='position:absolute;right:8px;padding:2px 6px;background:rgba(0,0,0,0.7);color:#fff;border-radius:4px;font-size:12px;pointer-events:none;display:none;'; box.appendChild(dragTip);
        box.addEventListener('mousedown', (e)=>{ const y=e.clientY-box.getBoundingClientRect().top; const hit=hitTest(y); if(hit){ drag.on=true; drag.kind=hit.kind; drag.idx=hit.idx; e.preventDefault(); dragTip.style.display='block'; dragTip.style.top=(y-10)+'px'; }}); window.addEventListener('mousemove', (e)=>{ if(!drag.on) return; const now=performance.now(); if(now-drag.last<25) return; drag.last=now; const y=e.clientY-box.getBoundingClientRect().top; const p=series.coordinateToPrice(y); if(!p||isNaN(p)||p<=0) return; const v=snap(p); updateLine(drag.kind,drag.idx,v); dragTip.textContent=fmt(v); dragTip.style.top=(y-10)+'px'; }); window.addEventListener('mouseup', ()=>{ if(!drag.on) return; drag.on=false; sortDedup('support'); sortDedup('resistance'); renderLists(); applyLines(); dragTip.style.display='none'; }); }
      function resize(){ try{ if(!chart) return; const box=el('kd_chart'); const r=box.getBoundingClientRect(); const w=Math.max(300,Math.floor(r.width||box.clientWidth||0)); const h=Math.max(300,Math.floor(r.height||540)); chart.resize(w,h);}catch(_){}}
      function hitTest(y){ const tol=6; let best=null; const test=(arr,kind)=>{ arr.forEach((p,i)=>{ const py=series.priceToCoordinate(p); if(py==null) return; const d=Math.abs(py-y); if(d<=tol && (!best||d<best.d)) best={kind,idx:i,d}; }); }; test(supports,'support'); test(resistances,'resistance'); test(entries,'entry'); test(tps,'tp'); return best; }
      function clearLines(arr){ if(!series) return; arr.forEach(l=>{ try{ series.removePriceLine(l);}catch(_){}}); arr.length=0; }
      // ---- å¤šæ–‡æœ¬æ³¨é‡Šå·¥å…· ----
      let annos = []; let annoIdSeq = 1;
      function addAnnoAt(x,y,text){ const box=el('kd_chart'); const id=annoIdSeq++; const div=document.createElement('div'); div.className='kd-anno'; div.dataset.id=String(id); div.textContent=text||'åŒå‡»ç¼–è¾‘'; div.style.cssText='position:absolute; left:'+x+'px; top:'+y+'px; color:#fff; background:rgba(0,0,0,0.45); padding:4px 6px; border-radius:4px; font-size:12px; cursor:move; user-select:text; z-index:100001; min-width:80px; min-height:20px; max-width:400px; word-wrap:break-word; white-space:pre-wrap;';
        // æ·»åŠ è°ƒæ•´å¤§å°çš„æ‰‹æŸ„ï¼ˆé»˜è®¤éšè—ï¼‰
        const resizeHandle = document.createElement('div');
        resizeHandle.className='kd-anno-resize';
        resizeHandle.style.cssText='position:absolute; right:0; bottom:0; width:12px; height:12px; background:rgba(255,255,255,0.3); cursor:nwse-resize; border-radius:2px 0 4px 0; z-index:100002; display:none;';
        div.appendChild(resizeHandle);
        const close=document.createElement('span'); close.textContent='Ã—'; close.className='kd-anno-close'; close.style.cssText='position:absolute; top:2px; right:2px; margin-left:6px; color:#ccc; cursor:pointer; font-size:14px; line-height:1; z-index:100003; display:none;'; close.onclick=(e)=>{ e.stopPropagation(); removeAnno(id); };
        div.appendChild(close);
        // drag and resize
        let dragging=false, dx=0, dy=0;
        let resizing=false, startWidth=0, startHeight=0, startX=0, startY=0;
        div.addEventListener('mousedown',(e)=>{
          if(e.target === resizeHandle || e.target.classList.contains('kd-anno-resize')) {
            resizing=true;
            const rect=div.getBoundingClientRect();
            startWidth=rect.width;
            startHeight=rect.height;
            startX=e.clientX;
            startY=e.clientY;
            e.stopPropagation();
            e.preventDefault();
          } else if(e.target !== close && !e.target.classList.contains('kd-anno-resize')) {
            dragging=true;
            const r=div.getBoundingClientRect();
            dx=e.clientX-r.left;
            dy=e.clientY-r.top;
            e.stopPropagation();
            e.preventDefault();
          }
        });
        window.addEventListener('mousemove',(e)=>{
          if(resizing) {
            const deltaX=e.clientX-startX;
            const deltaY=e.clientY-startY;
            const newWidth=Math.max(80, Math.min(400, startWidth+deltaX));
            const newHeight=Math.max(20, Math.min(200, startHeight+deltaY));
            div.style.width=newWidth+'px';
            div.style.height=newHeight+'px';
          } else if(dragging) {
            const r=box.getBoundingClientRect();
            let nx=e.clientX-r.left-dx;
            let ny=e.clientY-r.top-dy;
            nx=Math.max(4, Math.min(r.width-120, nx));
            ny=Math.max(4, Math.min(r.height-28, ny));
            div.style.left=nx+'px';
            div.style.top=ny+'px';
            const a=annos.find(a=>a.id===id);
            if(a){ a.x=nx; a.y=ny; }
          }
        });
        window.addEventListener('mouseup',()=>{ if(dragging){ dragging=false; renderAnnoList(); } if(resizing){ resizing=false; renderAnnoList(); } });
        // edit
        let editing=false;
        const showControls=()=>{ resizeHandle.style.display='block'; close.style.display='block'; };
        const hideControls=()=>{ resizeHandle.style.display='none'; close.style.display='none'; };
        div.addEventListener('dblclick',()=>{ editing=true; div.contentEditable='true'; div.focus(); showControls(); });
        div.addEventListener('blur',()=>{ if(!editing) return; div.contentEditable='false'; editing=false; const a=annos.find(a=>a.id===id); if(a){ let text = ''; const walker = document.createTreeWalker(div, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, { acceptNode: function(node) { if(node.nodeType === Node.ELEMENT_NODE && (node.classList.contains('kd-anno-close') || node.classList.contains('kd-anno-resize'))) return NodeFilter.FILTER_REJECT; return NodeFilter.FILTER_ACCEPT; } }, false); let node; while(node = walker.nextNode()){ if(node.nodeType === Node.TEXT_NODE){ text += node.textContent; } else if(node.tagName === 'BR' || (node.tagName === 'DIV' && node !== div && !node.classList.contains('kd-anno-close') && !node.classList.contains('kd-anno-resize'))){ text += '\n'; } } a.text = text.replace('Ã—','').trim(); } updateTemplateText(); renderAnnoList(); hideControls(); });
        // å…è®¸Enteræ¢è¡Œï¼ŒCtrl+Enteræˆ–Escapeé€€å‡ºç¼–è¾‘
        div.addEventListener('keydown',(e)=>{
          if(e.key==='Enter' && !e.ctrlKey && !e.metaKey) { return; }
          if((e.key==='Enter' && (e.ctrlKey || e.metaKey)) || e.key==='Escape') { e.preventDefault(); div.blur(); }
        });
        box.appendChild(div); annos.push({id, x, y, text: div.textContent.replace('Ã—','').trim()}); renderAnnoList();
      }
      function removeAnno(id){ const box=el('kd_chart'); const idx=annos.findIndex(a=>a.id===id); if(idx>=0){ const node=box.querySelector('.kd-anno[data-id="'+id+'"]'); if(node) node.remove(); annos.splice(idx,1); updateTemplateText(); renderAnnoList(); }}
      function renderAnnoList(){ try{ const list=el('kd_annoList'); if(!list) return; list.innerHTML=''; if(annos.length===0){ list.innerHTML='<div class="muted">ï¼ˆæ— æ–‡æœ¬æ³¨é‡Šï¼‰</div>'; return; } annos.forEach(a=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; row.style.alignItems='flex-start'; row.style.marginBottom='8px'; const textarea=document.createElement('textarea'); textarea.className='form-control'; textarea.value=a.text||''; textarea.rows=2; textarea.style.cssText='resize:both; min-width:200px; min-height:40px; max-width:400px;'; textarea.onchange=()=>{ a.text=textarea.value; const node=document.querySelector('.kd-anno[data-id="'+a.id+'"]'); if(node){ const textNode = Array.from(node.childNodes).find(n => n.nodeType === Node.TEXT_NODE); if(textNode) { textNode.textContent = textarea.value; } else { const closeNode = node.querySelector('span'); if(closeNode) { node.insertBefore(document.createTextNode(textarea.value), closeNode); } else { node.textContent = textarea.value + ' Ã—'; } } } updateTemplateText(); }; const pos=document.createElement('span'); pos.className='muted'; pos.style.cssText='font-size:11px; white-space:nowrap; margin-top:4px;'; pos.textContent = '('+Math.round(a.x)+', '+Math.round(a.y)+')'; const goto=document.createElement('button'); goto.className='btn'; goto.textContent='å®šä½'; goto.onclick=()=>{ const node=document.querySelector('.kd-anno[data-id="'+a.id+'"]'); if(node){ node.style.outline='1px solid #4caf50'; setTimeout(()=>{ node.style.outline='none'; },800); } }; const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=()=>removeAnno(a.id); row.appendChild(textarea); row.appendChild(pos); row.appendChild(goto); row.appendChild(del); list.appendChild(row); }); }catch(_){}}
      function applyLines(){
        ensureChart(); if(!series) return;
        // æ”¯æ’‘/é˜»åŠ›ï¼šè™šçº¿
        clearLines(linesS); clearLines(linesR);
        supports.forEach((p,i)=>{ const lab=(sLabels[i]&&sLabels[i].trim())||`S${i+1}`; const l=series.createPriceLine({price:p,color:'#10b981',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(p)}`}); linesS.push(l); });
        resistances.forEach((p,i)=>{ const lab=(rLabels[i]&&rLabels[i].trim())||`R${i+1}`; const l=series.createPriceLine({price:p,color:'#ef4444',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(p)}`}); linesR.push(l); });
        // å¼€ä»“/æ­¢ç›ˆï¼šå®çº¿
        clearLines(linesE); clearLines(linesTP);
        entries.forEach((p,i)=>{ const l=series.createPriceLine({price:p,color:'#ffffff',lineWidth:2,lineStyle:0,title:`E${i+1} ${fmt(p)}`}); linesE.push(l); });
        tps.forEach((p,i)=>{ const l=series.createPriceLine({price:p,color:'#facc15',lineWidth:2,lineStyle:0,title:`TP${i+1} ${fmt(p)}`}); linesTP.push(l); });
      }
      function addAnnoDefault(){ const box=el('kd_chart'); const r=box.getBoundingClientRect(); const x=Math.floor(r.width*0.65); let y=24; if(resistances.length>0 && typeof series.priceToCoordinate==='function'){ const yCss=series.priceToCoordinate(Math.max.apply(null,resistances)); if(yCss!=null) y=Math.max(8, Math.min(r.height-28, yCss-22)); } addAnnoAt(x,y,'åŒå‡»ç¼–è¾‘'); }
      function updateLine(kind, idx, v){
        if(kind==='support'){
          supports[idx]=v; if(linesS[idx]){ try{ series.removePriceLine(linesS[idx]); }catch(_){}}
          const lab=(sLabels[idx]&&sLabels[idx].trim())||`S${idx+1}`;
          linesS[idx]=series.createPriceLine({price:v,color:'#10b981',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(v)}`});
        } else if(kind==='resistance'){
          resistances[idx]=v; if(linesR[idx]){ try{ series.removePriceLine(linesR[idx]); }catch(_){}}
          const lab=(rLabels[idx]&&rLabels[idx].trim())||`R${idx+1}`;
          linesR[idx]=series.createPriceLine({price:v,color:'#ef4444',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(v)}`});
        } else if(kind==='entry'){
          entries[idx]=v; if(linesE[idx]){ try{ series.removePriceLine(linesE[idx]); }catch(_){}}
          linesE[idx]=series.createPriceLine({price:v,color:'#ffffff',lineWidth:2,lineStyle:0,title:`E${idx+1} ${fmt(v)}`});
        } else if(kind==='tp'){
          tps[idx]=v; if(linesTP[idx]){ try{ series.removePriceLine(linesTP[idx]); }catch(_){}}
          linesTP[idx]=series.createPriceLine({price:v,color:'#facc15',lineWidth:2,lineStyle:0,title:`TP${idx+1} ${fmt(v)}`});
        }
      }
      function renderLists(){
        const boxS=el('kd_supportLevels'); const boxR=el('kd_resistanceLevels');
        const boxE=el('kd_entryLevels'); const boxTP=el('kd_tpLevels');
        if(!boxS||!boxR||!boxE||!boxTP) return;
        // æ”¯æ’‘
        boxS.innerHTML=''; supports.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const lab=document.createElement('input'); lab.className='form-control'; lab.placeholder=`S${i+1}`; lab.value=sLabels[i]||''; lab.onchange=()=>{ sLabels[i]=lab.value.trim(); applyLines(); updateTemplateText(); }; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ supports[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=()=>{ supports.splice(i,1); sLabels.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(lab); row.appendChild(inp); row.appendChild(del); boxS.appendChild(row); });
        // é˜»åŠ›
        boxR.innerHTML=''; resistances.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const lab=document.createElement('input'); lab.className='form-control'; lab.placeholder=`R${i+1}`; lab.value=rLabels[i]||''; lab.onchange=()=>{ rLabels[i]=lab.value.trim(); applyLines(); updateTemplateText(); }; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ resistances[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=()=>{ resistances.splice(i,1); rLabels.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(lab); row.appendChild(inp); row.appendChild(del); boxR.appendChild(row); });
        // å¼€ä»“ E
        boxE.innerHTML=''; entries.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const tag=document.createElement('span'); tag.className='muted'; tag.textContent=`E${i+1}`; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ entries[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=()=>{ entries.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(tag); row.appendChild(inp); row.appendChild(del); boxE.appendChild(row); });
        // æ­¢ç›ˆ TP
        boxTP.innerHTML=''; tps.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const tag=document.createElement('span'); tag.className='muted'; tag.textContent=`TP${i+1}`; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ tps[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=()=>{ tps.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(tag); row.appendChild(inp); row.appendChild(del); boxTP.appendChild(row); });
      }

      function updateTemplateText(){
        try{
          const sym=(el('kd_symbol').value||'BTCUSDT').toUpperCase();
          const tf=el('kd_timeframe').value||'4h';
          const supTxt = supports.length? supports.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : '';
          const resTxt = resistances.length? resistances.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : '';
          const eTxt = entries.length? entries.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : '';
          const tpTxt = tps.length? tps.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : '';
          let tpl = `å¸ç§ $${sym}ï¼Œæ—¶é—´å‘¨æœŸ ${tf}`;
          if(supTxt) tpl += `ï¼›æ”¯æ’‘ï¼š${supTxt}`;
          if(resTxt) tpl += `ï¼›é˜»åŠ›ï¼š${resTxt}`;
          if(eTxt)   tpl += `ï¼›å¼€ä»“ï¼š${eTxt}`;
          if(tpTxt)  tpl += `ï¼›æ­¢ç›ˆï¼š${tpTxt}`;
          el('kd_nlp').value = tpl;
        }catch(_){ }
      }

      async function loadSeries(symbol, timeframe, source){ try{ status(`åŠ è½½ ${symbol} ${timeframe} (${source})...`); const resp=await fetch('/realtime-fib/api/analyze',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({symbol,timeframe,source,include_series:true})}); const data=await resp.json(); if(!data.success) throw new Error(data.error||'åŠ è½½å¤±è´¥'); const arr=(data.result.series||[]).map(r=>({ time: Math.floor((r.t||r.timestamp)/1000), open:r.open, high:r.high, low:r.low, close:r.close })); ensureChart(); if(!series) { status('å›¾è¡¨æœªåˆå§‹åŒ–','error'); return; } series.setData(arr); status(`å·²åŠ è½½ï¼š${data.result.symbol} / ${data.result.timeframe} / æº ${data.result.source}`); } catch(e){ console.error(e); status(`åŠ è½½å¤±è´¥ï¼š${e.message}`,'error'); } }
      function addLevel(kind, price){
        const p=parseFloat(price); if(!p||isNaN(p)) return;
        if(kind==='support'){
          supports.push(snap(p)); sLabels.push(''); sortDedup('support'); renderLists();
        } else if(kind==='resistance'){
          resistances.push(snap(p)); rLabels.push(''); sortDedup('resistance'); renderLists();
        } else if(kind==='entry'){
          entries.push(snap(p)); renderLists();
        } else if(kind==='tp'){
          tps.push(snap(p)); renderLists();
        }
        applyLines(); updateTemplateText();
      }

      return {
        init(){ ensureChart(); renderLists(); updateTemplateText(); try{ el('kd_symbol').addEventListener('change', updateTemplateText); el('kd_timeframe').addEventListener('change', updateTemplateText); const modeSel=el('kd_clickMode'); const editSel=el('kd_editMode'); const updOverlay=()=>{ const box=el('kd_chart'); const overlay = box.querySelector('#kd_textOverlay'); const v = modeSel? modeSel.value : 'none'; const edit = editSel? editSel.checked : false; if(overlay){ overlay.style.display = (edit || v==='text') ? 'block' : 'none'; overlay.style.cursor = (v==='text') ? 'text' : 'default'; } box.style.cursor = (edit || v==='text') ? 'text' : 'default'; }; if(modeSel){ modeSel.addEventListener('change',updOverlay);} if(editSel){ editSel.addEventListener('change',updOverlay);} updOverlay(); }catch(_){ } },
        addText(){ ensureChart(); addAnnoDefault(); updateTemplateText(); },
        parse(){
          const txt=(el('kd_nlp').value||'').trim(); if(!txt) return;
          // å¸ç§è§£æï¼š$BTC / å¸ç§: BTCUSDT / ç›´æ¥å‡ºç° BTCUSDT
          let sym=null; const m1=txt.match(/\$([A-Za-z]{2,15})/); if(m1) sym=m1[1]+(m1[1].toUpperCase().endsWith('USDT')?'':'USDT');
          const m2=txt.match(/å¸ç§[ï¼š: ]*([A-Za-z]{2,15})/); if(!sym && m2){ const raw=m2[1].toUpperCase(); sym=raw.endsWith('USDT')?raw:(raw+'USDT'); }
          const m3=txt.match(/([A-Z]{2,15}USDT)/); if(!sym && m3) sym=m3[1].toUpperCase(); if(!sym) sym='BTCUSDT'; el('kd_symbol').value=sym;
          // æ—¶é—´å‘¨æœŸè§£æ
          let tf='4h'; if(/1\s*å¤©|æ—¥çº¿|\b1d\b/i.test(txt)) tf='1d'; else if(/4\s*å°æ—¶|\b4h\b/i.test(txt)) tf='4h'; else if(/1\s*å°æ—¶|\b1h\b/i.test(txt)) tf='1h'; el('kd_timeframe').value=tf;
          // è§£æâ€˜æ”¯æ’‘ä½â€™/â€˜é˜»åŠ›ä½â€™å—ï¼Œä¸¥æ ¼æˆªå–åˆ°ä¸‹ä¸€ä¸ªå…³é”®è¯å‰
          const supportKeys = ['æ”¯æ’‘ä½','æ”¯æ’‘ä»·','æ”¯æ’‘åŒºé—´','æ”¯æ’‘','support'];
          const resistKeys  = ['é˜»åŠ›ä½','é˜»åŠ›ä»·','é˜»åŠ›åŒºé—´','é˜»åŠ›','resistance'];
          const nextLabels  = [...supportKeys, ...resistKeys, 'å¸ç§','symbol','æ—¶é—´å‘¨æœŸ','æ—¶é—´','å‘¨æœŸ'];
          function firstIndexOf(text, keys){ let best={idx:-1,key:null}; keys.forEach(k=>{ const i=text.indexOf(k); if(i>=0 && (best.idx<0 || i<best.idx)) best={idx:i,key:k}; }); return best; }
          function blockBetween(keys){
            const hit = firstIndexOf(txt, keys); if(hit.idx<0) return '';
            let s = txt.slice(hit.idx + hit.key.length);
            if (s[0] && /[\s:ï¼š]/.test(s[0])) s = s.slice(1);
            let end = s.length;
            nextLabels.forEach(lab=>{ const k=s.indexOf(lab); if(k>=0 && k<end) end=k; });
            ['ã€‚','ï¼›',';','\n','ï¼Œ',','].forEach(p=>{ const k=s.indexOf(p); if(k>=0 && k<end) end=k; });
            return s.slice(0,end);
          }
          function parseLevelBlock(block){
            const parts = block.split(/[ï¼Œ,\/\sã€]+/).map(t=>t.trim()).filter(Boolean);
            const out=[];
            parts.forEach(t=>{
              // å¿½ç•¥å¸¦å•ä½çš„ç‰‡æ®µï¼Œå¦‚ 4å°æ—¶/1å¤©/4h/15m
              if(/[A-Za-z\u4e00-\u9fa5]/.test(t)) return;
              if(/[æ—¶å¤©åˆ†hHdDmM]/.test((block||'').slice((block||'').indexOf(t)+t.length, (block||'').indexOf(t)+t.length+1))) return;
              const v = parseFloat(t);
              if(isFinite(v)) out.push(v);
            });
            return out;
          }
          const supBlock = blockBetween(supportKeys);
          const resBlock = blockBetween(resistKeys);
          supports = parseLevelBlock(supBlock).sort((a,b)=>a-b);
          resistances = parseLevelBlock(resBlock).sort((a,b)=>a-b);
          sLabels = new Array(supports.length).fill('');
          rLabels = new Array(resistances.length).fill('');
          renderLists();
          // æ›´æ–°æ¨¡æ¿ä¸å›¾
          updateTemplateText();
          this.drawChart();
        },
        addLevel(kind){ let id=''; if(kind==='support') id='kd_supportAdd'; else if(kind==='resistance') id='kd_resistanceAdd'; else if(kind==='entry') id='kd_entryAdd'; else if(kind==='tp') id='kd_tpAdd'; if(!id) return; const val=parseFloat(el(id).value); if(!val||isNaN(val)) return; addLevel(kind, val); el(id).value=''; },
        applyLevels(){ applyLines(); },
        drawChart(){ ensureChart(); const sym=el('kd_symbol').value.trim().toUpperCase(); const tf=el('kd_timeframe').value; const src=el('kd_source').value; resize(); loadSeries(sym, tf, src); applyLines(); },
        toggleAutoRefresh(){ const btn=el('kd_autoBtn'); if(autoTimer){ clearInterval(autoTimer); autoTimer=null; btn.textContent='å¼€å¯è‡ªåŠ¨åˆ·æ–°'; status('è‡ªåŠ¨åˆ·æ–°å…³é—­'); return; } const sym=el('kd_symbol').value.trim().toUpperCase(); const tf=el('kd_timeframe').value; const src=el('kd_source').value; autoTimer=setInterval(()=>loadSeries(sym,tf,src), 30000); btn.textContent='å…³é—­è‡ªåŠ¨åˆ·æ–°'; status('è‡ªåŠ¨åˆ·æ–°ä¸­ï¼Œæ¯ 30s æ›´æ–°ä¸€æ¬¡'); },
        exportPNG(){ try{ ensureChart(); if(!chart){ status('å›¾è¡¨æœªåˆå§‹åŒ–','error'); return; } const sym=(el('kd_symbol').value||'SYMBOL').toUpperCase(); const tfRaw=el('kd_timeframe').value||'tf'; const tf=tfRaw.toUpperCase(); const ts=new Date().toISOString().replace(/[:.]/g,'-'); const name=`kline_${sym}_${tf}_${ts}.png`; const composeAndDownload=(baseCanvas)=>{ const w=baseCanvas.width, h=baseCanvas.height; const out=document.createElement('canvas'); out.width=w; out.height=h; const ctx=out.getContext('2d');             ctx.drawImage(baseCanvas,0,0); // DPI ç¼©æ”¾ç³»æ•°ï¼ˆè®¾å¤‡åƒç´ æ¯”ï¼‰
            const box=el('kd_chart'); const cssW = Math.max(1, box.clientWidth||w); const scale = w / cssW; const fontSize = 12 * scale;
            // æ°´å°: å·¦ä¸Šè§’å¸ç§+å‘¨æœŸï¼ˆåŠ åŠé€æ˜åº•ï¼‰
            ctx.save(); ctx.font=`${fontSize}px Arial`; ctx.textBaseline='top'; const wm = `${sym} ${tf}`; const wmW = ctx.measureText(wm).width; const pad=4*scale; const x=8*scale, y=8*scale; ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(x-pad, y-pad, wmW+pad*2, fontSize+pad*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(wm, x, y); ctx.restore();
            // å¤šä¸ªæ–‡æœ¬æ³¨é‡Šï¼šä»annosæ•°ç»„è·å–æ–‡æœ¬ï¼ˆæ”¯æŒå¤šè¡Œï¼Œä¿ç•™æ¢è¡Œç¬¦ï¼‰
            ctx.save(); ctx.font=`${fontSize}px Arial`; ctx.textBaseline='top'; const lineHeight = fontSize * 1.2; const nodes = box.querySelectorAll('.kd-anno'); nodes.forEach(n=>{ const nodeId = n.dataset.id; const anno = annos.find(a => String(a.id) === nodeId); const text = anno ? (anno.text || '') : ((n.textContent||'').replace('Ã—','').replace(/\s+/g,' ').trim()); if(!text) return; const leftPx = parseFloat(n.style.left||'0'); const topPx = parseFloat(n.style.top||'0'); const xx = (isFinite(leftPx)? leftPx*scale : 16*scale); let yy = (isFinite(topPx)? topPx*scale : 24*scale); const lines = text.split('\n').filter(l => l.trim() || l === ''); if(lines.length === 0) return; const maxWidth = Math.max(...lines.map(line => ctx.measureText(line || ' ').width)); const totalHeight = lines.length * lineHeight; const pad = 4*scale; ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(xx-pad, yy-pad, maxWidth+pad*2, totalHeight+pad*2); ctx.fillStyle='rgba(255,255,255,0.95)'; lines.forEach((line, idx) => { ctx.fillText(line || ' ', xx, yy + idx * lineHeight); }); }); ctx.restore();
            const url=out.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('å·²å¯¼å‡ºå›¾è¡¨ PNG'); };
          if(typeof chart.takeScreenshot==='function'){ const cnv=chart.takeScreenshot(); composeAndDownload(cnv); return; }
          const box=el('kd_chart'); const cvs=box.querySelectorAll('canvas'); if(!cvs||cvs.length===0) throw new Error('æœªæ‰¾åˆ°ç”»å¸ƒ'); const w=cvs[0].width, h=cvs[0].height; const off=document.createElement('canvas'); off.width=w; off.height=h; const ctx=off.getContext('2d'); cvs.forEach(c=>{ try{ ctx.drawImage(c,0,0); }catch(_){}}); composeAndDownload(off); }catch(e){ console.error(e); status('å¯¼å‡ºå¤±è´¥:'+e.message,'error'); } },
        saveConfig: async function(){ try{ const payload={ name: el('kd_saveName').value.trim(), symbol: el('kd_symbol').value.trim().toUpperCase(), timeframe: el('kd_timeframe').value, source: el('kd_source').value, supports, resistances, supports_labels: sLabels, resistances_labels: rLabels, entries, tps, annotations: annos.map(a=>({x:a.x,y:a.y,text:a.text})) }; const resp=await fetch('/kline-draw/api/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)}); const data=await resp.json(); if(!data.success) throw new Error(data.error||'ä¿å­˜å¤±è´¥'); status('å·²ä¿å­˜:'+data.id); this.loadSavedList(); }catch(e){ status('ä¿å­˜å¤±è´¥:'+e.message,'error'); } },
        loadSavedList: async function(){ try{ const sym=el('kd_symbol').value.trim().toUpperCase(); const resp=await fetch('/kline-draw/api/list?symbol='+encodeURIComponent(sym)); const data=await resp.json(); if(!data.success) throw new Error(data.error||'åŠ è½½å¤±è´¥'); const list=data.items||[]; const box=el('kd_savedList'); box.innerHTML=''; list.forEach(item=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center'; const txt=document.createElement('div'); txt.textContent=`${item.name||'(æœªå‘½å)'} Â· ${item.symbol} ${item.timeframe} Â· ${new Date(item.created_at).toLocaleString()}`; const load=document.createElement('button'); load.className='btn'; load.textContent='è½½å…¥';           load.onclick=()=>{ el('kd_symbol').value=item.symbol||'BTCUSDT'; el('kd_timeframe').value=item.timeframe||'4h'; el('kd_source').value=item.source||'gate'; supports=(item.supports||[]).slice(); resistances=(item.resistances||[]).slice(); entries=(item.entries||[]).slice(); tps=(item.tps||[]).slice(); sLabels=(item.supports_labels||new Array(supports.length).fill('')).slice(); rLabels=(item.resistances_labels||new Array(resistances.length).fill('')).slice(); sortDedup('support'); sortDedup('resistance'); renderLists(); // é‡å»ºæ³¨é‡Š
            annos=[]; const boxChart=el('kd_chart'); boxChart.querySelectorAll('.kd-anno').forEach(n=>n.remove()); (item.annotations||[]).forEach(a=>addAnnoAt(parseFloat(a.x||0), parseFloat(a.y||0), a.text||'')); KLINE.drawChart(); };
          const del=document.createElement('button'); del.className='btn'; del.textContent='åˆ é™¤'; del.onclick=async ()=>{ const r=await fetch('/kline-draw/api/delete',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:item.id})}); const j=await r.json(); if(j.success){ KLINE.loadSavedList(); } }; row.appendChild(txt); row.appendChild(load); row.appendChild(del); box.appendChild(row); }); status(`å·²åŠ è½½ä¿å­˜é¡¹ï¼š${list.length} æ¡`); }catch(e){ status('åŠ è½½ä¿å­˜åˆ—è¡¨å¤±è´¥:'+e.message,'error'); } },
        exportJSON(){ const obj={ symbol: el('kd_symbol').value.trim().toUpperCase(), timeframe: el('kd_timeframe').value, source: el('kd_source').value, supports, resistances, supports_labels: sLabels, resistances_labels: rLabels, entries, tps }; const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.download=`kline_config_${obj.symbol}_${obj.timeframe}_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('å·²å¯¼å‡ºé…ç½® JSON'); },
        exportCSV(){ const lines=['kind,label,price']; supports.forEach((p,i)=>lines.push(`support,${(sLabels[i]||'')},${p}`)); resistances.forEach((p,i)=>lines.push(`resistance,${(rLabels[i]||'')},${p}`)); entries.forEach((p,i)=>lines.push(`entry,,${p}`)); tps.forEach((p,i)=>lines.push(`tp,,${p}`)); const blob=new Blob(['\uFEFF'+lines.join('\n')],{type:'text/csv;charset=utf-8;'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='levels.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('å·²å¯¼å‡ºæ°´å¹³çº¿ CSV'); },
        importJSON(input){ const file=input.files&&input.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ try{ const obj=JSON.parse(reader.result); el('kd_symbol').value=obj.symbol||'BTCUSDT'; el('kd_timeframe').value=obj.timeframe||'4h'; el('kd_source').value=obj.source||'gate'; supports=(obj.supports||[]).slice(); resistances=(obj.resistances||[]).slice(); entries=(obj.entries||[]).slice(); tps=(obj.tps||[]).slice(); sLabels=(obj.supports_labels||new Array(supports.length).fill('')).slice(); rLabels=(obj.resistances_labels||new Array(resistances.length).fill('')).slice(); sortDedup('support'); sortDedup('resistance'); renderLists(); KLINE.drawChart(); status('å·²å¯¼å…¥é…ç½®'); }catch(e){ status('å¯¼å…¥å¤±è´¥:'+e.message,'error'); } }; reader.readAsText(file); input.value=''; }
      };
    })();
    </script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            position: relative;
            overflow-x: hidden;
        }
        
        /* åŠ¨æ€èƒŒæ™¯æ ·å¼ */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            overflow: hidden;
            display: none; /* é»˜è®¤éšè—åŠ¨ç”»èƒŒæ™¯ */
        }
        
        /* æ·»åŠ æ˜Ÿæ˜Ÿæ•ˆæœ */
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.4);
        }
        
        .star:nth-child(1) {
            top: 15%;
            left: 20%;
            animation-delay: 0s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(2) {
            top: 25%;
            right: 15%;
            animation-delay: 0.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(3) {
            top: 45%;
            left: 10%;
            animation-delay: 1s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(4) {
            top: 35%;
            right: 25%;
            animation-delay: 1.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(5) {
            top: 65%;
            left: 30%;
            animation-delay: 2s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(6) {
            top: 55%;
            right: 40%;
            animation-delay: 2.5s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(7) {
            top: 75%;
            left: 60%;
            animation-delay: 3s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(8) {
            top: 85%;
            right: 20%;
            animation-delay: 3.5s;
            width: 3px;
            height: 3px;
        }
        
        @keyframes twinkle {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.3);
            }
        }
        

        
        /* è§†é¢‘èƒŒæ™¯æ ·å¼ */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            object-fit: cover;
            opacity: 0.8;
            display: block; /* é»˜è®¤æ˜¾ç¤ºè§†é¢‘èƒŒæ™¯ */
            filter: blur(2px);
        }
        
        .video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
            z-index: -2;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: transparent; 
            padding: 20px;
            border-radius: 15px;
            position: relative;
            z-index: 1;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .help-text {
            background: rgba(0, 0, 0, 0.1);
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 5px 5px 0;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .tab {
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: transparent;
            border-radius: 0 0 5px 5px;
            color: white;
        }
        .tab-content.active {
            display: block;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        
        /* è¶…çŸ­äº¤æ˜“è¯¦æƒ…æ ·å¼ */
        .signal-details {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 5px;
            border-left: 3px solid #007bff;
        }
        
        .detail-item label {
            font-weight: bold;
            color: #ccc;
        }
        
        .detail-item span {
            color: #fff;
            font-weight: bold;
        }
        
        .trading-signals {
            margin-bottom: 20px;
        }
        
        .signal-item:last-child {
            border-bottom: none;
        }
        
        .signal-label {
            color: #ccc;
            font-weight: bold;
        }
        
        .signal-value {
            color: #fff;
            font-weight: bold;
        }
        
        .strategy-explanation {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #28a745;
        }
        
        .strategy-explanation h6 {
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .strategy-explanation p {
            margin: 8px 0;
            color: #ccc;
            line-height: 1.5;
        }
        
        /* æ—¥å¿—è¯Šæ–­æ ·å¼ */
        .logs-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            max-height: 600px;
            overflow: hidden;
        }
        
        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .log-count {
            color: #007bff;
            font-size: 14px;
            font-weight: normal;
        }
        
        .log-controls {
            display: flex;
            gap: 15px;
        }
        
        .log-controls label {
            color: #ccc;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .logs-content {
            background: #0a0a0a;
            border-radius: 5px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px 8px;
            border-radius: 3px;
            border-left: 3px solid #333;
            word-wrap: break-word;
        }
        
        .log-entry.info {
            border-left-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }
        
        .log-entry.warning {
            border-left-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .log-entry.error {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .log-time {
            color: #888;
            font-size: 11px;
            margin-right: 10px;
        }
        
        .log-level {
            color: #fff;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            display: inline-block;
        }
        
        .log-message {
            color: #ccc;
        }
        
        .log-entry.info .log-level {
            color: #007bff;
        }
        
        .log-entry.warning .log-level {
            color: #ffc107;
        }
        
        .log-entry.error .log-level {
            color: #dc3545;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-warning:hover {
            background: #e0a800;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.1);
            color: white;
        }
        .results-container {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 15px;
            background: transparent;
            color: white;
        }
        .result-item {
            background: transparent;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
            color: white;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background: rgba(40, 167, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .status.error {
            background: rgba(220, 53, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: transparent;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
                .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .stat-label {
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* è¡¨æ ¼æ ·å¼ */
         .table-container {
             overflow-x: auto;
             margin-top: 15px;
         }
         
                                                                                                                                                                                                                               .analysis-table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            color: white;
            border-radius: 8px;
            overflow: hidden;
        }
         
         .analysis-table th,
         .analysis-table td {
             padding: 12px 8px;
             text-align: left;
             border-bottom: 1px solid #e9ecef;
         }
         
                                                                                                                                                                                                                               .analysis-table th {
            background: transparent;
            font-weight: bold;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 10;
            padding: 15px 12px;
        }
         
                           .analysis-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
                                   .analysis-table tr:nth-child(even) {
              background: transparent;
          }
         
         /* ç­›é€‰æ§åˆ¶æ ·å¼ */
                                                                                                                                                                                                                               .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            flex-wrap: wrap;
            color: white;
        }
         
         .filter-group {
             display: flex;
             align-items: center;
             gap: 8px;
         }
         
         .filter-group label {
             font-weight: bold;
             margin: 0;
             white-space: nowrap;
         }
         
                                                                               .filter-group select,
            .filter-group input {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
         .filter-group button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .filter-group button:hover {
             background: #0056b3;
         }
         
         /* åˆ†é¡µæ§åˆ¶æ ·å¼ */
                                                                                                                                                                                                                               .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            color: white;
        }
         
         .pagination-controls button {
             padding: 8px 15px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .pagination-controls button:hover {
             background: #0056b3;
         }
         
         .pagination-controls button:disabled {
             background: #6c757d;
             cursor: not-allowed;
         }
         
                                                                               .pagination-controls select {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
                 #pageInfo {
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* çŠ¶æ€æ ‡ç­¾æ ·å¼ */
         .status-badge {
             padding: 4px 8px;
             border-radius: 12px;
             font-size: 12px;
             font-weight: bold;
             text-align: center;
         }
         
         .status-buy {
             background: #d4edda;
             color: #155724;
         }
         
         .status-sell {
             background: #f8d7da;
             color: #721c24;
         }
         
         .status-hold {
             background: #fff3cd;
             color: #856404;
         }
         
         /* æ“ä½œæŒ‰é’®æ ·å¼ */
         .action-btn {
             padding: 4px 8px;
             margin: 2px;
             border: none;
             border-radius: 3px;
             cursor: pointer;
             font-size: 12px;
         }
         
         
         /* æ¨¡æ€å¯¹è¯æ¡†æ ·å¼ */
         .modal {
             display: none;
             position: fixed;
             z-index: 1000;
             left: 0;
             top: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.7);
             backdrop-filter: blur(5px);
         }
         
         .modal-content {
             background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
             margin: 5% auto;
             padding: 30px;
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: 15px;
             width: 80%;
             max-width: 500px;
             color: white;
             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
         }
         
         .modal-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px solid rgba(255, 255, 255, 0.3);
         }
         
         .modal-title {
             font-size: 20px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .close {
             color: rgba(255, 255, 255, 0.7);
             font-size: 28px;
             font-weight: bold;
             cursor: pointer;
             transition: color 0.3s;
         }
         
         .close:hover {
             color: white;
         }
         
         .modal-body {
             margin-bottom: 20px;
         }
         
         .modal-footer {
             display: flex;
             justify-content: flex-end;
             gap: 10px;
         }
         
         /* å›¾è¡¨å®¹å™¨æ ·å¼ */
         .chart-container {
             margin-top: 20px;
             padding: 20px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 10px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .chart-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 15px;
             color: white;
         }
         
         .chart-title {
             font-size: 18px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .chart-controls {
             display: flex;
             gap: 10px;
             align-items: center;
         }
         
         .chart-controls button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .chart-controls button:hover {
             background: #0056b3;
         }
         
         .chart-controls button.active {
             background: #28a745;
         }
         
         .chart-controls select {
             padding: 6px 10px;
             border: 1px solid rgba(255, 255, 255, 0.5);
             border-radius: 4px;
             background: rgba(0, 0, 0, 0.1);
             color: white;
             font-size: 12px;
         }
         
         .chart-wrapper {
             position: relative;
             height: 400px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             padding: 10px;
         }
         
         .chart-legend {
             display: flex;
             flex-wrap: wrap;
             gap: 15px;
             margin-top: 10px;
             padding: 10px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 5px;
         }
         
         .legend-item {
             display: flex;
             align-items: center;
             gap: 5px;
             font-size: 12px;
             color: white;
         }
         
         .legend-color {
             width: 12px;
             height: 2px;
             border-radius: 1px;
         }
         
         /* äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿æ ·å¼ */
         .cross-points-panel {
             margin-top: 15px;
             padding: 15px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .cross-points-panel h4 {
             color: white;
             margin: 0 0 15px 0;
             font-size: 16px;
         }
         
         .cross-points-tabs {
             display: flex;
             gap: 10px;
             margin-bottom: 15px;
         }
         
         .cross-tab {
             padding: 8px 16px;
             background: rgba(255, 255, 255, 0.1);
             color: white;
             border: 1px solid rgba(255, 255, 255, 0.2);
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .cross-tab:hover {
             background: rgba(255, 255, 255, 0.2);
         }
         
         .cross-tab.active {
             background: #007bff;
             border-color: #007bff;
         }
         
         .cross-tab-content {
             display: none;
         }
         
         .cross-tab-content.active {
             display: block;
         }
         
         .cross-points-list {
             max-height: 200px;
             overflow-y: auto;
         }
         
         .cross-point-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 8px 12px;
             margin-bottom: 8px;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 4px;
             border-left: 3px solid;
             font-size: 12px;
         }
         
         .cross-point-item.golden-cross {
             border-left-color: #00ff00;
         }
         
         .cross-point-item.death-cross {
             border-left-color: #ff0000;
         }
         
         .cross-point-info {
             color: white;
         }
         
         .cross-point-price {
             font-weight: bold;
             color: #ffd700;
         }
         
         .cross-point-time {
             color: #ccc;
             font-size: 11px;
         }
         
         .stats-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin: 15px 0;
         }
         
         .stat-item {
             background: rgba(255, 255, 255, 0.10);
             padding: 12px;
             border-radius: 6px;
             border-left: 4px solid #3498db;
             color: #ffffff;
         }
         .stat-item strong { color: #ffd54f; }
         
         /* æ–æ³¢æ¦‚ç‡é¢„æµ‹æ ·å¼ */
         .fibonacci-levels-container {
             margin-top: 20px;
         }
         
         .fib-levels-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .fib-level-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             border: 2px solid transparent;
             transition: all 0.3s ease;
         }
         
         .fib-level-item.high {
             border-color: #4CAF50;
             background: rgba(76, 175, 80, 0.1);
         }
         
         .fib-level-item.medium {
             border-color: #FFC107;
             background: rgba(255, 193, 7, 0.1);
         }
         
         .fib-level-item.low {
             border-color: #f44336;
             background: rgba(244, 67, 54, 0.1);
         }
         
         .fib-level-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 10px;
         }
         
         .probability-badge {
             background: rgba(255, 255, 255, 0.2);
             padding: 4px 8px;
             border-radius: 15px;
             font-weight: bold;
         }
         
         .fib-level-details {
             margin-bottom: 15px;
         }
         
         .fib-price, .fib-probability {
             margin: 5px 0;
             font-size: 14px;
         }
         
         .fib-factors {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 8px;
         }
         
         .factor-item {
             display: flex;
             justify-content: space-between;
             font-size: 12px;
             padding: 4px 8px;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 5px;
         }
         
         .batch-results-container {
             margin-top: 20px;
         }
         
         .batch-results-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .batch-result-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
         }
         
         .batch-symbol {
             font-weight: bold;
             font-size: 16px;
             margin-bottom: 10px;
             color: #ffd700;
         }
         
         .batch-probabilities {
             display: flex;
             flex-direction: column;
             gap: 5px;
         }
         
         .batch-prob-item {
             display: flex;
             justify-content: space-between;
             padding: 5px 10px;
             border-radius: 5px;
             font-size: 12px;
         }
         
         .batch-prob-item.high {
             background: rgba(76, 175, 80, 0.2);
             color: #4CAF50;
         }
         
         .batch-prob-item.medium {
             background: rgba(255, 193, 7, 0.2);
             color: #FFC107;
         }
         
         .batch-prob-item.low {
             background: rgba(244, 67, 54, 0.2);
             color: #f44336;
         }
         
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             margin-top: 20px;
         }
         
         /* æ–æ³¢è¯¦æƒ…æ ·å¼ */
         .fibonacci-levels-info {
             margin-top: 20px;
         }
         
         .fib-levels-detail-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .fib-level-detail-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             border: 2px solid transparent;
             transition: all 0.3s ease;
         }
         
         .fib-level-detail-item.high {
             border-color: #4CAF50;
             background: rgba(76, 175, 80, 0.1);
         }
         
         .fib-level-detail-item.medium {
             border-color: #FFC107;
             background: rgba(255, 193, 7, 0.1);
         }
         
         .fib-level-detail-item.low {
             border-color: #f44336;
             background: rgba(244, 67, 54, 0.1);
         }
         
         .fib-distance {
             color: #ffd700;
             font-size: 14px;
             margin: 5px 0;
         }
         
         /* å®æ—¶æ–æ³¢åˆ†ææ ·å¼ */
         .fib-position-container {
             margin-top: 20px;
         }
         
         .fib-position-info {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .position-item {
             background: rgba(255, 255, 255, 0.10);
             padding: 12px;
             border-radius: 6px;
             border-left: 4px solid #3498db;
             color: #ffffff;
         }
         
         .recent-analysis-container {
             margin-top: 20px;
         }
         
         .recent-stats-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .status-active {
             color: #4CAF50;
             font-weight: bold;
         }
         
         .status-inactive {
             color: #f44336;
             font-weight: bold;
         }
         
         .chart-container {
             max-width: 1100px;
             height: 420px;
             margin: 0 auto;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 10px;
         }
         .chart-container canvas {
             width: 100% !important;
             height: 100% !important;
         }
         
        
        .info-box {
            background: rgba(255, 255, 255, 0.10);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            color: #ffffff;
        }
        
        .info-box h4 {
            margin-top: 0;
            color: #ffffff;
        }
        
        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info-box li {
            margin: 5px 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- åŠ¨æ€èƒŒæ™¯ -->
    <div class="animated-background">
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
    </div>
    
    <!-- è§†é¢‘èƒŒæ™¯ -->
    <video class="video-background" autoplay muted loop playsinline>
        <source src="/static/videos/background.mp4" type="video/mp4">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ ‡ç­¾ã€‚
    </video>
    <div class="video-overlay"></div>
    
    <div class="container">
        <div class="header">
            <h1>å¸ƒæ—å¸¦ç­–ç•¥æŒ‚å•ç³»ç»Ÿ</h1>
            <p>åŸºäºå¸ƒæ—å¸¦æŠ€æœ¯æŒ‡æ ‡çš„æ™ºèƒ½åŠ å¯†è´§å¸åˆ†æç³»ç»Ÿ</p>
        </div>
        
        <div class="help-text">
                            <strong>ç³»ç»Ÿè¯´æ˜ï¼š</strong>æœ¬ç³»ç»ŸåŸºäºå¸ƒæ—å¸¦æŠ€æœ¯æŒ‡æ ‡åˆ†æåŠ å¯†è´§å¸ä»·æ ¼èµ°åŠ¿ï¼Œæä¾›æ™ºèƒ½æŒ‚å•å»ºè®®ã€‚æ”¯æŒ<span id="totalSymbolsDisplay">195</span>ä¸ªå¸ç§ã€å¤šæ—¶é—´å‘¨æœŸã€å¤šäº¤æ˜“æ‰€æ•°æ®æºã€æŒä»“ç®¡ç†ç­‰åŠŸèƒ½ã€‚
        </div>

        <!-- ç³»ç»Ÿç»Ÿè®¡ -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="totalSymbols">195</div>
                <div class="stat-label">æ”¯æŒå¸ç§</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="analyzedCount">0</div>
                <div class="stat-label">å·²åˆ†æ</div>
            </div>
        </div>

        <!-- Tabå¯¼èˆª -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('analysis', event)">ğŸ“Š å¸ç§åˆ†æ</button>
            <button class="tab" onclick="showTab('multiTimeframe', event)">ğŸ“ˆ å¤šæ—¶é—´æ¡†æ¶</button>
            <button class="tab" onclick="showTab('hotCoins', event)">ğŸ”¥ çƒ­ç‚¹å¸ç§åˆ†æ</button>
            <button class="tab" onclick="showTab('klineDraw', event)">ğŸ“‰ Kçº¿ç»˜åˆ¶</button>
            <button class="tab" onclick="showTab('ultraShort', event)">âš¡ è¶…çŸ­BTC</button>
            <button class="tab" onclick="showTab('logs', event)">ğŸ” æ—¥å¿—è¯Šæ–­</button>
            <button class="tab" onclick="showTab('management', event)">âš™ï¸ ç³»ç»Ÿç®¡ç†</button>
        </div>

        <!-- å¸ç§åˆ†æTab -->
        <div id="analysis" class="tab-content active">
            <h3>å¸ç§åˆ†æ</h3>
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeDefault()">åˆ†æå…¨éƒ¨<span id="analyzeButtonCount">130</span>ä¸ªå¸ç§</button>
                <button class="btn btn-info" onclick="showAddSymbolModal()">â• æ–°å¢å¸ç§</button>
                <button class="btn btn-warning" onclick="analyzeCustom()">åˆ†æè‡ªå®šä¹‰å¸ç§</button>
                <button class="btn btn-success" onclick="exportSymbols()">ğŸ“¤ å¯¼å‡ºå¸ç§åˆ—è¡¨</button>
                <button class="btn btn-outline-primary" onclick="saveAllSymbols()">ğŸ’¾ ä¿å­˜å…¨éƒ¨</button>
                <button class="btn btn-primary" onclick="showImportModal()">ğŸ“¥ å¯¼å…¥å¸ç§åˆ—è¡¨</button>
            </div>
            <div class="form-group">
                <label>è‡ªå®šä¹‰å¸ç§ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼š</label>
                <textarea class="form-control" id="symbolsInput" rows="3" placeholder="ä¾‹å¦‚: BTC, ETH, ADA, DOT"></textarea>
            </div>
            <div class="form-group">
                <label><input type="checkbox" id="forceRefresh"> å¼ºåˆ¶åˆ·æ–°æ•°æ®</label>
            </div>
            <div id="analysisResults" class="results-container" style="display: none;">
                <h4>åˆ†æç»“æœ</h4>
                
                <!-- ç­›é€‰å’Œæ’åºæ§åˆ¶ -->
                <div class="filter-controls">
                    <div class="filter-group">
                        <label>æ—¶é—´çº§åˆ«:</label>
                        <select id="timeframeFilter" onchange="filterResults()">
                            <option value="all">å…¨éƒ¨</option>
                            <option value="12h">12å°æ—¶</option>
                            <option value="1d">1å¤©</option>
                            <option value="3d">3å¤©</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>æ’åº:</label>
                        <select id="sortBy" onchange="sortResults()">
                            <option value="symbol">å¸ç§</option>
                            <option value="price">å½“å‰ä»·æ ¼</option>
                            <option value="orderPrice">æŒ‚å•ä»·æ ¼</option>
                            <option value="timeframe">æ—¶é—´çº§åˆ«</option>
                        </select>
                        <button id="sortOrder" onclick="toggleSortOrder()">â†‘</button>
                    </div>
                    <div class="filter-group">
                        <label>æœç´¢:</label>
                        <input type="text" id="searchSymbol" placeholder="æœç´¢å¸ç§..." onkeyup="filterResults()">
                    </div>
                </div>
                
                <!-- åˆ†é¡µæ§åˆ¶ -->
                <div class="pagination-controls">
                    <button onclick="changePage(-1)" id="prevPage">ä¸Šä¸€é¡µ</button>
                    <span id="pageInfo">ç¬¬ 1 é¡µï¼Œå…± 1 é¡µ</span>
                    <button onclick="changePage(1)" id="nextPage">ä¸‹ä¸€é¡µ</button>
                    <select id="pageSize" onchange="changePageSize()">
                        <option value="20">20æ¡/é¡µ</option>
                        <option value="50">50æ¡/é¡µ</option>
                        <option value="100">100æ¡/é¡µ</option>
                    </select>
                    <button class="btn btn-success" onclick="exportAnalysisResultsToCSV()" style="margin-left: 20px;">
                        ğŸ“¥ å¯¼å‡ºåˆ†æç»“æœ (CSV)
                    </button>
                </div>
                
                <!-- ç»“æœè¡¨æ ¼ -->
                <div class="table-container">
                    <table id="analysisTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>å¸ç§</th>
                                <th>å½“å‰ä»·æ ¼</th>
                                <th>æŒ‚å•ä»·æ ¼</th>
                                <th>æ—¶é—´çº§åˆ«</th>
                                <th>çŠ¶æ€</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="analysisTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥Tab -->
        <div id="multiTimeframe" class="tab-content">
            <h3>ğŸ“ˆ å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥</h3>
            <div class="help-text">
                <strong>ç­–ç•¥è¯´æ˜ï¼š</strong>åŸºäºEMA144/233/377/610çš„å¤šæ—¶é—´æ¡†æ¶è¶‹åŠ¿è·Ÿè¸ªç­–ç•¥ã€‚ä»4Hå¼€å§‹ï¼Œä¾æ¬¡åˆ†æ8H/12H/1D/3D/1Wï¼Œä»·æ ¼å›è¸©å‡çº¿æ—¶å¼€ä»“ï¼Œæ­¢ç›ˆä½¿ç”¨å¯¹åº”æ—¶é—´æ¡†æ¶çš„å¸ƒæ—ä¸­è½¨ã€‚
            </div>
            
            <div class="form-group">
                <label for="strategyTypeSelect">ç­–ç•¥ç±»å‹:</label>
                <select id="strategyTypeSelect" class="form-control" style="width: 300px; display: inline-block;">
                    <option value="original">åŸç­–ç•¥ (4H/8H/12H/1D/3D/1Wï¼Œä¸åŒæ­¢ç›ˆ)</option>
                    <option value="modified">ä¿®æ”¹ç­–ç•¥ (8H/12H/1D/3D/1Wï¼Œç»Ÿä¸€3åˆ†é’Ÿæ­¢ç›ˆ)</option>
                </select>
            </div>
            
            <div class="form-group">
                <button class="btn btn-primary" onclick="analyzeMultiTimeframeSymbols()">åˆ†æå‰500å¸ç§</button>
                <button class="btn btn-info" onclick="getMultiTimeframeTopSymbols()">è·å–å¸ç§åˆ—è¡¨</button>
                <button class="btn btn-warning" onclick="clearMultiTimeframeCache()">æ¸…é™¤EMAè®°å½•</button>
                <button class="btn btn-secondary" onclick="validateMultiTimeframeSymbol()">éªŒè¯å¸ç§</button>
            </div>
            
            <div class="form-group">
                <label for="multiTimeframeSymbolInput">è‡ªå®šä¹‰å¸ç§åˆ†æ:</label>
                <input type="text" id="multiTimeframeSymbolInput" class="form-control" placeholder="è¾“å…¥å¸ç§ï¼Œå¦‚: BTC, ETH, DOT" style="width: 300px; display: inline-block;">
                <button class="btn btn-success" onclick="analyzeCustomMultiTimeframeSymbols()">åˆ†æ</button>
            </div>
            
            <div class="form-group">
                <label for="multiTimeframeProfitFilter">æ”¶ç›Šç‡è¿‡æ»¤:</label>
                <select id="multiTimeframeProfitFilter" class="form-control" style="width: 200px; display: inline-block;">
                    <option value="0" selected>æ˜¾ç¤ºå…¨éƒ¨</option>
                    <option value="0.2">â‰¥ 0.2% (æ”¶ç›Šè¾ƒä½)</option>
                    <option value="0.5">â‰¥ 0.5% (ä¸€èˆ¬æœºä¼š)</option>
                    <option value="1.0">â‰¥ 1.0% (ä¼˜è´¨æœºä¼š)</option>
                </select>
                <button class="btn btn-sm btn-outline-primary" onclick="applyMultiTimeframeFilter()">åº”ç”¨è¿‡æ»¤</button>
            </div>
            
            <div class="form-group">
                <label for="pageSizeSelect">æ¯é¡µæ˜¾ç¤º:</label>
                <select id="pageSizeSelect" class="form-control" style="width: 150px; display: inline-block;">
                    <option value="10">10ä¸ªä¿¡å·</option>
                    <option value="20" selected>20ä¸ªä¿¡å·</option>
                    <option value="50">50ä¸ªä¿¡å·</option>
                </select>
                <button class="btn btn-sm btn-outline-secondary" onclick="changePageSize()">æ›´æ”¹é¡µé¢å¤§å°</button>
            </div>
            
            <div class="form-group" id="paginationControls" style="display: none;">
                <button class="btn btn-sm btn-outline-primary" onclick="previousSignalPage()" id="prevBtn" disabled>ä¸Šä¸€é¡µ</button>
                    <span id="pageInfo" style="margin: 0 10px;">ç¬¬1é¡µï¼Œå…±1é¡µ (ä¿¡å·åˆ†é¡µ)</span>
                <button class="btn btn-sm btn-outline-primary" onclick="nextSignalPage()" id="nextBtn" disabled>ä¸‹ä¸€é¡µ</button>
                <button class="btn btn-sm btn-success" onclick="exportAllSignalsToCSV()" style="margin-left: 20px;">
                    ğŸ“¥ å¯¼å‡ºå…¨éƒ¨æ•°æ® (CSV)
                </button>
            </div>
            
            <!-- å¤šæ—¶é—´æ¡†æ¶ä¿¡å·è¡¨æ ¼ -->
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>å¸ç§</th>
                            <th>æ—¶é—´æ¡†æ¶</th>
                            <th>è¶‹åŠ¿</th>
                            <th>EMAçº§åˆ«</th>
                            <th>å…¥åœºä»·æ ¼</th>
                            <th>æ­¢ç›ˆä»·æ ¼</th>
                            <th>æ”¶ç›Šç‡</th>
                            <th>ä¿¡å·ç±»å‹</th>
                            <th>ä¿¡å·æ—¶é—´</th>
                            <th>æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="multiTimeframeSignalsTableBody">
                        <tr>
                            <td colspan="10" style="text-align: center; color: #666;">æš‚æ— å¤šæ—¶é—´æ¡†æ¶äº¤æ˜“ä¿¡å·</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- çŠ¶æ€æ˜¾ç¤º -->
            <div id="multiTimeframeStatus" class="status-message"></div>
            
            <!-- å›¾è¡¨åŒºåŸŸï¼ˆå¤šæ—¶é—´æ¡†æ¶å†…åµŒå›¾è¡¨ï¼‰ -->
            <div id="chartSection" style="display:none; margin-top: 20px;">
                <div class="form-group" style="display:flex; gap: 10px; align-items:center; flex-wrap:wrap;">
                    <label for="chartSymbolSelect">å¸ç§:</label>
                    <select id="chartSymbolSelect" class="form-control" style="width: 160px;"></select>
                    
                    <label for="chartTimeframeSelect">æ—¶é—´å‘¨æœŸ:</label>
                    <select id="chartTimeframeSelect" class="form-control" style="width: 140px;" onchange="updateChartTimeframe()">
                        <option value="5m">5åˆ†é’Ÿ</option>
                        <option value="15m">15åˆ†é’Ÿ</option>
                        <option value="1h">1å°æ—¶</option>
                        <option value="4h">4å°æ—¶</option>
                        <option value="1d">1å¤©</option>
                    </select>
                    
                    <button class="btn" onclick="refreshChart()">ğŸ”„ åˆ·æ–°</button>
                    <button class="btn" onclick="toggleChartVisibility()">ğŸ‘ï¸ æ˜¾ç¤º/éšè—</button>
                </div>
                <div class="chart-wrapper" style="height:420px; border:1px solid rgba(255,255,255,0.2); padding:10px; border-radius:6px;">
                    <canvas id="emaChart"></canvas>
                </div>
                <div class="chart-legend" id="chartLegend" style="margin-top:10px;"></div>
                
                <!-- äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿ï¼ˆå½“å‰åç«¯æœªè¿”å›äº¤å‰ç‚¹ï¼Œé»˜è®¤éšè—ï¼‰ -->
                <div class="cross-points-panel" id="crossPointsPanel" style="display: none; margin-top: 10px;">
                    <h4>ğŸ¯ äº¤å‰ç‚¹ä½ä¿¡æ¯</h4>
                    <div class="cross-points-tabs">
                        <button class="cross-tab active" onclick="showCrossTab('price', event)">ä»·æ ¼äº¤å‰</button>
                        <button class="cross-tab" onclick="showCrossTab('indicator', event)">å‡çº¿äº¤å‰</button>
                    </div>
                    <div class="cross-points-content">
                        <div id="priceCrossPoints" class="cross-tab-content active">
                            <div class="cross-points-list" id="priceCrossList"></div>
                        </div>
                        <div id="indicatorCrossPoints" class="cross-tab-content">
                            <div class="cross-points-list" id="indicatorCrossList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ—¥å¿—è¯Šæ–­Tab -->
        <div id="logs" class="tab-content">
            <h3>ğŸ” æ—¥å¿—è¯Šæ–­</h3>
            <div class="help-text">
                <strong>æ—¥å¿—è¯Šæ–­è¯´æ˜ï¼š</strong>å®æ—¶æ˜¾ç¤ºç³»ç»Ÿè¿è¡Œæ—¥å¿—ï¼Œä¾¿äºè°ƒè¯•å’Œé—®é¢˜è¯Šæ–­ã€‚åŒ…æ‹¬è¶…çŸ­äº¤æ˜“åˆ†æã€æ•°æ®è·å–ã€é”™è¯¯ä¿¡æ¯ç­‰ã€‚
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="startLogMonitoring()">å¼€å§‹ç›‘æ§æ—¥å¿—</button>
                <button class="btn btn-warning" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn btn-secondary" onclick="exportLogs()">å¯¼å‡ºæ—¥å¿—</button>
            </div>
            
            <div class="form-group">
                <label for="logLevelFilter">æ—¥å¿—çº§åˆ«è¿‡æ»¤:</label>
                <select id="logLevelFilter" class="form-control" onchange="filterLogs()">
                    <option value="all">å…¨éƒ¨</option>
                    <option value="INFO">INFO</option>
                    <option value="WARNING">WARNING</option>
                    <option value="ERROR">ERROR</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="logSearch">æœç´¢æ—¥å¿—:</label>
                <input type="text" id="logSearch" class="form-control" placeholder="è¾“å…¥å…³é”®è¯æœç´¢æ—¥å¿—..." onkeyup="searchLogs()">
            </div>
            
            <!-- æ—¥å¿—æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="logs-container">
                <div class="logs-header">
                    <h4>å®æ—¶æ—¥å¿— <span id="logCount" class="log-count">(0æ¡)</span></h4>
                    <div class="log-controls">
                        <label>
                            <input type="checkbox" id="autoScroll" checked> è‡ªåŠ¨æ»šåŠ¨
                        </label>
                        <label>
                            <input type="checkbox" id="showTimestamp" checked> æ˜¾ç¤ºæ—¶é—´æˆ³
                        </label>
                    </div>
                </div>
                <div id="logsContent" class="logs-content">
                    <div class="log-entry info">
                        <span class="log-time">[ç³»ç»Ÿå¯åŠ¨]</span>
                        <span class="log-level">INFO</span>
                        <span class="log-message">æ—¥å¿—ç³»ç»Ÿå·²å°±ç»ªï¼Œç­‰å¾…æ—¥å¿—è¾“å‡º...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- çƒ­ç‚¹å¸ç§åˆ†æTab -->
        <div id="hotCoins" class="tab-content">
            <h3>ğŸ”¥ çƒ­ç‚¹å¸ç§åˆ†æ</h3>
            
            <!-- åŠŸèƒ½æ¨¡å¼åˆ‡æ¢ -->
            <div style="margin-bottom: 20px;">
                <button class="cross-tab active" onclick="switchHotCoinsMode('realtime', event)">âš¡ å®æ—¶åˆ†æ</button>
                <button class="cross-tab" onclick="switchHotCoinsMode('historical', event)">ğŸ“ˆ å†å²æ—¶æ®µåˆ†æ</button>
            </div>
            
            <!-- å®æ—¶åˆ†ææ¨¡å¼ -->
            <div id="realtimeMode" style="display: block;">
                <div class="help-text">
                    <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>å®æ—¶åˆ†æ350ä¸ªä¸»æµå¸ç§çš„24å°æ—¶ä»·æ ¼è¡¨ç°ï¼Œæ‰¾å‡ºå¸‚åœºçƒ­ç‚¹å’ŒæŠ•èµ„æœºä¼šã€‚æ•°æ®æºï¼šGate.io
                </div>
                
                <div class="form-group">
                    <button class="btn btn-success" onclick="analyzeHotCoins()">ğŸ” å¼€å§‹åˆ†æ</button>
                    <button class="btn btn-info" onclick="showHotCoinsSymbols()">ğŸ“‹ æŸ¥çœ‹å¸ç§åˆ—è¡¨</button>
                </div>
            </div>
            
            <!-- å†å²æ—¶æ®µåˆ†ææ¨¡å¼ -->
            <div id="historicalMode" style="display: none;">
                <div class="help-text">
                    <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>åˆ†ææŒ‡å®šæ—¶é—´æ®µå†…çš„å¸ç§æ¶¨å¹…ï¼Œç­›é€‰è¶…çº§ç‰›å¸ï¼Œå¹¶æä¾›é¡¹ç›®è¯¦æƒ…ã€ç ”å‘è¿›å±•ã€èµ„é‡‘æµå‘ç­‰æ·±åº¦åˆ†æã€‚
                </div>
                
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #444;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">ğŸ“… å¼€å§‹æ—¥æœŸ</label>
                            <input type="date" id="advStartDate" class="form-control" value="2025-08-20" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">ğŸ“… ç»“æŸæ—¥æœŸ</label>
                            <input type="date" id="advEndDate" class="form-control" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">ğŸ¯ æœ€é«˜ç‚¹æ¶¨å¹…å€æ•°</label>
                            <input type="number" id="minGainRatio" value="3" min="0.5" step="0.1" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                            <small style="color: #999;">å¦‚è¾“å…¥3è¡¨ç¤ºç­›é€‰æœŸé—´æœ€é«˜ç‚¹è¾¾åˆ°3å€ï¼ˆå³200%æ¶¨å¹…ï¼‰çš„å¸ç§</small>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; color: #e0e0e0;">
                        <label style="margin-right: 20px;">
                            <input type="checkbox" id="includeProjectInfo" checked>
                            <strong>ğŸ“‹ åŒ…å«é¡¹ç›®è¯¦æƒ…</strong>ï¼ˆåç§°ã€æè¿°ã€èµ›é“ã€é“¾æ¥ã€ç¤¾åŒºæ•°æ®ç­‰ï¼‰
                        </label>
                        <label>
                            <input type="checkbox" id="includeMoneyFlow" checked>
                            <strong>ğŸ’° åŒ…å«èµ„é‡‘æµå‘</strong>ï¼ˆæ¯æ—¥èµ„é‡‘æµå…¥æµå‡ºåˆ†æï¼‰
                        </label>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn btn-success" onclick="analyzeHistoricalPeriod()">ğŸš€ å¼€å§‹å†å²åˆ†æ</button>
                        <button class="btn btn-info" onclick="showAdvancedExample()">ğŸ’¡ æŸ¥çœ‹ç¤ºä¾‹</button>
                    </div>
                </div>
            </div>
            
            <!-- åˆ†æè¿›åº¦ -->
            <div id="hotCoinsProgress" style="display: none; margin: 20px 0;">
                <div style="background: #f0f0f0; border-radius: 5px; padding: 15px;">
                    <div style="margin-bottom: 10px;">
                        <strong>åˆ†æè¿›åº¦ï¼š</strong>
                        <span id="hotCoinsProgressText">0/0</span>
                    </div>
                    <div style="background: #fff; height: 20px; border-radius: 10px; overflow: hidden;">
                        <div id="hotCoinsProgressBar" style="background: linear-gradient(90deg, #28a745, #20c997); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>
            
            <!-- åˆ†æç»“æœæ¦‚è§ˆ -->
            <div id="hotCoinsSummary" style="display: none; margin: 20px 0;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="totalCoins">0</div>
                        <div style="font-size: 12px; color: #999;">æ€»å¸ç§æ•°</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="successCoins">0</div>
                        <div style="font-size: 12px; color: #999;">æˆåŠŸè·å–</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;" id="positiveCoins">0</div>
                        <div style="font-size: 12px; color: #999;">ä¸Šæ¶¨å¸ç§</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="avgChange">0%</div>
                        <div style="font-size: 12px; color: #999;">å¹³å‡æ¶¨è·Œ</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;" id="maxGain">0%</div>
                        <div style="font-size: 12px; color: #999;">æœ€å¤§æ¶¨å¹…</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #dc3545; margin-bottom: 5px;" id="maxLoss">0%</div>
                        <div style="font-size: 12px; color: #999;">æœ€å¤§è·Œå¹…</div>
                    </div>
                </div>
            </div>
            
            <!-- Tabåˆ‡æ¢ -->
            <div id="hotCoinsTabsContainer" style="display: none; margin: 20px 0;">
                <div style="border-bottom: 2px solid #444; margin-bottom: 20px;">
                    <button class="cross-tab active" onclick="showHotCoinsSubTab('gainers', event)">ğŸš€ æ¶¨å¹…æ¦œ</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('losers', event)">ğŸ“‰ è·Œå¹…æ¦œ</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('volume', event)">ğŸ’° äº¤æ˜“é‡æ¦œ</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('distribution', event)">ğŸ“Š æ¶¨è·Œåˆ†å¸ƒ</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('all', event)">ğŸ“‹ å®Œæ•´åˆ—è¡¨</button>
                </div>
                
                <!-- æ¶¨å¹…æ¦œ -->
                <div id="gainersTab" class="cross-tab-content active">
                    <h4 style="color: #e0e0e0;">ğŸš€ TOP 20 æ¶¨å¹…æ¦œ</h4>
                    <div id="gainersContent"></div>
                </div>
                
                <!-- è·Œå¹…æ¦œ -->
                <div id="losersTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">ğŸ“‰ TOP 20 è·Œå¹…æ¦œ</h4>
                    <div id="losersContent"></div>
                </div>
                
                <!-- äº¤æ˜“é‡æ¦œ -->
                <div id="volumeTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">ğŸ’° TOP 20 äº¤æ˜“é‡æ¦œ</h4>
                    <div id="volumeContent"></div>
                </div>
                
                <!-- æ¶¨è·Œåˆ†å¸ƒ -->
                <div id="distributionTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">ğŸ“Š æ¶¨è·Œåˆ†å¸ƒç»Ÿè®¡</h4>
                    <div id="distributionContent"></div>
                </div>
                
                <!-- å®Œæ•´åˆ—è¡¨ -->
                <div id="allTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">ğŸ“‹ æ‰€æœ‰å¸ç§åˆ—è¡¨</h4>
                    <div style="margin-bottom: 10px;">
                        <input type="text" id="coinSearchInput" placeholder="æœç´¢å¸ç§..." style="padding: 8px; width: 300px; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e0e0;">
                    </div>
                    <div id="allCoinsContent"></div>
                </div>
            </div>
            
            <!-- ç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
            <div id="hotCoinsResults"></div>
        </div>

        <!-- Kçº¿ç»˜åˆ¶ï¼ˆå†…åµŒç‰ˆï¼‰ -->
        <div id="klineDraw" class="tab-content">
            <h3>ğŸ“‰ ä¸“ä¸šKçº¿ç»˜åˆ¶</h3>
            <p class="muted">åŸºäº TradingView Lightweight Chartsï¼›æ”¯æŒè‡ªç„¶è¯­è¨€è§£ææ”¯æ’‘/é˜»åŠ›ã€ç‚¹å‡»åŠ çº¿ã€æ‹–æ‹½ã€ä¿å­˜/å¯¼å…¥/å¯¼å‡ºã€å¯¼å‡ºå›¾è¡¨PNGã€‚</p>

            <div class="form-group">
                <label>è‡ªç„¶è¯­è¨€æè¿°</label>
                <textarea id="kd_nlp" class="form-control" rows="3" placeholder="ä¾‹ï¼šå¸ç§ $BTCï¼Œæ—¶é—´å‘¨æœŸ 4å°æ—¶ï¼›æ”¯æ’‘ä½ï¼š61200, 60000ï¼›é˜»åŠ›ä½ï¼š63500ï¼›å¼€ä»“ï¼š62000ï¼›æ­¢ç›ˆï¼š65000"></textarea>
                <div style="margin-top:8px;">
                    <button class="btn btn-primary" onclick="KLINE.parse()">è§£æ</button>
                    <button class="btn" onclick="KLINE.clearAll()">æ¸…ç©º</button>
                </div>
            </div>

            <div class="form-group">
                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                    <div style="flex:1; min-width:220px;">
                        <label>å¸ç§ï¼ˆç°è´§ï¼Œå¦‚ BTCUSDTï¼‰</label>
                        <input id="kd_symbol" class="form-control" value="BTCUSDT">
                    </div>
                    <div>
                        <label>æ—¶é—´å‘¨æœŸ</label>
                        <select id="kd_timeframe" class="form-control">
                            <option value="1d">1å¤©</option>
                            <option value="4h" selected>4å°æ—¶</option>
                            <option value="1h">1å°æ—¶</option>
                        </select>
                    </div>
                    <div>
                        <label>æ•°æ®æº</label>
                        <select id="kd_source" class="form-control">
                            <option value="gate" selected>Gate.io</option>
                            <option value="bybit">Bybit</option>
                        </select>
                    </div>
                    <div>
                        <label>ç‚¹å‡»æ·»åŠ </label>
                        <select id="kd_clickMode" class="form-control">
                            <option value="none" selected>å…³é—­</option>
                            <option value="support">æ”¯æ’‘</option>
                            <option value="resistance">é˜»åŠ›</option>
                            <option value="entry">å…¥åœº</option>
                            <option value="tp">æ­¢ç›ˆ</option>
                            <option value="text">æ–‡æœ¬</option>
                        </select>
                    </div>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <label for="kd_editMode" style="margin:0;">ç¼–è¾‘æ¨¡å¼</label>
                        <input type="checkbox" id="kd_editMode" />
                    </div>
                </div>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 2fr; gap: 12px; align-items:start;">
                <div>
                    <div class="form-group">
                        <label>æ”¯æ’‘ä½</label>
                        <div id="kd_supportLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_supportAdd" class="form-control" placeholder="è¾“å…¥ä»·æ ¼">
                            <button class="btn" onclick="KLINE.addLevel('support')">æ·»åŠ æ”¯æ’‘</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>é˜»åŠ›ä½</label>
                        <div id="kd_resistanceLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_resistanceAdd" class="form-control" placeholder="è¾“å…¥ä»·æ ¼">
                            <button class="btn" onclick="KLINE.addLevel('resistance')">æ·»åŠ é˜»åŠ›</button>
                        </div>
                    </div>
                    <!-- æ·»åŠ å…¥åœºä»·æ ¼ -->
                    <div class="form-group">
                        <label>å…¥åœºä»·æ ¼</label>
                        <div id="kd_entryLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_entryAdd" class="form-control" placeholder="è¾“å…¥ä»·æ ¼">
                            <button class="btn" onclick="KLINE.addLevel('entry')">æ·»åŠ å…¥åœº</button>
                        </div>
                    </div>
                    <!-- æ·»åŠ æ­¢ç›ˆä»·æ ¼ -->
                    <div class="form-group">
                        <label>æ­¢ç›ˆä»·æ ¼</label>
                        <div id="kd_tpLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_tpAdd" class="form-control" placeholder="è¾“å…¥ä»·æ ¼">
                            <button class="btn" onclick="KLINE.addLevel('tp')">æ·»åŠ æ­¢ç›ˆ</button>
                        </div>
                    </div>
                    <!-- æ·»åŠ æ–‡æœ¬æ³¨é‡Šåˆ—è¡¨ -->
                    <div class="form-group">
                        <label>æ–‡æœ¬æ³¨é‡Š</label>
                        <div id="kd_annoList" class="results-container" style="max-height:180px; overflow:auto;"></div>
                    </div>
                    <div class="form-group" style="display:flex; gap:8px; flex-wrap:wrap;">
                        <button class="btn btn-primary" onclick="KLINE.drawChart()">ç»˜åˆ¶å›¾è¡¨</button>
                        <button class="btn" onclick="KLINE.applyLevels()">åº”ç”¨æ°´å¹³çº¿</button>
                        <button class="btn" id="kd_autoBtn" onclick="KLINE.toggleAutoRefresh()">å¼€å¯è‡ªåŠ¨åˆ·æ–°</button>
                        <button class="btn" onclick="KLINE.exportPNG()">å¯¼å‡ºå›¾è¡¨PNG</button>
                        <button class="btn" onclick="KLINE.addText()">æ·»åŠ æ–‡æœ¬æ³¨é‡Š</button>
                    </div>
                    <div class="form-group" style="display:flex; gap:8px; flex-wrap:wrap;">
                        <input id="kd_saveName" class="form-control" placeholder="ä¿å­˜åç§°ï¼ˆå¯é€‰ï¼‰">
                        <button class="btn" onclick="KLINE.saveConfig()">ä¿å­˜åˆ°æœåŠ¡å™¨</button>
                        <button class="btn" onclick="KLINE.loadSavedList()">åŠ è½½ä¿å­˜åˆ—è¡¨</button>
                        <button class="btn" onclick="KLINE.exportJSON()">å¯¼å‡ºé…ç½®JSON</button>
                        <button class="btn" onclick="KLINE.exportCSV()">å¯¼å‡ºæ°´å¹³çº¿CSV</button>
                        <input type="file" id="kd_importFile" accept="application/json" onchange="KLINE.importJSON(this)">
                    </div>
                    <div id="kd_savedList" class="results-container" style="max-height:200px; overflow:auto;"></div>
                    <div id="kd_status" class="muted" style="margin-top:6px;"></div>
                </div>
                <div>
                    <div id="kd_chart" style="height:620px; position:relative; background:#0f111a; z-index:10; pointer-events:auto; touch-action:none;"></div>
                </div>
            </div>
        </div>

        <!-- è¶…çŸ­BTC Tab -->
        <div id="ultraShort" class="tab-content">
            <h3>âš¡ è¶…çŸ­BTCä¿¡å·ç³»ç»Ÿ</h3>
            <div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 20px; margin-top: 20px;">
                <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
                <div>
                    <div class="form-group">
                        <button class="btn btn-primary" onclick="ultraShortStartMonitor()">å¼€å§‹ç›‘æ§</button>
                        <button class="btn" onclick="ultraShortStopMonitor()">åœæ­¢ç›‘æ§</button>
                        <button class="btn" onclick="ultraShortCheckSignal()">æ‰‹åŠ¨æ£€æŸ¥</button>
                    </div>
                    
                    <div class="form-group">
                        <label>æ—¶é—´æ¡†æ¶</label>
                        <select id="ultraShortTimeframe" class="form-control">
                            <option value="1m">1åˆ†é’Ÿ</option>
                            <option value="2m">2åˆ†é’Ÿ</option>
                            <option value="3m">3åˆ†é’Ÿ</option>
                            <option value="5m" selected>5åˆ†é’Ÿ</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>ç›‘æ§çŠ¶æ€</label>
                        <div id="ultraShortStatus" style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                            <div>çŠ¶æ€: <span id="ultraShortMonitorStatus">æœªå¯åŠ¨</span></div>
                            <div>ä¸Šæ¬¡æ£€æŸ¥: <span id="ultraShortLastCheck">-</span></div>
                            <div>ç›ˆäºæ¯”: <span style="color: #4caf50;">1:2</span> (æ­¢æŸ150ç‚¹ / æ­¢ç›ˆ300ç‚¹)</div>
                        </div>
                    </div>
                    
                    <!-- å®æ—¶ä¿¡å· -->
                    <div class="form-group">
                        <h4>å®æ—¶ä¿¡å·</h4>
                        <div id="ultraShortActiveSignals" style="max-height: 300px; overflow-y: auto;">
                            <p class="muted">æš‚æ— æ´»è·ƒä¿¡å·</p>
                        </div>
                    </div>
                    
                    <!-- å†å²ä¿¡å· -->
                    <div class="form-group">
                        <h4>å†å²ä¿¡å·</h4>
                        <div id="ultraShortHistorySignals" style="max-height: 300px; overflow-y: auto;">
                            <p class="muted">æš‚æ— å†å²è®°å½•</p>
                        </div>
                    </div>
                </div>
                
                <!-- å³ä¾§å›¾è¡¨åŒºåŸŸ -->
                <div>
                    <div id="ultraShortChart" style="height: 600px; background: #0f111a; position: relative;"></div>
                    <div id="ultraShortChartStatus" class="muted" style="margin-top: 10px;"></div>
                </div>
            </div>
        </div>

        <!-- ç³»ç»Ÿç®¡ç†Tab -->
        <div id="management" class="tab-content">
            <h3>ç³»ç»Ÿç®¡ç†</h3>
            <div class="form-group">
                <button class="btn btn-warning" onclick="clearCache()">æ¸…é™¤ç¼“å­˜</button>
                <button class="btn" onclick="downloadCSV()">ä¸‹è½½CSVæŠ¥å‘Š</button>
                <button class="btn" onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
                <button class="btn" onclick="importData()">å¯¼å…¥æ•°æ®</button>
                <a class="btn" href="/kline-draw" target="_blank">æ‰“å¼€Kçº¿ç»˜åˆ¶ï¼ˆæ–°é¡µï¼‰</a>
            </div>
            
            <div class="form-group">
                <h4>èƒŒæ™¯æ§åˆ¶</h4>
                <button class="btn btn-info" onclick="toggleVideoBackground()">åˆ‡æ¢èƒŒæ™¯æ¨¡å¼</button>
                <button class="btn btn-secondary" onclick="toggleBackground()">å¼€å…³èƒŒæ™¯</button>
                <label>èƒŒæ™¯é€æ˜åº¦: <input type="range" min="10" max="100" value="30" onchange="adjustVideoOpacity(this.value)"></label>
                <span id="opacityValue">30%</span>
            </div>
            <div class="form-group">
                <label>ç³»ç»Ÿè®¾ç½®ï¼š</label>
                <input type="number" class="form-control" id="refreshInterval" placeholder="åˆ·æ–°é—´éš”(ç§’)" value="30">
                <input type="number" class="form-control" id="maxPositions" placeholder="æœ€å¤§æŒä»“æ•°" value="10">
                <input type="number" class="form-control" id="stopLoss" placeholder="æ­¢æŸç™¾åˆ†æ¯”" value="5">
            </div>
            <div id="systemStatus" class="results-container">
                <h4>ç³»ç»ŸçŠ¶æ€</h4>
                <div id="statusContent">
                    <p>æ­£åœ¨åŠ è½½ç³»ç»ŸçŠ¶æ€...</p>
                </div>
            </div>
        </div>


        <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ -->
        <div id="statusArea"></div>
    </div>
    
    <!-- æ–°å¢å¸ç§æ¨¡æ€å¯¹è¯æ¡† -->
    <div id="addSymbolModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">æ–°å¢å¸ç§</span>
                <span class="close" onclick="closeAddSymbolModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>è¯·è¾“å…¥è¦æ–°å¢çš„å¸ç§ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼š</label>
                    <textarea class="form-control" id="newSymbolsInput" rows="4" placeholder="ä¾‹å¦‚: BTC, ETH, ADA, DOT, LINK, UNI"></textarea>
                </div>
                <div class="form-group">
                    <p style="color: #ffc107; font-size: 14px;">
                        ğŸ’¡ æç¤ºï¼šæ–°å¢çš„å¸ç§å°†è¢«ä¿å­˜åˆ°ç³»ç»Ÿä¸­ï¼Œä¸‹æ¬¡åˆ†ææ—¶ä¼šåŒ…å«è¿™äº›å¸ç§ã€‚
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeAddSymbolModal()">å–æ¶ˆ</button>
                <button class="btn btn-success" onclick="addNewSymbols()">ç¡®è®¤æ·»åŠ </button>
            </div>
        </div>
    </div>

    <!-- å¯¼å…¥å¸ç§æ¨¡æ€å¯¹è¯æ¡† -->
    <div id="importSymbolModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">å¯¼å…¥å¸ç§åˆ—è¡¨</span>
                <span class="close" onclick="closeImportModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>é€‰æ‹©CSVæ–‡ä»¶ï¼š</label>
                    <input type="file" id="importFileInput" accept=".csv" class="form-control">
                </div>
                <div class="form-group">
                    <p style="color: #ffc107; font-size: 14px;">
                        ğŸ’¡ æç¤ºï¼šè¯·é€‰æ‹©åŒ…å«å¸ç§åˆ—è¡¨çš„CSVæ–‡ä»¶ã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨å»é‡ï¼Œä¿ç•™åŸæœ‰å¸ç§ã€‚
                    </p>
                    <p style="color: #17a2b8; font-size: 12px;">
                        ğŸ“‹ CSVæ ¼å¼ï¼šç¬¬ä¸€åˆ—ä¸ºå¸ç§åç§°ï¼Œæ”¯æŒBTCã€BTCUSDTç­‰æ ¼å¼
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">å–æ¶ˆ</button>
                <button class="btn btn-success" onclick="importSymbols()">ç¡®è®¤å¯¼å…¥</button>
            </div>
        </div>
    </div>

    <script>
        let currentResults = [];
        
        // åˆ†é¡µå’Œç­›é€‰ç›¸å…³å˜é‡
        let pageSize = 20;
        let filteredResults = [];
        let sortOrder = 'asc';
        
        // å¸ç§ç®¡ç†ç›¸å…³å˜é‡
        let totalSymbols = 130; // é»˜è®¤å¸ç§æ•°é‡
        
        // æ—¥å†…äº¤æ˜“ç›¸å…³å˜é‡
        
        // å›¾è¡¨ç›¸å…³å˜é‡
        let emaChart = null;
        let currentChartSymbol = '';
        let currentChartTimeframe = '5m';
        let chartData = null;

        // showTabå‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰

                 // åˆ†æé»˜è®¤å¸ç§ - åˆ†æ‰¹å¤„ç†ç‰ˆæœ¬
         async function analyzeDefault() {
             const batchSize = 50; // æ¯æ‰¹å¤„ç†50ä¸ªå¸ç§
             let allResults = [];
             let currentBatch = 0;
             
             showStatus(`æ­£åœ¨åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§ï¼ˆåˆ†æ‰¹å¤„ç†ï¼‰...`, 'success');
             
             try {
                 while (true) {
                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 30000); // 30ç§’è¶…æ—¶
                     
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: [],
                             force_refresh: document.getElementById('forceRefresh').checked,
                             batch_size: batchSize,
                             batch_index: currentBatch
                         }),
                         signal: controller.signal
                     });
                     
                     clearTimeout(timeoutId);

                const data = await response.json();
                if (data.success) {
                         // åˆå¹¶ç»“æœ
                         allResults = allResults.concat(data.results);
                         
                         // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                         const progress = data.batch_info;
                         showStatus(`æ­£åœ¨åˆ†æ... ç¬¬${progress.current_batch}/${progress.total_batches}æ‰¹ (${progress.processed}/${progress.total_symbols})`, 'success');
                         
                         // å®æ—¶æ›´æ–°æ˜¾ç¤º
                         if (data.results.length > 0) {
                             showAnalysisResults(allResults);
                         }
                         
                         // å¦‚æœæ˜¯æœ€åä¸€æ‰¹ï¼Œç»“æŸå¾ªç¯
                         if (progress.is_last_batch) {
                             break;
                         }
                         
                         currentBatch++;
                         
                         // æ·»åŠ å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡å¿«
                         await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    showStatus('åˆ†æå¤±è´¥: ' + data.error, 'error');
                         return;
                     }
                 }
                 
                 showStatus(`åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${allResults.length} ä¸ªå¸ç§`, 'success');
                 currentResults = allResults;
                 updateStats();
                 
             } catch (error) {
                 if (error.name === 'AbortError') {
                     showStatus('è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•', 'error');
                 } else {
                     showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
                 }
                 console.error('åˆ†æé”™è¯¯:', error);
             }
        }

        // åˆ†æè‡ªå®šä¹‰å¸ç§ - åˆ†æ‰¹å¤„ç†ç‰ˆæœ¬
        async function analyzeCustom() {
            const symbols = document.getElementById('symbolsInput').value.trim();
            if (!symbols) {
                showStatus('è¯·è¾“å…¥è¦åˆ†æçš„å¸ç§', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            const batchSize = 50;
            let allResults = [];
            let currentBatch = 0;
            
            showStatus(`æ­£åœ¨åˆ†æ ${symbolList.length} ä¸ªè‡ªå®šä¹‰å¸ç§ï¼ˆåˆ†æ‰¹å¤„ç†ï¼‰...`, 'success');
            
            try {
                while (true) {
                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 30000); // 30ç§’è¶…æ—¶
                     
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: symbolList,
                             force_refresh: document.getElementById('forceRefresh').checked,
                             batch_size: batchSize,
                             batch_index: currentBatch
                         }),
                         signal: controller.signal
                     });
                     
                     clearTimeout(timeoutId);

                const data = await response.json();
                if (data.success) {
                        // åˆå¹¶ç»“æœ
                        allResults = allResults.concat(data.results);
                        
                        // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                        const progress = data.batch_info;
                        showStatus(`æ­£åœ¨åˆ†æ... ç¬¬${progress.current_batch}/${progress.total_batches}æ‰¹ (${progress.processed}/${progress.total_symbols})`, 'success');
                        
                        // å®æ—¶æ›´æ–°æ˜¾ç¤º
                        if (data.results.length > 0) {
                            showAnalysisResults(allResults);
                        }
                        
                        // å¦‚æœæ˜¯æœ€åä¸€æ‰¹ï¼Œç»“æŸå¾ªç¯
                        if (progress.is_last_batch) {
                            break;
                        }
                        
                        currentBatch++;
                        
                        // æ·»åŠ å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡å¿«
                        await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    showStatus('åˆ†æå¤±è´¥: ' + data.error, 'error');
                        return;
                    }
                }
                
                showStatus(`åˆ†æå®Œæˆï¼Œå…±å¤„ç† ${allResults.length} ä¸ªå¸ç§`, 'success');
                currentResults = allResults;
                updateStats();
                
             } catch (error) {
                 if (error.name === 'AbortError') {
                     showStatus('è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•', 'error');
                 } else {
                     showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
                 }
                 console.error('åˆ†æé”™è¯¯:', error);
             }
        }

                 // æ˜¾ç¤ºåˆ†æç»“æœ
         function showAnalysisResults(results) {
             console.log(`showAnalysisResults è¢«è°ƒç”¨: results.length=${results.length}`);
             
             const resultsContainer = document.getElementById('analysisResults');
             
             if (results.length === 0) {
                 document.getElementById('analysisTableBody').innerHTML = '<tr><td colspan="6" style="text-align: center;">æ²¡æœ‰æ‰¾åˆ°ç»“æœ</td></tr>';
                 filteredResults = [];
                 currentResults = [];
                 console.warn('åˆ†æç»“æœä¸ºç©º');
             } else {
                 // ä¸ºæ¯ä¸ªç»“æœæ·»åŠ æ—¶é—´çº§åˆ«
                 const resultsWithTimeframe = results.map(result => ({
                     ...result,
                     timeframe: getRandomTimeframe() // æ¨¡æ‹Ÿæ—¶é—´çº§åˆ«ï¼Œå®é™…åº”è¯¥ä»åç«¯è·å–
                 }));
                 
                 currentResults = resultsWithTimeframe;
                 filteredResults = [...resultsWithTimeframe];
                 
                 console.log(`è®¾ç½® filteredResults: length=${filteredResults.length}`);
                 console.log(`è®¾ç½® currentResults: length=${currentResults.length}`);
                 
                 // é‡ç½®åˆ†é¡µ
                 currentPage = 1;
                 
                 // æ¸²æŸ“è¡¨æ ¼
                 renderTable();
                 updatePagination();
             }
             
             resultsContainer.style.display = 'block';
         }
         
         // æ¨¡æ‹Ÿè·å–æ—¶é—´çº§åˆ«ï¼ˆå®é™…åº”è¯¥ä»åç«¯è·å–ï¼‰
         function getRandomTimeframe() {
             const timeframes = ['12h', '1d', '3d'];
             return timeframes[Math.floor(Math.random() * timeframes.length)];
         }
         
         // æ¸²æŸ“è¡¨æ ¼
         function renderTable() {
             console.log(`renderTable è¢«è°ƒç”¨: currentPage=${currentPage}, pageSize=${pageSize}, filteredResults.length=${filteredResults.length}`);
             
             const tbody = document.getElementById('analysisTableBody');
             if (!tbody) {
                 console.error('æ‰¾ä¸åˆ° analysisTableBody å…ƒç´ ');
                 return;
             }
             
             if (!filteredResults || filteredResults.length === 0) {
                 tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">æ²¡æœ‰æ•°æ®ï¼Œè¯·å…ˆè¿è¡Œåˆ†æ</td></tr>';
                 console.warn('æ²¡æœ‰ filteredResults æ•°æ®');
                 return;
             }
             
             const startIndex = (currentPage - 1) * pageSize;
             const endIndex = startIndex + pageSize;
             const pageData = filteredResults.slice(startIndex, endIndex);
             
             console.log(`æ˜¾ç¤ºæ•°æ®èŒƒå›´: ${startIndex}-${endIndex}, å½“å‰é¡µæ•°æ®: ${pageData.length}æ¡`);
             
             if (pageData.length === 0) {
                 tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">å½“å‰é¡µæ²¡æœ‰æ•°æ®</td></tr>';
                 return;
             }
             
             let html = '';
             pageData.forEach(result => {
                 const symbol = (result.symbol || '').replace('USDT', '');
                 const price = result.current_price ? result.current_price.toFixed(6) : 'N/A';
                 const orderPrice = result.order_price || 'N/A';
                 const timeframe = result.timeframe || '1d';
                 
                 html += `
                     <tr>
                         <td><strong>${symbol}</strong></td>
                         <td>${price}</td>
                         <td>${orderPrice}</td>
                         <td>${timeframe}</td>
                         <td></td>
                         <td>
                             <button class="action-btn action-btn-buy" onclick="viewDetails('${symbol}')">æŸ¥çœ‹è¯¦æƒ…</button>
                         </td>
                     </tr>
                 `;
             });
             
             tbody.innerHTML = html;
         }

        // ä¿å­˜å…¨éƒ¨å¸ç§åˆ°åç«¯æ–‡ä»¶
        async function saveAllSymbols() {
            try {
                const res = await fetch('/save_all_symbols', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await res.json();
                if (data.success) {
                    showStatus(`ä¿å­˜æˆåŠŸï¼šå…± ${data.saved} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus('ä¿å­˜å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (e) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // å¸ç§åˆ†æ - æŸ¥çœ‹è¯¦æƒ…
        function viewDetails(rawSymbol) {
            try {
                const norm = (s) => (s || '').toString().trim().toUpperCase();
                const symbolNoUsdt = norm(rawSymbol).replace(/USDT$/, '');
                const matchResult = (arr) => {
                    if (!Array.isArray(arr)) return null;
                    for (const r of arr) {
                        const rs = norm(r && r.symbol);
                        if (!rs) continue;
                        if (rs === symbolNoUsdt || rs === symbolNoUsdt + 'USDT' || rs.replace(/USDT$/, '') === symbolNoUsdt) {
                            return r;
                        }
                    }
                    return null;
                };

                // ä¼˜å…ˆåœ¨å½“å‰ç»“æœé›†ä¸­æŸ¥æ‰¾
                const result = matchResult(typeof currentResults !== 'undefined' ? currentResults : [])
                              || matchResult(typeof filteredResults !== 'undefined' ? filteredResults : [])
                              || null;

                // æ„å»ºè¯¦æƒ…å†…å®¹
                const sDisp = symbolNoUsdt || 'N/A';
                const price = result && typeof result.current_price === 'number' ? result.current_price.toFixed(6) : 'N/A';
                const orderPrice = result && (typeof result.order_price === 'number' || typeof result.order_price === 'string') ? result.order_price : 'N/A';
                const timeframe = result && result.timeframe ? result.timeframe : (result && result.timeframes ? Object.keys(result.timeframes).join(', ') : 'N/A');
                const dataSource = result && result.data_source ? result.data_source : 'N/A';
                const status = result && result.status ? result.status : 'N/A';
                const upperBand = result && typeof result.upper_band === 'number' ? result.upper_band.toFixed(6) : (result && result.upper_band ? result.upper_band : 'N/A');
                const middleBand = result && typeof result.middle_band === 'number' ? result.middle_band.toFixed(6) : (result && result.middle_band ? result.middle_band : 'N/A');
                const lowerBand = result && typeof result.lower_band === 'number' ? result.lower_band.toFixed(6) : (result && result.lower_band ? result.lower_band : 'N/A');

                // åˆ›å»ºå¹¶æ˜¾ç¤ºå¼¹çª—
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 720px;">
                        <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                        <h3>å¸ç§è¯¦æƒ… - ${sDisp}</h3>
                        <div class="signal-details">
                            <div class="details-grid">
                                <div class="detail-item"><label>å¸ç§</label><span>${sDisp}</span></div>
                                <div class="detail-item"><label>æ—¶é—´æ¡†æ¶</label><span>${timeframe}</span></div>
                                <div class="detail-item"><label>å½“å‰ä»·æ ¼</label><span>${price}</span></div>
                                <div class="detail-item"><label>æŒ‚å•ä»·æ ¼</label><span>${orderPrice}</span></div>
                                <div class="detail-item"><label>ä¸Šè½¨(Upper)</label><span>${upperBand}</span></div>
                                <div class="detail-item"><label>ä¸­è½¨(Middle)</label><span>${middleBand}</span></div>
                                <div class="detail-item"><label>ä¸‹è½¨(Lower)</label><span>${lowerBand}</span></div>
                                <div class="detail-item"><label>æ•°æ®æº</label><span>${dataSource}</span></div>
                                <div class="detail-item"><label>çŠ¶æ€</label><span>${status}</span></div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å…³é—­</button>
                        </div>
                    </div>`;
                document.body.appendChild(modal);
            } catch (e) {
                console.error('æŸ¥çœ‹è¯¦æƒ…å¤±è´¥:', e);
                showStatus('æŸ¥çœ‹è¯¦æƒ…å¤±è´¥: ' + e.message, 'error');
            }
        }

                 // åˆ†é¡µåŠŸèƒ½
         function updatePagination() {
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const pageInfo = document.getElementById('pageInfo');
             const prevBtn = document.getElementById('prevPage');
             const nextBtn = document.getElementById('nextPage');
             
             pageInfo.textContent = `ç¬¬ ${currentPage} é¡µï¼Œå…± ${totalPages} é¡µ (å…± ${filteredResults.length} æ¡è®°å½•)`;
             
             prevBtn.disabled = currentPage <= 1;
             nextBtn.disabled = currentPage >= totalPages;
         }
         
         function changePage(delta) {
             console.log(`changePage è¢«è°ƒç”¨: delta=${delta}, currentPage=${currentPage}, filteredResults.length=${filteredResults.length}, pageSize=${pageSize}`);
             
             if (!filteredResults || filteredResults.length === 0) {
                 showStatus('æ²¡æœ‰åˆ†ææ•°æ®ï¼Œè¯·å…ˆè¿è¡Œå¸ç§åˆ†æ', 'warning');
                 return;
             }
             
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const newPage = currentPage + delta;
             
             console.log(`è®¡ç®—ç»“æœ: totalPages=${totalPages}, newPage=${newPage}`);
             
             if (newPage >= 1 && newPage <= totalPages) {
                 currentPage = newPage;
                 renderTable();
                 updatePagination();
                 showStatus(`åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
             } else if (newPage < 1) {
                 showStatus('å·²ç»æ˜¯ç¬¬ä¸€é¡µäº†', 'info');
             } else if (newPage > totalPages) {
                 showStatus('å·²ç»æ˜¯æœ€åä¸€é¡µäº†', 'info');
             }
         }
         
         function changePageSize() {
             pageSize = parseInt(document.getElementById('pageSize').value);
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // æ’åºåŠŸèƒ½
         function sortResults() {
             const sortBy = document.getElementById('sortBy').value;
             
             filteredResults.sort((a, b) => {
                 let aVal, bVal;
                 
                 switch (sortBy) {
                     case 'symbol':
                         aVal = a.symbol.toLowerCase();
                         bVal = b.symbol.toLowerCase();
                         break;
                     case 'price':
                         aVal = a.current_price || 0;
                         bVal = b.current_price || 0;
                         break;
                     case 'orderPrice':
                         aVal = a.order_price || 0;
                         bVal = b.order_price || 0;
                         break;
                     case 'timeframe':
                         aVal = a.timeframe || '';
                         bVal = b.timeframe || '';
                         break;
                     default:
                         return 0;
                 }
                 
                 if (sortOrder === 'asc') {
                     return aVal > bVal ? 1 : -1;
                 } else {
                     return aVal < bVal ? 1 : -1;
                 }
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         function toggleSortOrder() {
             const sortOrderBtn = document.getElementById('sortOrder');
             sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
             sortOrderBtn.textContent = sortOrder === 'asc' ? 'â†‘' : 'â†“';
             sortResults();
         }
         
         // ç­›é€‰åŠŸèƒ½
         function filterResults() {
             const timeframeFilter = document.getElementById('timeframeFilter').value;
             const searchTerm = document.getElementById('searchSymbol').value.toLowerCase();
             
             filteredResults = currentResults.filter(result => {
                 // æ—¶é—´çº§åˆ«ç­›é€‰
                 if (timeframeFilter !== 'all' && result.timeframe !== timeframeFilter) {
                     return false;
                 }
                 
                 // æœç´¢ç­›é€‰
                 if (searchTerm && !result.symbol.toLowerCase().includes(searchTerm)) {
                     return false;
                 }
                 
                 return true;
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // ä»åˆ†æç»“æœåˆ›å»ºæŒ‚å•
         
         // è·å–å¸ç§åˆ—è¡¨
         async function getSymbols() {
            try {
                const response = await fetch('/get_default_symbols');
                const data = await response.json();
                showStatus(`å½“å‰å¸ç§åˆ—è¡¨ï¼š${data.count} ä¸ªå¸ç§`, 'success');
            } catch (error) {
                showStatus('è·å–å¤±è´¥: ' + error.message, 'error');
            }
        }





        // æ¸…é™¤ç¼“å­˜
        async function clearCache() {
            try {
                const response = await fetch('/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('ç¼“å­˜å·²æ¸…é™¤', 'success');
                } else {
                    showStatus('æ¸…é™¤å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ä¸‹è½½CSV
        async function downloadCSV() {
            if (currentResults.length === 0) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„æ•°æ®ï¼Œè¯·å…ˆè¿›è¡Œåˆ†æ', 'error');
                return;
            }

            try {
                const response = await fetch('/download_csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: currentResults
                    })
                });

                const data = await response.json();
                if (data.success) {
                    const blob = new Blob([data.csv_data], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = data.filename;
                    link.click();
                    showStatus('CSVæ–‡ä»¶ä¸‹è½½æˆåŠŸ', 'success');
                } else {
                    showStatus('ä¸‹è½½å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å¯¼å‡ºæ•°æ®
        function exportData() {
            const data = {
                results: currentResults
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'bollinger_data.json';
            link.click();
            showStatus('æ•°æ®å¯¼å‡ºæˆåŠŸ', 'success');
        }

        // å¯¼å…¥æ•°æ®
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        // orders and positions modules removed
                        if (data.results) currentResults = data.results;
                        
                        // updateOrdersList and updatePositionsList functions removed
                        updateStats();
                        showStatus('æ•°æ®å¯¼å…¥æˆåŠŸ', 'success');
                    } catch (error) {
                        showStatus('æ•°æ®å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStats() {
            document.getElementById('analyzedCount').textContent = currentResults.length;
            // orders and positions modules removed
        }

                 // æ˜¾ç¤ºçŠ¶æ€
         function showStatus(message, type) {
             const statusArea = document.getElementById('statusArea');
             if (statusArea) {
                 statusArea.innerHTML = `<div class="status ${type}">${message}</div>`;
             } else {
                 console.error('statusArea element not found');
             }
         }
         
         // æ–°å¢å¸ç§ç›¸å…³å‡½æ•°
         function showAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'block';
             document.getElementById('newSymbolsInput').value = '';
             document.getElementById('newSymbolsInput').focus();
         }
         
         function closeAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'none';
         }
         
         async function addNewSymbols() {
             const symbolsInput = document.getElementById('newSymbolsInput').value.trim();
             if (!symbolsInput) {
                 showStatus('è¯·è¾“å…¥è¦æ–°å¢çš„å¸ç§', 'error');
                 return;
             }
             
             const symbolList = symbolsInput.split(',').map(s => s.trim()).filter(s => s);
             if (symbolList.length === 0) {
                 showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å¸ç§', 'error');
                 return;
             }
             
             try {
                 const response = await fetch('/add_symbols', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         symbols: symbolList
                     })
                 });
                 
                 const data = await response.json();
                if (data.success) {
                    // æ›´æ–°å¸ç§æ•°é‡
                    totalSymbols = data.total_symbols;
                    
                    // æ›´æ–°é¡µé¢æ˜¾ç¤ºçš„æ‰€æœ‰å¸ç§æ•°é‡å…ƒç´ 
                    const totalSymbolsEl = document.getElementById('totalSymbols');
                    const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                    const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                    
                    if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                    if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                    if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                    
                    // æ›´æ–°åˆ†ææŒ‰é’®æ–‡æœ¬
                    const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                    if (analyzeBtn) {
                        analyzeBtn.textContent = `åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§`;
                    }
                    
                    closeAddSymbolModal();
                    showStatus(`æˆåŠŸæ–°å¢ ${symbolList.length} ä¸ªå¸ç§ï¼Œå½“å‰æ€»è®¡ ${totalSymbols} ä¸ªå¸ç§`, 'success');
                    
                    // åˆ·æ–°é¡µé¢
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                     showStatus('æ–°å¢å¸ç§å¤±è´¥: ' + data.error, 'error');
                 }
             } catch (error) {
                 showStatus('è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
             }
         }
         
         // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
         window.onclick = function(event) {
             const addModal = document.getElementById('addSymbolModal');
             const importModal = document.getElementById('importSymbolModal');
             if (event.target === addModal) {
                 closeAddSymbolModal();
             }
             if (event.target === importModal) {
                 closeImportModal();
             }
         }
         
         // å¯¼å‡ºå¸ç§åˆ—è¡¨
         async function exportSymbols() {
             try {
                 showStatus('æ­£åœ¨å¯¼å‡ºå¸ç§åˆ—è¡¨...', 'info');
                 
                 const response = await fetch('/export_symbols');
                 
                 if (response.ok) {
                     // è·å–æ–‡ä»¶å
                     const contentDisposition = response.headers.get('Content-Disposition');
                     let filename = 'symbols_export.csv';
                     if (contentDisposition) {
                         const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                         if (filenameMatch) {
                             filename = filenameMatch[1];
                         }
                     }
                     
                     // ä¸‹è½½æ–‡ä»¶
                     const blob = await response.blob();
                     const url = window.URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = filename;
                     document.body.appendChild(a);
                     a.click();
                     window.URL.revokeObjectURL(url);
                     document.body.removeChild(a);
                     
                     showStatus('å¸ç§åˆ—è¡¨å¯¼å‡ºæˆåŠŸï¼', 'success');
                 } else {
                     const errorData = await response.json();
                     showStatus('å¯¼å‡ºå¤±è´¥: ' + errorData.error, 'error');
                 }
             } catch (error) {
                 showStatus('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
             }
         }
         
         // æ˜¾ç¤ºå¯¼å…¥æ¨¡æ€æ¡†
         function showImportModal() {
             document.getElementById('importSymbolModal').style.display = 'block';
             document.getElementById('importFileInput').value = '';
         }
         
         // å…³é—­å¯¼å…¥æ¨¡æ€æ¡†
         function closeImportModal() {
             document.getElementById('importSymbolModal').style.display = 'none';
         }
         
         // å¯¼å…¥å¸ç§åˆ—è¡¨
         async function importSymbols() {
             const fileInput = document.getElementById('importFileInput');
             const file = fileInput.files[0];
             
             if (!file) {
                 showStatus('è¯·é€‰æ‹©è¦å¯¼å…¥çš„CSVæ–‡ä»¶', 'error');
                 return;
             }
             
             if (!file.name.toLowerCase().endsWith('.csv')) {
                 showStatus('è¯·é€‰æ‹©CSVæ ¼å¼çš„æ–‡ä»¶', 'error');
                 return;
             }
             
             try {
                 showStatus('æ­£åœ¨å¯¼å…¥å¸ç§åˆ—è¡¨...', 'info');
                 
                 const formData = new FormData();
                 formData.append('file', file);
                 
                 const response = await fetch('/import_symbols', {
                     method: 'POST',
                     body: formData
                 });
                 
                 const data = await response.json();
                 
                 if (data.success) {
                     // æ›´æ–°å¸ç§æ•°é‡
                     totalSymbols = data.total_symbols;
                     
                     // æ›´æ–°é¡µé¢æ˜¾ç¤ºçš„æ‰€æœ‰å¸ç§æ•°é‡å…ƒç´ 
                     const totalSymbolsEl = document.getElementById('totalSymbols');
                     const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                     const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                     
                     if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                     if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                     if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                     
                     // æ›´æ–°åˆ†ææŒ‰é’®æ–‡æœ¬
                     const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                     if (analyzeBtn) {
                         analyzeBtn.textContent = `åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§`;
                     }
                     
                     closeImportModal();
                     showStatus(`æˆåŠŸå¯¼å…¥ ${data.imported_symbols.length} ä¸ªå¸ç§ï¼Œå½“å‰æ€»è®¡ ${totalSymbols} ä¸ªå¸ç§`, 'success');
                     
                     // åˆ·æ–°é¡µé¢
                     setTimeout(() => {
                         location.reload();
                     }, 2000);
                 } else {
                     showStatus('å¯¼å…¥å¤±è´¥: ' + data.error, 'error');
                 }
             } catch (error) {
                 showStatus('å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
             }
         }
         
         // æ›´æ–°å¸ç§æ•°é‡
         async function updateSymbolCount() {
             try {
                 const response = await fetch('/get_symbol_count');
                 const data = await response.json();
                 
                 totalSymbols = data.count;
                 
                 // æ›´æ–°æ‰€æœ‰æ˜¾ç¤ºå¸ç§æ•°é‡çš„åœ°æ–¹
                 const totalSymbolsEl = document.getElementById('totalSymbols');
                 const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                 const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                 
                 if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                 if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                 if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                 
                 // æ›´æ–°åˆ†ææŒ‰é’®æ–‡æœ¬
                 const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                 if (analyzeBtn) {
                     analyzeBtn.textContent = `åˆ†æå…¨éƒ¨${totalSymbols}ä¸ªå¸ç§`;
                 }
                 
                 console.log(`å½“å‰å¸ç§æ•°é‡: ${totalSymbols}`);
             } catch (error) {
                 console.error('è·å–å¸ç§æ•°é‡å¤±è´¥:', error);
             }
         }

        // è§†é¢‘èƒŒæ™¯æ§åˆ¶
        let videoElement = null;
        
        function initVideoBackground() {
            videoElement = document.querySelector('.video-background');
            
            if (videoElement) {
                console.log('æ‰¾åˆ°è§†é¢‘å…ƒç´ ï¼Œå¼€å§‹åˆå§‹åŒ–...');
                
                // æ£€æŸ¥è§†é¢‘æº
                console.log('è§†é¢‘æº:', videoElement.src);
                console.log('è§†é¢‘å½“å‰çŠ¶æ€:', videoElement.readyState);
                
                videoElement.addEventListener('loadeddata', function() {
                    console.log('è§†é¢‘èƒŒæ™¯åŠ è½½å®Œæˆ');
                    showStatus('è§†é¢‘èƒŒæ™¯åŠ è½½å®Œæˆ', 'success');
                });
                
                videoElement.addEventListener('canplay', function() {
                    console.log('è§†é¢‘å¯ä»¥æ’­æ”¾');
                    showStatus('è§†é¢‘èƒŒæ™¯å¯ä»¥æ’­æ”¾', 'success');
                });
                
                videoElement.addEventListener('error', function(e) {
                    console.log('è§†é¢‘èƒŒæ™¯åŠ è½½å¤±è´¥:', e);
                    showStatus('è§†é¢‘èƒŒæ™¯åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŠ¨ç”»èƒŒæ™¯', 'warning');
                    const animatedBg = document.querySelector('.animated-background');
                    if (animatedBg) {
                        animatedBg.style.display = 'block';
                    }
                });
                
                // å¼ºåˆ¶åŠ è½½è§†é¢‘
                videoElement.load();
            } else {
                console.log('æœªæ‰¾åˆ°è§†é¢‘å…ƒç´ ');
                showStatus('æœªæ‰¾åˆ°è§†é¢‘å…ƒç´ ', 'error');
            }
        }
        
        function toggleVideoBackground() {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const overlay = document.querySelector('.video-overlay');
            
            if (video.style.display === 'none' || video.style.display === '') {
                // åˆ‡æ¢åˆ°è§†é¢‘èƒŒæ™¯
                video.style.display = 'block';
                animatedBg.style.display = 'none';
                overlay.style.display = 'block';
                showStatus('å·²åˆ‡æ¢åˆ°è§†é¢‘èƒŒæ™¯', 'success');
            } else {
                // åˆ‡æ¢åˆ°åŠ¨ç”»èƒŒæ™¯
                video.style.display = 'none';
                animatedBg.style.display = 'block';
                overlay.style.display = 'block';
                showStatus('å·²åˆ‡æ¢åˆ°åŠ¨ç”»èƒŒæ™¯', 'info');
            }
        }
        
        function adjustVideoOpacity(value) {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const opacity = value / 100;
            
            if (video) video.style.opacity = opacity;
            if (animatedBg) animatedBg.style.opacity = opacity;
            
            document.getElementById('opacityValue').textContent = value + '%';
            showStatus(`èƒŒæ™¯é€æ˜åº¦å·²è°ƒæ•´ä¸º ${value}%`, 'info');
        }
        
        function toggleBackground() {
            const overlay = document.querySelector('.video-overlay');
            if (overlay.style.display === 'none') {
                overlay.style.display = 'block';
                showStatus('èƒŒæ™¯å·²å¯ç”¨', 'success');
            } else {
                overlay.style.display = 'none';
                showStatus('èƒŒæ™¯å·²ç¦ç”¨', 'info');
            }
        }
        
                 // RSIæ—¥çº¿çªç ´åŠŸèƒ½å·²ç§»é™¤

                 // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
         document.addEventListener('DOMContentLoaded', function() {
             console.log('å¸ƒæ—å¸¦ç­–ç•¥ç³»ç»Ÿå·²åŠ è½½å®Œæˆ');
             showStatus('ç³»ç»Ÿå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹åˆ†æ', 'success');
             updateStats();
             updateSystemStatus();
             
             // è·å–å½“å‰å¸ç§æ•°é‡
             updateSymbolCount();
            
            // åˆå§‹åŒ–è§†é¢‘èƒŒæ™¯
            initVideoBackground();
            
            // åˆå§‹åŒ–å›¾è¡¨
            waitForChartAndInit();
            initChartSymbolSelect();
            
            // åˆå§‹åŒ–åŠ¨ç”»èƒŒæ™¯ï¼ˆé»˜è®¤éšè—ï¼‰
            const animatedBg = document.querySelector('.animated-background');
            if (animatedBg) {
                animatedBg.style.display = 'none';
            }
            
            // å®šæœŸæ›´æ–°ç³»ç»ŸçŠ¶æ€
            setInterval(updateSystemStatus, 30000); // æ¯30ç§’æ›´æ–°ä¸€æ¬¡
            setInterval(updateStats, 10000); // æ¯10ç§’æ›´æ–°ä¸€æ¬¡ç»Ÿè®¡
        });

        // æ›´æ–°ç³»ç»ŸçŠ¶æ€
        function updateSystemStatus() {
            const statusContent = document.getElementById('statusContent');
            const now = new Date();
            const startTime = new Date(now.getTime() - 2 * 60 * 60 * 1000); // 2å°æ—¶å‰
            const uptime = Math.floor((now - startTime) / (1000 * 60)); // åˆ†é’Ÿ
            
            statusContent.innerHTML = `
                <p>ç¼“å­˜çŠ¶æ€: æ­£å¸¸</p>
                <p>APIè¿æ¥: æ­£å¸¸</p>
                <p>æ•°æ®æ›´æ–°: ${now.getMinutes()}åˆ†é’Ÿå‰</p>
                <p>ç³»ç»Ÿè¿è¡Œæ—¶é—´: ${uptime}åˆ†é’Ÿ</p>
                <p>æœ€åæ›´æ–°: ${now.toLocaleTimeString()}</p>
            `;
        }
        
        // å¯¼å‡ºæ—¥å¿—
        async function exportLogs() {
            try {
                const levelFilter = document.getElementById('logLevelFilter').value;
                const searchTerm = document.getElementById('logSearch').value;
                
                let url = '/logs/export_logs?';
                if (levelFilter !== 'all') url += `level=${levelFilter}&`;
                if (searchTerm) url += `search=${encodeURIComponent(searchTerm)}&`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url2 = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url2;
                    a.download = `logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url2);
                    
                    showStatus(`æ—¥å¿—å·²å¯¼å‡ºï¼Œå…± ${data.count} æ¡`, 'success');
                }
            } catch (error) {
                showStatus('å¯¼å‡ºæ—¥å¿—å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // è¿‡æ»¤æ—¥å¿—
        function filterLogs() {
            const levelFilter = document.getElementById('logLevelFilter').value;
            const searchTerm = document.getElementById('logSearch').value.toLowerCase();
            const logEntries = document.querySelectorAll('.log-entry');
            
            logEntries.forEach(entry => {
                const level = entry.querySelector('.log-level').textContent;
                const message = entry.querySelector('.log-message').textContent.toLowerCase();
                
                let show = true;
                
                if (levelFilter !== 'all' && level !== levelFilter) {
                    show = false;
                }
                
                if (searchTerm && !message.includes(searchTerm)) {
                    show = false;
                }
                
                entry.style.display = show ? 'block' : 'none';
            });
        }
        
        // æœç´¢æ—¥å¿—
        function searchLogs() {
            filterLogs();
        }
        
        // ==================== å›¾è¡¨ç›¸å…³å‡½æ•° ====================
        
        // ä»·æ ¼æ ‡ç­¾æ’ä»¶
        const priceLabelsPlugin = {
            id: 'priceLabels',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                const datasets = chart.data.datasets;
                
                datasets.forEach((dataset, datasetIndex) => {
                    if (dataset.label && (dataset.label.startsWith('ä»·æ ¼:') || dataset.label.includes('ä¿¡å·:'))) {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        const data = dataset.data;
                        
                        data.forEach((point, index) => {
                            if (meta.data[index]) {
                                const element = meta.data[index];
                                const x = element.x;
                                const y = element.y;
                                
                                ctx.save();
                                
                                if (dataset.label.startsWith('ä»·æ ¼:')) {
                                    // ç»˜åˆ¶ä»·æ ¼æ ‡ç­¾
                                    const price = dataset.label.replace('ä»·æ ¼: ', '').split(' (')[0];
                                    const signalDesc = dataset.label.includes('(') ? 
                                        dataset.label.split('(')[1].replace(')', '') : '';
                                    
                                    // ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²æˆ–é»˜è®¤é¢œè‰²
                                    const labelBg = dataset.labelBg || 'rgba(0, 0, 0, 0.7)';
                                    const labelColor = dataset.labelColor || '#ffd700';
                                    
                                    // è®¡ç®—æ–‡æœ¬å®½åº¦
                                    ctx.font = 'bold 12px Arial';
                                    const priceWidth = ctx.measureText(price).width;
                                    const descWidth = signalDesc ? ctx.measureText(signalDesc).width : 0;
                                    const maxWidth = Math.max(priceWidth, descWidth);
                                    
                                    // ç»˜åˆ¶èƒŒæ™¯
                                    ctx.fillStyle = labelBg;
                                    ctx.fillRect(x - maxWidth/2 - 5, y - 25, maxWidth + 10, 20);
                                    
                                    // ç»˜åˆ¶ä»·æ ¼æ–‡æœ¬
                                    ctx.fillStyle = labelColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(price, x, y - 12);
                                    
                                    // ç»˜åˆ¶ä¿¡å·æè¿°ï¼ˆå¦‚æœæœ‰ï¼‰
                                    if (signalDesc) {
                                        ctx.font = '10px Arial';
                                        ctx.fillText(signalDesc, x, y - 2);
                                    }
                                } else if (dataset.label.includes('ä¿¡å·:')) {
                                    // ç»˜åˆ¶ä¿¡å·æè¿°
                                    const signalText = dataset.label.split('ä¿¡å·: ')[1];
                                    const isBuy = dataset.label.includes('ä¹°å…¥');
                                    const bgColor = isBuy ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                                    const textColor = '#ffffff';
                                    
                                    // è®¡ç®—æ–‡æœ¬å®½åº¦
                                    ctx.font = 'bold 10px Arial';
                                    const textWidth = ctx.measureText(signalText).width;
                                    
                                    // ç»˜åˆ¶èƒŒæ™¯
                                    ctx.fillStyle = bgColor;
                                    ctx.fillRect(x - textWidth/2 - 5, y - 25, textWidth + 10, 18);
                                    
                                    // ç»˜åˆ¶æ–‡æœ¬
                                    ctx.fillStyle = textColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(signalText, x, y - 12);
                                }
                                
                                ctx.restore();
                            }
                        });
                    }
                });
            }
        };
        
        // ç­‰å¾…Chart.jsåŠ è½½å®Œæˆååˆå§‹åŒ–
        let chartInitRetries = 0;
        const maxChartInitRetries = 50; // æœ€å¤šé‡è¯•50æ¬¡ï¼Œæ€»å…±5ç§’
        
        function waitForChartAndInit() {
            chartInitRetries++;
            console.log(`å°è¯•åˆå§‹åŒ–Chart.js (ç¬¬${chartInitRetries}æ¬¡)`);
            
            if (typeof Chart !== 'undefined') {
                console.log('Chart.jså·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–å›¾è¡¨');
                try {
        // æ³¨å†Œæ’ä»¶
        Chart.register(priceLabelsPlugin);
                    console.log('ä»·æ ¼æ ‡ç­¾æ’ä»¶æ³¨å†ŒæˆåŠŸ');
                    
                    // åˆå§‹åŒ–å›¾è¡¨
                    initChart();
                    console.log('å›¾è¡¨åˆå§‹åŒ–æˆåŠŸ');
                } catch (error) {
                    console.error('å›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', error);
                }
            } else {
                if (chartInitRetries < maxChartInitRetries) {
                    console.log(`Chart.jsæœªåŠ è½½ï¼Œ${100}msåé‡è¯•...`);
                    setTimeout(waitForChartAndInit, 100);
                } else {
                    console.error('Chart.jsåŠ è½½è¶…æ—¶ï¼Œå›¾è¡¨åŠŸèƒ½å°†ä¸å¯ç”¨');
                }
            }
        }
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const ctx = document.getElementById('emaChart').getContext('2d');
            
            emaChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false // ä½¿ç”¨è‡ªå®šä¹‰å›¾ä¾‹
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1
                        },
                        // æ·»åŠ ä»·æ ¼æ ‡ç­¾æ’ä»¶
                        priceLabels: {
                            enabled: true,
                            color: '#ffd700',
                            fontSize: 12,
                            fontWeight: 'bold',
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            padding: 4,
                            borderRadius: 4
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'MM-dd HH:mm'
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white'
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white',
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // è·å–å›¾è¡¨æ•°æ®ï¼ˆæ”¹ç”¨multi_timeframeåç«¯ç«¯ç‚¹ï¼‰
        async function getChartData(symbol, timeframe = '5m') {
            try {
                const resp = await fetch('/multi_timeframe/get_chart_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol, base_timeframe: timeframe, limit: 300 })
                });
                const data = await resp.json();
                if (!data.success) {
                    showStatus('è·å–å›¾è¡¨æ•°æ®å¤±è´¥: ' + (data.error || 'Unknown'), 'error');
                    return null;
                }
                return data;
            } catch (e) {
                console.error('è·å–å›¾è¡¨æ•°æ®å¼‚å¸¸:', e);
                showStatus('è·å–å›¾è¡¨æ•°æ®å¼‚å¸¸: ' + e.message, 'error');
                return null;
            }
        }

        // æ›´æ–°å›¾è¡¨
        function updateChart(data) {
            if (!emaChart || !data || !data.base_data) return;
            const baseData = data.base_data;
            const ema = data.ema || {};
            const labels = (baseData.timestamps || []).map(ts => new Date(ts));

            const colors = {
                price: '#ffffff',
                ema89: '#feca57',
                ema144: '#ff6b9d',
                ema233: '#ff9ff3',
                ema377: '#54a0ff'
            };

            const datasets = [];
            // ä»·æ ¼çº¿
            if (baseData.prices && baseData.prices.length) {
                datasets.push({
                    label: 'ä»·æ ¼',
                    data: baseData.prices.map((price, i) => ({ x: labels[i], y: price })),
                    borderColor: colors.price,
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
            }
            // EMAç³»åˆ—
            ['ema89','ema144','ema233','ema377'].forEach(key => {
                const series = ema[key] || [];
                if (series.length) {
                    datasets.push({
                        label: key.toUpperCase(),
                        data: series.map((v, i) => v == null ? null : ({ x: labels[i], y: v })),
                        borderColor: colors[key],
                        backgroundColor: colors[key] + '20',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1,
                        yAxisID: 'y'
                    });
                }
            });

            emaChart.data.labels = labels;
            emaChart.data.datasets = datasets;
            emaChart.update('none');
            updateChartLegend(datasets);
            // éšè—äº¤å‰ç‚¹é¢æ¿ï¼ˆå½“å‰æœªè®¡ç®—ï¼‰
            const panel = document.getElementById('crossPointsPanel');
            if (panel) panel.style.display = 'none';
        }
        
        // æ›´æ–°å›¾è¡¨å›¾ä¾‹
        function updateChartLegend(datasets) {
            const legendContainer = document.getElementById('chartLegend');
            let html = '';
            
            datasets.forEach(dataset => {
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${dataset.borderColor}"></div>
                        <span>${dataset.label}</span>
                    </div>
                `;
            });
            
            legendContainer.innerHTML = html;
        }
        
        // æ˜¾ç¤ºå›¾è¡¨
        function showChart(symbol) {
            currentChartSymbol = symbol;
            const chartSection = document.getElementById('chartSection');
            chartSection.style.display = 'block';
            
            // æ›´æ–°å¸ç§é€‰æ‹©å™¨
            const symbolSelect = document.getElementById('chartSymbolSelect');
            symbolSelect.value = symbol;
            
            // è·å–å›¾è¡¨æ•°æ®å¹¶æ›´æ–°
            getChartData(symbol, currentChartTimeframe).then(data => {
                if (data) {
                    updateChart(data);
                }
            });
        }
        
        // æ›´æ–°å›¾è¡¨å¸ç§
        function updateChartSymbol() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const symbol = symbolSelect.value;
            
            if (symbol) {
                currentChartSymbol = symbol;
                getChartData(symbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // æ›´æ–°å›¾è¡¨æ—¶é—´å‘¨æœŸ
        function updateChartTimeframe() {
            const timeframeSelect = document.getElementById('chartTimeframeSelect');
            const timeframe = timeframeSelect.value;
            
            if (currentChartSymbol) {
                currentChartTimeframe = timeframe;
                getChartData(currentChartSymbol, timeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // åˆ·æ–°å›¾è¡¨
        function refreshChart() {
            if (currentChartSymbol) {
                getChartData(currentChartSymbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©å¸ç§', 'error');
            }
        }
        
        // åˆ‡æ¢å›¾è¡¨æ˜¾ç¤º/éšè—
        function toggleChartVisibility() {
            const chartSection = document.getElementById('chartSection');
            if (chartSection.style.display === 'none') {
                chartSection.style.display = 'block';
                if (currentChartSymbol) {
                    refreshChart();
                }
            } else {
                chartSection.style.display = 'none';
            }
        }
        
        // åˆå§‹åŒ–å¸ç§é€‰æ‹©å™¨
        function initChartSymbolSelect() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const mainSymbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'];
            
            mainSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                symbolSelect.appendChild(option);
            });
        }
        
        // æ›´æ–°äº¤å‰ç‚¹ä½ä¿¡æ¯é¢æ¿
        function updateCrossPointsInfo(crossPoints) {
            const panel = document.getElementById('crossPointsPanel');
            const priceList = document.getElementById('priceCrossList');
            const indicatorList = document.getElementById('indicatorCrossList');
            
            if (!crossPoints || (!crossPoints.price_crosses.length && !crossPoints.indicator_crosses.length)) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            // æ›´æ–°ä»·æ ¼äº¤å‰ç‚¹åˆ—è¡¨
            priceList.innerHTML = '';
            if (crossPoints.price_crosses && crossPoints.price_crosses.length > 0) {
                crossPoints.price_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>ä»·æ ¼ Ã— ${cross.indicator}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    priceList.appendChild(item);
                });
            } else {
                priceList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">æš‚æ— ä»·æ ¼äº¤å‰ç‚¹</div>';
            }
            
            // æ›´æ–°å‡çº¿äº¤å‰ç‚¹åˆ—è¡¨
            indicatorList.innerHTML = '';
            if (crossPoints.indicator_crosses && crossPoints.indicator_crosses.length > 0) {
                crossPoints.indicator_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>${cross.indicator1} Ã— ${cross.indicator2}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    indicatorList.appendChild(item);
                });
            } else {
                indicatorList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">æš‚æ— å‡çº¿äº¤å‰ç‚¹</div>';
            }
        }
        
        // showCrossTabå‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰
        
        // åˆ†æå±€éƒ¨é¡¶åº•æ’åˆ—
        function analyzeLocalTopBottom(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000 // 1åˆ†é’Ÿå†…
                );
                
                if (crossIndex < 10 || crossIndex >= chartData.prices.length - 10) {
                    return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
                }
                
                // è·å–äº¤å‰ç‚¹å‰åçš„ä»·æ ¼æ•°æ®
                const beforePrices = chartData.prices.slice(Math.max(0, crossIndex - 10), crossIndex);
                const afterPrices = chartData.prices.slice(crossIndex, Math.min(chartData.prices.length, crossIndex + 10));
                const currentPrice = chartData.prices[crossIndex];
                
                // åˆ†æEMAæ’åˆ—
                const ema89 = chartData.ema89[crossIndex];
                const ema144 = chartData.ema144[crossIndex];
                const ema233 = chartData.ema233[crossIndex];
                const ema365 = chartData.ema365[crossIndex];
                
                // åˆ¤æ–­EMAæ’åˆ—
                const isBullishArrangement = ema89 > ema144 && ema144 > ema233 && ema233 > ema365;
                const isBearishArrangement = ema89 < ema144 && ema144 < ema233 && ema233 < ema365;
                
                // åˆ†æä»·æ ¼ä½ç½®
                const beforeMax = Math.max(...beforePrices.filter(p => p !== null));
                const beforeMin = Math.min(...beforePrices.filter(p => p !== null));
                const afterMax = Math.max(...afterPrices.filter(p => p !== null));
                const afterMin = Math.min(...afterPrices.filter(p => p !== null));
                
                // åˆ¤æ–­å±€éƒ¨é¡¶åº•
                let isLocalTop = false;
                let isLocalBottom = false;
                let confidence = 0;
                
                // å±€éƒ¨é¡¶éƒ¨åˆ¤æ–­ï¼šä»·æ ¼åœ¨äº¤å‰ç‚¹é™„è¿‘è¾¾åˆ°å±€éƒ¨é«˜ç‚¹ï¼Œä¸”EMAæ’åˆ—åç©º
                if (currentPrice >= beforeMax * 0.98 && currentPrice >= afterMax * 0.98) {
                    if (isBearishArrangement || ema89 < ema233) {
                        isLocalTop = true;
                        confidence = 0.8;
                    }
                }
                
                // å±€éƒ¨åº•éƒ¨åˆ¤æ–­ï¼šä»·æ ¼åœ¨äº¤å‰ç‚¹é™„è¿‘è¾¾åˆ°å±€éƒ¨ä½ç‚¹ï¼Œä¸”EMAæ’åˆ—åå¤š
                if (currentPrice <= beforeMin * 1.02 && currentPrice <= afterMin * 1.02) {
                    if (isBullishArrangement || ema89 > ema233) {
                        isLocalBottom = true;
                        confidence = 0.8;
                    }
                }
                
                return { isLocalTop, isLocalBottom, confidence, emaArrangement: isBullishArrangement ? 'bullish' : 'bearish' };
                
            } catch (error) {
                console.error('åˆ†æå±€éƒ¨é¡¶åº•å¤±è´¥:', error);
                return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
            }
        }
        
        // å¤„ç†é‡å çš„ä»·æ ¼æ ‡ç­¾
        function filterOverlappingPrices(crosses, chartData) {
            if (crosses.length === 0) return [];
            
            const filtered = [];
            const minDistance = 0.02; // æœ€å°è·ç¦»ï¼ˆ2%ï¼‰
            
            for (let i = 0; i < crosses.length; i++) {
                const current = crosses[i];
                let shouldAdd = true;
                
                // åˆ†æå±€éƒ¨é¡¶åº•
                const topBottomAnalysis = analyzeLocalTopBottom(current, chartData);
                
                // æ ¹æ®åˆ†æç»“æœè°ƒæ•´æ˜¾ç¤ºä»·æ ¼
                if (topBottomAnalysis.isLocalTop && topBottomAnalysis.confidence > 0.6) {
                    // å±€éƒ¨é¡¶éƒ¨ï¼šæ˜¾ç¤ºæœ€é«˜ä»·æ ¼ï¼Œé€‚åˆåšç©º
                    current.displayPrice = getLocalMaxPrice(current, chartData);
                    current.signalType = 'sell';
                    current.signalDescription = 'å±€éƒ¨é¡¶éƒ¨ï¼Œé€‚åˆåšç©º';
                } else if (topBottomAnalysis.isLocalBottom && topBottomAnalysis.confidence > 0.6) {
                    // å±€éƒ¨åº•éƒ¨ï¼šæ˜¾ç¤ºåŸä»·æ ¼ï¼Œé€‚åˆåšå¤š
                    current.displayPrice = current.price;
                    current.signalType = 'buy';
                    current.signalDescription = 'å±€éƒ¨åº•éƒ¨ï¼Œé€‚åˆåšå¤š';
                } else {
                    // ä¸­æ€§ï¼šæ˜¾ç¤ºåŸä»·æ ¼
                    current.displayPrice = current.price;
                    current.signalType = 'neutral';
                    current.signalDescription = 'ä¸­æ€§ä¿¡å·';
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å·²æ·»åŠ çš„ç‚¹å¤ªè¿‘
                for (let j = 0; j < filtered.length; j++) {
                    const existing = filtered[j];
                    const priceDiff = Math.abs(current.displayPrice - existing.displayPrice) / existing.displayPrice;
                    const timeDiff = Math.abs(new Date(current.timestamp) - new Date(existing.timestamp)) / (1000 * 60 * 60); // å°æ—¶
                    
                    // å¦‚æœä»·æ ¼å’Œæ—¶é—´éƒ½å¾ˆæ¥è¿‘ï¼Œåˆ™è·³è¿‡
                    if (priceDiff < minDistance && timeDiff < 24) {
                        shouldAdd = false;
                        break;
                    }
                }
                
                if (shouldAdd) {
                    filtered.push(current);
                }
            }
            
            return filtered;
        }
        
        // è·å–å±€éƒ¨æœ€é«˜ä»·æ ¼
        function getLocalMaxPrice(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000
                );
                
                if (crossIndex < 5 || crossIndex >= chartData.prices.length - 5) {
                    return cross.price;
                }
                
                // è·å–äº¤å‰ç‚¹å‰å10ä¸ªç‚¹çš„ä»·æ ¼
                const startIndex = Math.max(0, crossIndex - 10);
                const endIndex = Math.min(chartData.prices.length, crossIndex + 10);
                const localPrices = chartData.prices.slice(startIndex, endIndex).filter(p => p !== null);
                
                return Math.max(...localPrices);
            } catch (error) {
                console.error('è·å–å±€éƒ¨æœ€é«˜ä»·æ ¼å¤±è´¥:', error);
                return cross.price;
            }
        }
        
        // ç”Ÿæˆä¹°å–ä¿¡å·
        function generateTradingSignals(crossPoints) {
            const signals = [];
            
            if (!crossPoints || !crossPoints.indicator_crosses) {
                return signals;
            }
            
            // åˆ†æEMAæ’åˆ—å’Œäº¤å‰ç‚¹
            const emaCrosses = crossPoints.indicator_crosses.filter(cross => 
                cross.indicator1.includes('EMA') && cross.indicator2.includes('EMA')
            );
            
            // æŒ‰æ—¶é—´æ’åº
            emaCrosses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // åˆ†ææ¯ä¸ªäº¤å‰ç‚¹
            emaCrosses.forEach(cross => {
                const { indicator1, indicator2, type, timestamp, price } = cross;
                
                // ä¹°å…¥ä¿¡å·æ¡ä»¶
                if (isBuySignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'buy');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'buy',
                        description: getBuySignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
                
                // å–å‡ºä¿¡å·æ¡ä»¶
                if (isSellSignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'sell');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'sell',
                        description: getSellSignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
            });
            
            return signals;
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºä¹°å…¥ä¿¡å·
        function isBuySignal(indicator1, indicator2, type, crossPoints) {
            // æ¡ä»¶1ï¼šEMA89çªç ´EMA144/233/365ï¼Œå½¢æˆå¤šå¤´æ’åˆ—
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'golden_cross') {
                    return true; // EMA89ä¸Šç©¿å…¶ä»–EMA
                }
            }
            
            // æ¡ä»¶2ï¼šå¸‚åœºå›è°ƒè‡³EMA233æˆ–EMA144ï¼Œæ”¯æ’‘åå¼¹
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === 'ä»·æ ¼') {
                if (type === 'golden_cross') {
                    return true; // ä»·æ ¼ä»ä¸‹æ–¹çªç ´EMAæ”¯æ’‘ä½
                }
            }
            
            return false;
        }
        
        // æ£€æŸ¥æˆäº¤é‡ç¡®è®¤
        function checkVolumeConfirmation(cross, signalType) {
            if (cross.volume_confirmation) {
                const volConf = cross.volume_confirmation;
                if (signalType === 'buy') {
                    // ä¹°å…¥ä¿¡å·éœ€è¦æˆäº¤é‡å¢åŠ ç¡®è®¤
                    return volConf.confirmed && volConf.volume_ratio > 1.2;
                } else {
                    // å–å‡ºä¿¡å·æˆäº¤é‡å˜åŒ–ç¡®è®¤
                    return volConf.confirmed && (volConf.volume_ratio > 1.1 || volConf.volume_ratio < 0.8);
                }
            }
            return false; // æ²¡æœ‰æˆäº¤é‡æ•°æ®æ—¶é»˜è®¤ä¸ç¡®è®¤
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºå–å‡ºä¿¡å·
        function isSellSignal(indicator1, indicator2, type, crossPoints) {
            // æ¡ä»¶1ï¼šEMA89è·Œç ´EMA144/233/365ï¼Œå½¢æˆç©ºå¤´æ’åˆ—
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'death_cross') {
                    return true; // EMA89ä¸‹ç©¿å…¶ä»–EMA
                }
            }
            
            // æ¡ä»¶2ï¼šå¸‚åœºå›è°ƒè‡³EMA233æˆ–EMA144ï¼Œæœªçªç ´ï¼Œå½¢æˆä¸‹è¡Œå‹åŠ›
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === 'ä»·æ ¼') {
                if (type === 'death_cross') {
                    return true; // ä»·æ ¼ä»ä¸Šæ–¹è·Œç ´EMAé˜»åŠ›ä½
                }
            }
            
            return false;
        }
        
        // è·å–ä¹°å…¥ä¿¡å·æè¿°
        function getBuySignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89çªç ´${indicator2}ï¼Œå¤šå¤´æ’åˆ—å½¢æˆ`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `ä»·æ ¼çªç ´${indicator1}æ”¯æ’‘ä½ï¼Œåå¼¹ä¿¡å·`;
            }
            return 'ä¹°å…¥ä¿¡å·';
        }
        
        // è·å–å–å‡ºä¿¡å·æè¿°
        function getSellSignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89è·Œç ´${indicator2}ï¼Œç©ºå¤´æ’åˆ—å½¢æˆ`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `ä»·æ ¼è·Œç ´${indicator1}é˜»åŠ›ä½ï¼Œä¸‹è¡Œå‹åŠ›`;
            }
            return 'å–å‡ºä¿¡å·';
        }

        // å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥ç›¸å…³å˜é‡
        let allMultiTimeframeSignals = [];
        
        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('unhandledrejection', function(event) {
            const reason = event && event.reason;
            const msg = String((reason && (reason.message || reason)) || '');
            if (!msg || /(qk-content\.js|lockdown-install\.js|SES_UNCAUGHT_EXCEPTION)/.test(msg)) {
                return; // å¿½ç•¥ç¬¬ä¸‰æ–¹è„šæœ¬/ç©ºé”™è¯¯
            }
            console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', reason);
            showStatus(`ç³»ç»Ÿé”™è¯¯: ${msg}`, 'error');
            event.preventDefault(); // é˜»æ­¢é»˜è®¤çš„é”™è¯¯å¤„ç†
        });
        
        window.addEventListener('error', function(event) {
            const src = String((event && (event.filename || (event.error && event.error.stack) || '')) || '');
            const msg = String((event && (event.message || (event.error && event.error.message))) || '');
            if (!msg || /(qk-content\.js|lockdown-install\.js|SES_UNCAUGHT_EXCEPTION)/.test(src + ' ' + msg)) {
                return; // å¿½ç•¥ç¬¬ä¸‰æ–¹è„šæœ¬/ç©ºé”™è¯¯
            }
            console.error('JavaScripté”™è¯¯:', event.error || msg);
            if (msg) {
                showStatus(`JavaScripté”™è¯¯: ${msg}`, 'error');
            }
        });

        // analyzeMultiTimeframeSymbolså‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰

        // åˆ†æå¤šä¸ªå¸ç§çš„å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥
        async function analyzeMultipleMultiTimeframeSymbols(symbols, strategyType = 'original') {
            try {
                showStatus(`å¼€å§‹åˆ†æ ${symbols.length} ä¸ªå¸ç§çš„å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥ (ç­–ç•¥: ${strategyType === 'original' ? 'åŸç­–ç•¥' : 'ä¿®æ”¹ç­–ç•¥'})...`, 'info');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2åˆ†é’Ÿè¶…æ—¶
                
                const response = await fetch('/multi_timeframe/analyze_multiple_symbols', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        symbols: symbols,
                        strategy_type: strategyType
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // ä½¿ç”¨æ–°çš„ä¿¡å·æ ¼å¼
                    const allSignals = data.signals || [];
                    
                    console.log('å¤šæ—¶é—´æ¡†æ¶åˆ†æç»“æœ:', data);
                    console.log('ä¿¡å·æ•°æ®:', allSignals);
                    console.log('ä¿¡å·æ•°é‡:', allSignals.length);
                    
                    allMultiTimeframeSignals = allSignals;
                    showMultiTimeframeSignals(allSignals, 0); // é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰ä¿¡å·
                    showStatus(`åˆ†æå®Œæˆ: æ€»è®¡${data.total_signals}ä¸ªä¿¡å·ï¼ŒæˆåŠŸ${data.successful_signals}ä¸ª`, 'success');
                } else {
                    showStatus(`åˆ†æå¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`åˆ†æå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ†æè‡ªå®šä¹‰å¸ç§çš„å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥
        async function analyzeCustomMultiTimeframeSymbols() {
            const symbolInput = document.getElementById('multiTimeframeSymbolInput').value.trim();
            if (!symbolInput) {
                showStatus('è¯·è¾“å…¥è¦åˆ†æçš„å¸ç§', 'warning');
                return;
            }
            
            const symbols = symbolInput.split(',').map(s => s.trim().toUpperCase());
            
            try {
                const strategyType = document.getElementById('strategyTypeSelect').value;
                showStatus(`å¼€å§‹åˆ†æè‡ªå®šä¹‰å¸ç§: ${symbols.join(', ')} (ç­–ç•¥: ${strategyType === 'original' ? 'åŸç­–ç•¥' : 'ä¿®æ”¹ç­–ç•¥'})`, 'info');
                await analyzeMultipleMultiTimeframeSymbols(symbols, strategyType);
            } catch (error) {
                showStatus(`åˆ†æå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // getMultiTimeframeTopSymbolså‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰

        // æ¸…é™¤EMAä½¿ç”¨è®°å½•
        async function clearMultiTimeframeCache() {
            try {
                const response = await fetch('/multi_timeframe/clear_ema_usage', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    showStatus('EMAä½¿ç”¨è®°å½•å·²æ¸…é™¤', 'success');
                } else {
                    showStatus(`æ¸…é™¤å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`æ¸…é™¤å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // éªŒè¯å¸ç§
        async function validateMultiTimeframeSymbol() {
            const symbolInput = document.getElementById('multiTimeframeSymbolInput').value.trim();
            if (!symbolInput) {
                showStatus('è¯·è¾“å…¥è¦éªŒè¯çš„å¸ç§', 'warning');
                return;
            }
            
            const symbol = symbolInput.split(',')[0].trim().toUpperCase(); // åªéªŒè¯ç¬¬ä¸€ä¸ªå¸ç§
            
            try {
                showStatus(`æ­£åœ¨éªŒè¯å¸ç§: ${symbol}...`, 'info');
                
                const response = await fetch('/multi_timeframe/validate_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (data.is_valid) {
                        showStatus(`âœ… ${data.symbol} éªŒè¯é€šè¿‡ï¼Œå¯ä»¥æ­£å¸¸äº¤æ˜“`, 'success');
                    } else {
                        showStatus(`âŒ ${data.symbol} éªŒè¯å¤±è´¥ï¼Œè¯¥å¸ç§ä¸å­˜åœ¨æˆ–æ— æ³•è·å–æ•°æ®`, 'error');
                    }
                } else {
                    showStatus(`éªŒè¯å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`éªŒè¯å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ã€å·²é‡æ„ã€‘ç»Ÿä¸€çš„å¤šæ—¶é—´æ¡†æ¶ä¿¡å·æ˜¾ç¤º
        function showMultiTimeframeSignals(signals, minProfit = 0) {
            console.log('showMultiTimeframeSignals è¢«è°ƒç”¨ - ä½¿ç”¨ç»Ÿä¸€åˆ†é¡µç³»ç»Ÿ');
            console.log('ä¼ å…¥çš„ä¿¡å·æ•°æ®:', signals);
            console.log('ä¿¡å·æ•°é‡:', signals ? signals.length : 0);
            
            // å¦‚æœæœ‰ä¿¡å·æ•°æ®ï¼Œæ›´æ–°ç¼“å­˜ï¼ˆè¿™é€šå¸¸åœ¨é¦–æ¬¡åŠ è½½æ—¶å‘ç”Ÿï¼‰
            if (signals && signals.length > 0) {
                // è¿‡æ»¤ä¿¡å·
                let filteredSignals = signals;
                if (minProfit > 0) {
                    filteredSignals = signals.filter(signal => signal.profit_pct >= minProfit);
                }
                
                console.log('è¿‡æ»¤åçš„ä¿¡å·æ•°é‡:', filteredSignals.length);
                
                // æ›´æ–°ç¼“å­˜
                allCachedSignals = filteredSignals;
                
                // é‡æ–°è®¡ç®—æ€»é¡µæ•°  
                const signalsPerPage = 50;
                totalPages = Math.ceil(allCachedSignals.length / signalsPerPage);
                currentPage = 1; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                
                // æ›´æ–°åˆ†é¡µæ§ä»¶å¹¶æ˜¾ç¤ºç¬¬ä¸€é¡µ
                updatePaginationControls();
                displayCurrentPageSignals(signalsPerPage);
            } else {
                // æ²¡æœ‰ä¿¡å·ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
                updateSignalDisplay([]);
            }
        }
        
        // ã€å·²åºŸå¼ƒã€‘æ—§çš„ä¿¡å·é¡µé¢æ˜¾ç¤ºå‡½æ•°ï¼Œä¿ç•™ä»¥é¿å…è°ƒç”¨é”™è¯¯
        function displaySignalPage(filteredSignals, page, totalPages) {
            const tbody = document.getElementById('multiTimeframeSignalsTableBody');
            if (!tbody) return;
            
            if (filteredSignals.length === 0) {
                const filterText = document.getElementById('multiTimeframeProfitFilter')?.value === '0' ? 'æš‚æ— å¤šæ—¶é—´æ¡†æ¶äº¤æ˜“ä¿¡å·' : `æš‚æ— æ”¶ç›Šç‡${document.getElementById('multiTimeframeProfitFilter')?.value}%åŠä»¥ä¸Šçš„å¤šæ—¶é—´æ¡†æ¶äº¤æ˜“ä¿¡å·`;
                tbody.innerHTML = `<tr><td colspan="10" style="text-align: center; color: #666;">${filterText}</td></tr>`;
                return;
            }
            
            // è®¡ç®—å½“å‰é¡µçš„ä¿¡å·èŒƒå›´
            const startIndex = (page - 1) * signalsPerPage;
            const endIndex = startIndex + signalsPerPage;
            const pageSignals = filteredSignals.slice(startIndex, endIndex);
            
            console.log(`æ˜¾ç¤ºç¬¬${page}é¡µä¿¡å·: ${startIndex}-${endIndex}, å…±${pageSignals.length}ä¸ªä¿¡å·`);
            
            let html = '';
            pageSignals.forEach(signal => {
                let signalTypeClass = 'warning';
                let signalTypeText = signal.signal_type;
                
                if (signal.signal_type === 'long') {
                    signalTypeClass = 'success';
                    signalTypeText = 'åšå¤š';
                } else if (signal.signal_type === 'short') {
                    signalTypeClass = 'danger';
                    signalTypeText = 'åšç©º';
                }
                
                let profitClass = 'text-success';
                if (signal.profit_pct < 0.5) {
                    profitClass = 'text-warning';
                } else if (signal.profit_pct < 0.2) {
                    profitClass = 'text-danger';
                }
                
                html += `
                    <tr>
                        <td><strong>${signal.symbol}</strong></td>
                        <td><span class="badge badge-info">${signal.timeframe}</span></td>
                        <td>${signal.trend}</td>
                        <td><span class="badge badge-secondary">${signal.ema_period ? 'EMA' + signal.ema_period : signal.signal_data?.type || 'N/A'}</span></td>
                        <td><strong>${signal.entry_price}</strong></td>
                        <td><strong>${signal.take_profit || 'N/A'}</strong></td>
                        <td class="${profitClass}"><strong>${signal.profit_pct}%</strong></td>
                        <td><span class="status-${signalTypeClass}">${signalTypeText}</span></td>
                        <td><small>${signal.signal_time || 'N/A'}</small></td>
                        <td>
                            <button class="btn btn-sm btn-info" onclick="showSignalDetails('${signal.symbol}', '${signal.timeframe}', '${signal.condition || 'N/A'}', '${signal.description || 'N/A'}')">è¯¦æƒ…</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const totalCount = filteredSignals.length;
            const filterText = document.getElementById('multiTimeframeProfitFilter')?.value === '0' ? 'æ˜¾ç¤ºå…¨éƒ¨' : `æ”¶ç›Šç‡â‰¥${document.getElementById('multiTimeframeProfitFilter')?.value}%`;
            showStatus(`å¤šæ—¶é—´æ¡†æ¶ä¿¡å·: ç¬¬${page}é¡µï¼Œå…±${totalPages}é¡µ (${pageSignals.length}ä¸ªä¿¡å·) - ${filterText}`, 'success');
        }

        // åˆ†é¡µç›¸å…³å˜é‡
        let currentPage = 1;
        let currentPageSize = 20;  // æ”¹ä¸º20ä¸ªä¿¡å·æ¯é¡µ
        let totalPages = 1;
        let allSymbols = [];
        let currentSymbols = [];
        let allSignals = [];  // å­˜å‚¨æ‰€æœ‰ä¿¡å·
        let currentSignalPage = 1;  // å½“å‰ä¿¡å·é¡µ
        let signalsPerPage = 20;  // æ¯é¡µä¿¡å·æ•°é‡
        
        // æ›´æ–°ä¿¡å·åˆ†é¡µæ§åˆ¶
        function updateSignalPagination(totalPages) {
            const paginationControls = document.getElementById('paginationControls');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (paginationControls) {
                paginationControls.style.display = 'block';
            }
            
            if (pageInfo) {
                pageInfo.textContent = `ç¬¬${currentSignalPage}é¡µï¼Œå…±${totalPages}é¡µ (ä¿¡å·åˆ†é¡µ)`;
            }
            
            if (prevBtn) {
                prevBtn.disabled = currentSignalPage <= 1;
            }
            
            if (nextBtn) {
                nextBtn.disabled = currentSignalPage >= totalPages;
            }
        }
        
        // ä¿¡å·ç¿»é¡µå‡½æ•°
        function previousSignalPage() {
            if (currentSignalPage > 1) {
                currentSignalPage--;
                // é‡æ–°æ˜¾ç¤ºå½“å‰é¡µçš„ä¿¡å·
                const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter')?.value || 0);
                let filteredSignals = allSignals;
                if (minProfit > 0) {
                    filteredSignals = allSignals.filter(signal => signal.profit_pct >= minProfit);
                }
                const totalSignalPages = Math.ceil(filteredSignals.length / signalsPerPage);
                displaySignalPage(filteredSignals, currentSignalPage, totalSignalPages);
                updateSignalPagination(totalSignalPages);
            }
        }
        
        function nextSignalPage() {
            const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter')?.value || 0);
            let filteredSignals = allSignals;
            if (minProfit > 0) {
                filteredSignals = allSignals.filter(signal => signal.profit_pct >= minProfit);
            }
            const totalSignalPages = Math.ceil(filteredSignals.length / signalsPerPage);
            
            if (currentSignalPage < totalSignalPages) {
                currentSignalPage++;
                displaySignalPage(filteredSignals, currentSignalPage, totalSignalPages);
                updateSignalPagination(totalSignalPages);
            }
        }

        // åº”ç”¨å¤šæ—¶é—´æ¡†æ¶è¿‡æ»¤
        function applyMultiTimeframeFilter() {
            const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter').value);
            showMultiTimeframeSignals(allMultiTimeframeSignals, minProfit);
        }

        // æ›´æ”¹é¡µé¢å¤§å°
        function changePageSize() {
            // ã€å·²ä¿®å¤ã€‘ç°åœ¨ä¸éœ€è¦æ”¹å˜é¡µé¢å¤§å°ï¼Œå› ä¸ºæˆ‘ä»¬æŒ‰ä¿¡å·åˆ†é¡µ
            // å¦‚æœéœ€è¦é‡æ–°åˆ†æï¼Œå¯ä»¥æ¸…é™¤ç¼“å­˜
            showStatus('æ¯é¡µä¿¡å·æ•°é‡ç°åœ¨å›ºå®šä¸º50ä¸ª', 'info');
        }

        // ä¸Šä¸€é¡µä¿¡å·
        function previousSignalPage() {
            console.log(`previousSignalPage è¢«è°ƒç”¨: currentPage=${currentPage}, totalPages=${totalPages}`);
            
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('æ²¡æœ‰å¯æ˜¾ç¤ºçš„ä¿¡å·æ•°æ®', 'warning');
                return;
            }
            
            if (currentPage > 1) {
                currentPage--;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
            } else {
                showStatus('å·²ç»æ˜¯ç¬¬ä¸€é¡µäº†', 'info');
            }
        }

        // ä¸‹ä¸€é¡µä¿¡å·
        function nextSignalPage() {
            console.log(`nextSignalPage è¢«è°ƒç”¨: currentPage=${currentPage}, totalPages=${totalPages}, allCachedSignals.length=${allCachedSignals.length}`);
            
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('æ²¡æœ‰å¯æ˜¾ç¤ºçš„ä¿¡å·æ•°æ®', 'warning');
                return;
            }
            
            if (currentPage < totalPages) {
                currentPage++;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`åˆ‡æ¢åˆ°ç¬¬${currentPage}é¡µ`, 'success');
            } else {
                showStatus('å·²ç»æ˜¯æœ€åä¸€é¡µäº†', 'info');
            }
        }

        // å¯¼å‡ºå…¨éƒ¨ä¿¡å·åˆ°CSV
        function exportAllSignalsToCSV() {
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®', 'warning');
                return;
            }
            
            try {
                showStatus('æ­£åœ¨ç”ŸæˆCSVæ–‡ä»¶...', 'info');
                
                // CSVè¡¨å¤´
                const headers = ['å¸ç§', 'æ—¶é—´æ¡†æ¶', 'ä¿¡å·æè¿°', 'å…¥åœºä»·æ ¼', 'æ­¢ç›ˆä»·æ ¼', 'æ½œåœ¨æ”¶ç›Šç‡', 'ä¿¡å·æ•°é‡', 'åˆ†ææ—¶é—´'];
                
                // æ„å»ºCSVå†…å®¹
                let csvContent = headers.join(',') + '\n';
                
                allCachedSignals.forEach(signal => {
                    const row = [
                        signal.symbol || '',
                        signal.timeframe || '',
                        `"${(signal.description || '').replace(/"/g, '""')}"`, // è½¬ä¹‰å¼•å·
                        signal.entry_price || '',
                        signal.take_profit_price || '',
                        signal.potential_profit ? `${(signal.potential_profit * 100).toFixed(2)}%` : '',
                        signal.signal_count || 0,
                        signal.timestamp || new Date().toLocaleString('zh-CN')
                    ];
                    csvContent += row.join(',') + '\n';
                });
                
                // åˆ›å»ºBlobå¹¶ä¸‹è½½
                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `multi_timeframe_signals_${timestamp}.csv`;
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`æˆåŠŸå¯¼å‡º ${allCachedSignals.length} æ¡ä¿¡å·æ•°æ®åˆ° ${filename}`, 'success');
                
            } catch (error) {
                console.error('å¯¼å‡ºCSVå¤±è´¥:', error);
                showStatus(`å¯¼å‡ºå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¯¼å‡ºå¸ç§åˆ†æç»“æœåˆ°CSV
        function exportAnalysisResultsToCSV() {
            const dataToExport = filteredResults.length > 0 ? filteredResults : currentResults;
            
            if (!dataToExport || dataToExport.length === 0) {
                showStatus('æ²¡æœ‰å¯å¯¼å‡ºçš„åˆ†ææ•°æ®ï¼Œè¯·å…ˆè¿è¡Œåˆ†æ', 'warning');
                return;
            }
            
            try {
                showStatus('æ­£åœ¨ç”ŸæˆCSVæ–‡ä»¶...', 'info');
                
                // CSVè¡¨å¤´
                const headers = ['å¸ç§', 'å½“å‰ä»·æ ¼', 'æŒ‚å•ä»·æ ¼', 'æ—¶é—´çº§åˆ«', 'EMA89', 'EMA144', 'EMA233', 'EMA365', 'å¸ƒæ—ä¸Šè½¨', 'å¸ƒæ—ä¸­è½¨', 'å¸ƒæ—ä¸‹è½¨', 'æœ€åæ›´æ–°æ—¶é—´'];
                
                // æ„å»ºCSVå†…å®¹
                let csvContent = headers.join(',') + '\n';
                
                dataToExport.forEach(result => {
                    const row = [
                        result.symbol || '',
                        result.current_price || '',
                        result.order_price || '',
                        result.timeframe || '',
                        result.ema89 || '',
                        result.ema144 || '',
                        result.ema233 || '',
                        result.ema365 || '',
                        result.bb_upper || '',
                        result.bb_middle || '',
                        result.bb_lower || '',
                        result.last_updated || new Date().toLocaleString('zh-CN')
                    ];
                    csvContent += row.join(',') + '\n';
                });
                
                // åˆ›å»ºBlobå¹¶ä¸‹è½½
                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `analysis_results_${timestamp}.csv`;
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`æˆåŠŸå¯¼å‡º ${dataToExport.length} æ¡åˆ†æç»“æœåˆ° ${filename}`, 'success');
                
            } catch (error) {
                console.error('å¯¼å‡ºCSVå¤±è´¥:', error);
                showStatus(`å¯¼å‡ºå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // analyzeCurrentPageå‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰

        // updatePaginationControlså‡½æ•°å·²ç§»åˆ°HTMLå‰é¢å®šä¹‰

        // æ˜¾ç¤ºå¤šæ—¶é—´æ¡†æ¶è¯¦æƒ…
        async function showMultiTimeframeDetails(symbol, timeframe) {
            try {
                const response = await fetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const result = data.results.find(r => r.timeframe === timeframe);
                    if (result) {
                        showMultiTimeframeDetailsModal(result);
                    } else {
                        showStatus(`æœªæ‰¾åˆ°${symbol} ${timeframe}çš„è¯¦æƒ…`, 'warning');
                    }
                } else {
                    showStatus(`è·å–è¯¦æƒ…å¤±è´¥: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`è·å–è¯¦æƒ…å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºå¤šæ—¶é—´æ¡†æ¶è¯¦æƒ…æ¨¡æ€æ¡†
        function showMultiTimeframeDetailsModal(signal) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h3>å¤šæ—¶é—´æ¡†æ¶ç­–ç•¥è¯¦æƒ… - ${signal.symbol}</h3>
                    <div class="signal-details">
                        <div class="details-grid">
                            <div class="detail-item">
                                <label>æ—¶é—´æ¡†æ¶:</label>
                                <span>${signal.timeframe}</span>
                            </div>
                            <div class="detail-item">
                                <label>è¶‹åŠ¿æ–¹å‘:</label>
                                <span>${signal.trend}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMAçº§åˆ«:</label>
                                <span>EMA${signal.ema_period}</span>
                            </div>
                            <div class="detail-item">
                                <label>ä¿¡å·ç±»å‹:</label>
                                <span>${signal.signal_type === 'long' ? 'åšå¤š' : 'åšç©º'}</span>
                            </div>
                            <div class="detail-item">
                                <label>å…¥åœºä»·æ ¼:</label>
                                <span>${signal.entry_price}</span>
                            </div>
                            <div class="detail-item">
                                <label>æ­¢ç›ˆä»·æ ¼:</label>
                                <span>${signal.take_profit}</span>
                            </div>
                            <div class="detail-item">
                                <label>é¢„æœŸæ”¶ç›Šç‡:</label>
                                <span>${signal.profit_pct}%</span>
                            </div>
                            <div class="detail-item">
                                <label>å½“å‰ä»·æ ¼:</label>
                                <span>${signal.current_price}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMA144:</label>
                                <span>${signal.ema144}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMA233:</label>
                                <span>${signal.ema233}</span>
                            </div>
                            <div class="detail-item">
                                <label>ä¿¡å·æ—¶é—´:</label>
                                <span>${signal.signal_time}</span>
                            </div>
                        </div>
                        
                        <div class="strategy-explanation">
                            <h6>ç­–ç•¥è¯´æ˜</h6>
                            <p><strong>è¶‹åŠ¿åˆ¤æ–­:</strong> ${signal.trend}</p>
                            <p><strong>å…¥åœºæ¡ä»¶:</strong> ä»·æ ¼å›è¸©EMA${signal.ema_period}</p>
                            <p><strong>æ­¢ç›ˆè®¾ç½®:</strong> ä½¿ç”¨${signal.timeframe}å¯¹åº”æ—¶é—´æ¡†æ¶çš„å¸ƒæ—ä¸­è½¨</p>
                            <p><strong>é£é™©æ§åˆ¶:</strong> æ¯ä¸ªEMAçº§åˆ«åªç”¨ä¸€æ¬¡ï¼Œé¿å…é‡å¤ä¿¡å·</p>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // ==================== çƒ­ç‚¹å¸ç§åˆ†æåŠŸèƒ½ ====================
        
        // åˆå§‹åŒ–é»˜è®¤æ—¥æœŸ
        (function initDefaultDates() {
            // è®¾ç½®ç»“æŸæ—¥æœŸä¸ºä»Šå¤©
            const today = new Date().toISOString().split('T')[0];
            const endDateInput = document.getElementById('advEndDate');
            if (endDateInput) {
                endDateInput.value = today;
            }
        })();
        
        let hotCoinsData = null;
        
        // åˆ†æçƒ­ç‚¹å¸ç§
        async function analyzeHotCoins() {
            try {
                showStatus('æ­£åœ¨åˆ†æ350ä¸ªå¸ç§ï¼Œè¯·è€å¿ƒç­‰å¾…...', 'info');
                
                // æ˜¾ç¤ºè¿›åº¦æ¡
                document.getElementById('hotCoinsProgress').style.display = 'block';
                document.getElementById('hotCoinsProgressText').textContent = 'åˆ†æä¸­...';
                document.getElementById('hotCoinsProgressBar').style.width = '50%';
                
                // éšè—ä¹‹å‰çš„ç»“æœ
                document.getElementById('hotCoinsSummary').style.display = 'none';
                document.getElementById('hotCoinsTabsContainer').style.display = 'none';
                
                const response = await safeFetch('/crypto_analysis/analyze');
                const result = await response.json();
                
                if (result.success) {
                    hotCoinsData = result.data;
                    
                    // æ›´æ–°è¿›åº¦æ¡
                    document.getElementById('hotCoinsProgressBar').style.width = '100%';
                    document.getElementById('hotCoinsProgressText').textContent = 'åˆ†æå®Œæˆï¼';
                    
                    // æ˜¾ç¤ºç»“æœ
                    displayHotCoinsResults(hotCoinsData);
                    
                    showStatus(`âœ… åˆ†æå®Œæˆï¼æˆåŠŸåˆ†æ ${hotCoinsData.summary.successful_coins}/${hotCoinsData.summary.total_coins} ä¸ªå¸ç§`, 'success');
                    
                    // éšè—è¿›åº¦æ¡
                    setTimeout(() => {
                        document.getElementById('hotCoinsProgress').style.display = 'none';
                    }, 2000);
                } else {
                    showStatus(`åˆ†æå¤±è´¥: ${result.error}`, 'error');
                    document.getElementById('hotCoinsProgress').style.display = 'none';
                }
            } catch (error) {
                console.error('åˆ†æå¤±è´¥:', error);
                showStatus(`åˆ†æå¤±è´¥: ${error.message}`, 'error');
                document.getElementById('hotCoinsProgress').style.display = 'none';
            }
        }
        
        // æ˜¾ç¤ºå¸ç§åˆ—è¡¨
        async function showHotCoinsSymbols() {
            try {
                const response = await safeFetch('/crypto_analysis/get_symbols');
                const result = await response.json();
                
                if (result.success) {
                    let html = '<div style="background: #2b2b2b; padding: 20px; border-radius: 8px; border: 1px solid #444;">';
                    html += `<h4 style="color: #e0e0e0;">ğŸ“‹ åˆ†æå¸ç§åˆ—è¡¨ï¼ˆå…± ${result.count} ä¸ªï¼‰</h4>`;
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px;">';
                    
                    result.symbols.forEach(symbol => {
                        html += `<div style="background: #1a1a1a; padding: 8px; border-radius: 4px; text-align: center; border: 1px solid #555; color: #e0e0e0;">${symbol}</div>`;
                    });
                    
                    html += '</div></div>';
                    
                    document.getElementById('hotCoinsResults').innerHTML = html;
                    showStatus(`âœ… å·²åŠ è½½ ${result.count} ä¸ªå¸ç§`, 'success');
                } else {
                    showStatus(`è·å–å¸ç§åˆ—è¡¨å¤±è´¥: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('è·å–å¸ç§åˆ—è¡¨å¤±è´¥:', error);
                showStatus(`è·å–å¸ç§åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æ˜¾ç¤ºåˆ†æç»“æœ
        function displayHotCoinsResults(data) {
            // æ˜¾ç¤ºæ¦‚è§ˆ
            document.getElementById('hotCoinsSummary').style.display = 'block';
            document.getElementById('totalCoins').textContent = data.summary.total_coins;
            document.getElementById('successCoins').textContent = data.summary.successful_coins;
            document.getElementById('positiveCoins').textContent = data.summary.positive_coins;
            
            if (data.statistics) {
                document.getElementById('avgChange').textContent = data.statistics.avg_change.toFixed(2) + '%';
                document.getElementById('maxGain').textContent = '+' + data.statistics.max_gain.toFixed(2) + '%';
                document.getElementById('maxLoss').textContent = data.statistics.max_loss.toFixed(2) + '%';
            }
            
            // æ˜¾ç¤ºTabå®¹å™¨
            document.getElementById('hotCoinsTabsContainer').style.display = 'block';
            
            // æ¸²æŸ“å„ä¸ªTabå†…å®¹
            renderGainersTab(data.top_gainers);
            renderLosersTab(data.top_losers);
            renderVolumeTab(data.top_volume);
            renderDistributionTab(data.distribution);
            renderAllCoinsTab(data.all_coins);
        }
        
        // æ¸²æŸ“æ¶¨å¹…æ¦œ
        function renderGainersTab(gainers) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">æ’å</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å¸ç§</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæ¶¨è·Œ</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å½“å‰ä»·æ ¼</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€é«˜</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€ä½</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">äº¤æ˜“é‡</th>';
            html += '</tr></thead><tbody>';
            
            gainers.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('gainersContent').innerHTML = html;
        }
        
        // æ¸²æŸ“è·Œå¹…æ¦œ
        function renderLosersTab(losers) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">æ’å</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å¸ç§</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæ¶¨è·Œ</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å½“å‰ä»·æ ¼</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€é«˜</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€ä½</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">äº¤æ˜“é‡</th>';
            html += '</tr></thead><tbody>';
            
            losers.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('losersContent').innerHTML = html;
        }
        
        // æ¸²æŸ“äº¤æ˜“é‡æ¦œ
        function renderVolumeTab(volumes) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">æ’å</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å¸ç§</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">äº¤æ˜“é‡</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæ¶¨è·Œ</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å½“å‰ä»·æ ¼</th>';
            html += '</tr></thead><tbody>';
            
            volumes.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('volumeContent').innerHTML = html;
        }
        
        // æ¸²æŸ“æ¶¨è·Œåˆ†å¸ƒ
        function renderDistributionTab(distribution) {
            let html = '<div style="background: #2b2b2b; padding: 20px; border-radius: 8px; border: 1px solid #444;">';
            
            const categories = [
                { label: 'æ¶¨å¹… â‰¥10%', value: distribution.up_10_plus, color: '#28a745' },
                { label: 'æ¶¨å¹… 5%-10%', value: distribution.up_5_10, color: '#20c997' },
                { label: 'æ¶¨å¹… 0%-5%', value: distribution.up_0_5, color: '#17a2b8' },
                { label: 'è·Œå¹… 0%-5%', value: distribution.down_0_5, color: '#ffc107' },
                { label: 'è·Œå¹… 5%-10%', value: distribution.down_5_10, color: '#fd7e14' },
                { label: 'è·Œå¹… â‰¥10%', value: distribution.down_10_plus, color: '#dc3545' }
            ];
            
            const total = categories.reduce((sum, cat) => sum + cat.value, 0);
            
            categories.forEach(cat => {
                const percentage = total > 0 ? (cat.value / total * 100).toFixed(1) : 0;
                html += `
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #e0e0e0;"><strong>${cat.label}</strong></span>
                            <span style="color: #bbb;">${cat.value} ä¸ª (${percentage}%)</span>
                        </div>
                        <div style="background: #1a1a1a; height: 30px; border-radius: 5px; overflow: hidden; border: 1px solid #444;">
                            <div style="background: ${cat.color}; height: 100%; width: ${percentage}%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                ${percentage}%
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('distributionContent').innerHTML = html;
        }
        
        // æ¸²æŸ“æ‰€æœ‰å¸ç§åˆ—è¡¨
        function renderAllCoinsTab(coins) {
            // æ·»åŠ æœç´¢åŠŸèƒ½
            const searchInput = document.getElementById('coinSearchInput');
            searchInput.onkeyup = function() {
                filterCoins(this.value.toUpperCase());
            };
            
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å¸ç§</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæ¶¨è·Œ</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">å½“å‰ä»·æ ¼</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€é«˜</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24hæœ€ä½</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">äº¤æ˜“é‡</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">æ•°æ®æº</th>';
            html += '</tr></thead><tbody>';
            
            coins.forEach(coin => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                const textColor = coin.source === 'Failed' ? '#666' : '#e0e0e0';
                html += `<tr class="coin-row" data-symbol="${coin.symbol}" style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: ${textColor};"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">${coin.volume.toFixed(2)}</td>
                    <td style="padding: 10px; color: ${textColor};">${coin.source}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('allCoinsContent').innerHTML = html;
        }
        
        // è¿‡æ»¤å¸ç§
        function filterCoins(searchTerm) {
            const rows = document.querySelectorAll('.coin-row');
            rows.forEach(row => {
                const symbol = row.getAttribute('data-symbol');
                if (symbol.indexOf(searchTerm) > -1) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // åˆ‡æ¢å­Tab
        function showHotCoinsSubTab(tabName, event) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#hotCoinsTabsContainer .cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('#hotCoinsTabsContainer .cross-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const tabMap = {
                'gainers': 'gainersTab',
                'losers': 'losersTab',
                'volume': 'volumeTab',
                'distribution': 'distributionTab',
                'all': 'allTab'
            };
            
            const targetTab = document.getElementById(tabMap[tabName]);
            if (targetTab) {
                targetTab.classList.add('active');
            }
        }
        
        // ==================== çƒ­ç‚¹å¸ç§åˆ†æåŠŸèƒ½ç»“æŸ ====================
        
        // ==================== é«˜çº§å†å²åˆ†æåŠŸèƒ½ ====================
        
        let historicalAnalysisData = null;
        
        // åˆ‡æ¢åˆ†ææ¨¡å¼
        function switchHotCoinsMode(mode, event) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            event.target.parentElement.querySelectorAll('.cross-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // åˆ‡æ¢æ˜¾ç¤º
            if (mode === 'realtime') {
                document.getElementById('realtimeMode').style.display = 'block';
                document.getElementById('historicalMode').style.display = 'none';
            } else {
                document.getElementById('realtimeMode').style.display = 'none';
                document.getElementById('historicalMode').style.display = 'block';
            }
            
            // æ¸…ç©ºç»“æœ
            document.getElementById('hotCoinsResults').innerHTML = '';
            document.getElementById('hotCoinsSummary').style.display = 'none';
            document.getElementById('hotCoinsTabsContainer').style.display = 'none';
        }
        
        // å†å²æ—¶æ®µåˆ†æ
        async function analyzeHistoricalPeriod() {
            try {
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                const minGainRatio = parseFloat(document.getElementById('minGainRatio').value);
                const includeProjectInfo = document.getElementById('includeProjectInfo').checked;
                const includeMoneyFlow = document.getElementById('includeMoneyFlow').checked;
                
                if (!startDate) {
                    showStatus('è¯·é€‰æ‹©å¼€å§‹æ—¥æœŸ', 'error');
                    return;
                }
                
                showStatus(`æ­£åœ¨åˆ†æ ${startDate} ${endDate ? 'åˆ° ' + endDate : 'è‡³ä»Š'} çš„æ•°æ®ï¼Œç­›é€‰æ¶¨å¹…â‰¥${minGainRatio}å€çš„å¸ç§...`, 'info');
                
                // æ˜¾ç¤ºè¿›åº¦æ¡
                document.getElementById('hotCoinsProgress').style.display = 'block';
                document.getElementById('hotCoinsProgressText').textContent = 'åˆ†æä¸­...è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿ';
                document.getElementById('hotCoinsProgressBar').style.width = '30%';
                
                const requestData = {
                    start_date: startDate,
                    end_date: endDate || null,
                    min_gain_ratio: minGainRatio,
                    include_project_info: includeProjectInfo,
                    include_money_flow: includeMoneyFlow
                };
                
                const response = await safeFetch('/crypto_advanced/analyze_period', {
                    method: 'POST',
                    body: JSON.stringify(requestData)
                });
                
                document.getElementById('hotCoinsProgressBar').style.width = '100%';
                
                const result = await response.json();
                
                if (result.success) {
                    historicalAnalysisData = result.data;
                    displayHistoricalResults(historicalAnalysisData);
                    showStatus(`âœ… åˆ†æå®Œæˆï¼æ‰¾åˆ° ${historicalAnalysisData.qualified_count} ä¸ªç¬¦åˆæ¡ä»¶çš„å¸ç§`, 'success');
                } else {
                    showStatus(`åˆ†æå¤±è´¥: ${result.error}`, 'error');
                }
                
                setTimeout(() => {
                    document.getElementById('hotCoinsProgress').style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('å†å²åˆ†æå¤±è´¥:', error);
                showStatus(`åˆ†æå¤±è´¥: ${error.message}`, 'error');
                document.getElementById('hotCoinsProgress').style.display = 'none';
            }
        }
        
        // æ˜¾ç¤ºå†å²åˆ†æç»“æœ
        function displayHistoricalResults(data) {
            if (!data.results || data.results.length === 0) {
                document.getElementById('hotCoinsResults').innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                        <h3 style="color: #e0e0e0;">ğŸ˜¢ æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å¸ç§</h3>
                        <p style="color: #bbb;">åœ¨æŒ‡å®šæ—¶é—´æ®µå†…ï¼Œæ²¡æœ‰å¸ç§çš„æœ€é«˜ç‚¹è¾¾åˆ° ${data.min_gain_ratio}å€æ¶¨å¹…</p>
                        <p style="color: #999;">å»ºè®®ï¼šé™ä½æ¶¨å¹…å€æ•°æˆ–æ‰©å¤§æ—¶é—´èŒƒå›´</p>
                    </div>
                `;
                return;
            }
            
            let html = '<div style="margin-top: 20px;">';
            
            // æ¦‚è§ˆå¡ç‰‡
            html += `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.total_analyzed}</div>
                        <div style="font-size: 12px; color: #999;">åˆ†æå¸ç§æ•°</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;">${data.qualified_count}</div>
                        <div style="font-size: 12px; color: #999;">ç¬¦åˆæ¡ä»¶</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.start_date}</div>
                        <div style="font-size: 12px; color: #999;">å¼€å§‹æ—¥æœŸ</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.end_date}</div>
                        <div style="font-size: 12px; color: #999;">ç»“æŸæ—¥æœŸ</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.min_gain_ratio}x</div>
                        <div style="font-size: 12px; color: #999;">æœ€å°æ¶¨å¹…</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #dc3545; margin-bottom: 5px;">${data.results[0].gain_ratio.toFixed(2)}x</div>
                        <div style="font-size: 12px; color: #999;">æœ€é«˜æ¶¨å¹…</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #ffc107; margin-bottom: 5px;">${data.failed_count || 0}</div>
                        <div style="font-size: 12px; color: #999;">åˆ†æå¤±è´¥</div>
                    </div>
                </div>
            `;
            
            // æ·»åŠ æŸ¥çœ‹å¤±è´¥è®°å½•æŒ‰é’®
            if (data.failed_count > 0) {
                html += `
                    <div style="text-align: center; margin: 20px 0;">
                        <button class="btn btn-warning" onclick="showFailedRecords()">
                            âš ï¸ æŸ¥çœ‹å¤±è´¥è®°å½• (${data.failed_count}ä¸ªå¸ç§)
                        </button>
                    </div>
                `;
            }
            
            // å¸ç§åˆ—è¡¨
            html += '<h3 style="margin-top: 30px; color: #e0e0e0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">ğŸ† è¶…çº§ç‰›å¸æ¦œå•</h3>';
            
            data.results.forEach((coin, index) => {
                html += `
                    <div style="background: #1a1a1a; border: 2px solid #28a745; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div>
                                <span style="font-size: 24px; font-weight: bold; color: #e0e0e0;">
                                    ${index + 1}. ${coin.symbol}
                                </span>
                                <span style="font-size: 32px; font-weight: bold; color: #28a745; margin-left: 20px;">
                                    ${coin.gain_ratio.toFixed(2)}x ğŸš€
                                </span>
                                <span style="color: #999; margin-left: 10px;">(æœ€é«˜ç‚¹+${coin.gain_percent.toFixed(2)}%)</span>
                            </div>
                            <div>
                                <button class="btn btn-info" onclick="showCoinDetail('${coin.symbol}', ${index})">ğŸ“Š æŸ¥çœ‹è¯¦æƒ…</button>
                                <button class="btn btn-success" onclick="showCoinChart('${coin.symbol}')">ğŸ“ˆ æŸ¥çœ‹å›¾è¡¨</button>
                            </div>
                        </div>
                        
                        <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #444;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #bbb;">ğŸ“… æ—¶é—´è·¨åº¦:</strong><br>
                                    <span style="color: #e0e0e0;">${coin.start_date} è‡³ ${coin.end_date}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">ğŸ’° èµ·å§‹ä»·æ ¼:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.start_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">ğŸ“ˆ æœ€é«˜ä»·:</strong><br>
                                    <span style="color: #28a745; font-size: 18px; font-weight: bold;">$${coin.max_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">ğŸ“‰ æœ€ä½ä»·:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.min_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">ğŸ’µ å½“å‰ä»·æ ¼:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.end_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">ğŸ“Š å½“å‰æ¶¨å¹…:</strong><br>
                                    <span style="color: ${coin.current_gain_percent >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;">
                                        ${coin.current_gain_ratio ? coin.current_gain_ratio.toFixed(2) : 'N/A'}x (${coin.current_gain_percent >= 0 ? '+' : ''}${coin.current_gain_percent ? coin.current_gain_percent.toFixed(2) : 'N/A'}%)
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        ${coin.project_info ? `
                            <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #444;">
                                <h4 style="margin: 0 0 10px 0; color: #17a2b8;">ğŸ“‹ é¡¹ç›®ä¿¡æ¯</h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                    <div><strong style="color: #bbb;">é¡¹ç›®åç§°:</strong> <span style="color: #e0e0e0;">${coin.project_info.name}</span></div>
                                    <div><strong style="color: #bbb;">å¸‚å€¼æ’å:</strong> <span style="color: #e0e0e0;">#${coin.project_info.market_cap_rank}</span></div>
                                    <div><strong style="color: #bbb;">æŠ€æœ¯èµ›é“:</strong> <span style="color: #28a745;">${coin.project_info.categories.join(', ') || 'æœªçŸ¥'}</span></div>
                                    <div><strong style="color: #bbb;">å¸‚å€¼:</strong> <span style="color: #e0e0e0;">$${(coin.project_info.market_cap / 1e6).toFixed(2)}M</span></div>
                                </div>
                                <div style="margin-top: 10px;">
                                    <strong style="color: #bbb;">é¡¹ç›®ç®€ä»‹:</strong> <span style="color: #ccc;">${coin.project_info.description || 'æš‚æ— æè¿°'}</span>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                                    <div><strong style="color: #bbb;">Twitterç²‰ä¸:</strong> <span style="color: #e0e0e0;">${coin.project_info.twitter_followers.toLocaleString()}</span></div>
                                    <div><strong style="color: #bbb;">GitHubæ˜Ÿæ ‡:</strong> <span style="color: #e0e0e0;">${coin.project_info.github_stars}</span></div>
                                    <div><strong style="color: #bbb;">4å‘¨ä»£ç æäº¤:</strong> <span style="color: #e0e0e0;">${coin.project_info.github_commits_4w}</span></div>
                                </div>
                                <div style="margin-top: 10px;">
                                    ${coin.project_info.homepage ? `<a href="${coin.project_info.homepage}" target="_blank" style="margin-right: 15px; color: #17a2b8; text-decoration: none;">ğŸŒ å®˜ç½‘</a>` : ''}
                                    ${coin.project_info.github ? `<a href="${coin.project_info.github}" target="_blank" style="margin-right: 15px; color: #17a2b8; text-decoration: none;">ğŸ’» GitHub</a>` : ''}
                                    ${coin.project_info.twitter ? `<a href="https://twitter.com/${coin.project_info.twitter}" target="_blank" style="color: #17a2b8; text-decoration: none;">ğŸ¦ Twitter</a>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${coin.money_flow ? `
                            <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #444;">
                                <h4 style="margin: 0 0 10px 0; color: #ffc107;">ğŸ’° èµ„é‡‘æµå‘åˆ†æ</h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                    <div><strong style="color: #bbb;">æœ€æ–°èµ„é‡‘æµ:</strong> <span style="color: ${coin.money_flow.latest_flow > 0 ? '#28a745' : '#dc3545'};">${coin.money_flow.latest_flow > 0 ? 'âœ… æµå…¥' : 'âš ï¸ æµå‡º'} ${Math.abs(coin.money_flow.latest_flow).toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">ç´¯è®¡èµ„é‡‘æµ:</strong> <span style="color: #e0e0e0;">${coin.money_flow.cumulative_flow.toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">æ—¥å‡æˆäº¤é‡:</strong> <span style="color: #e0e0e0;">${coin.money_flow.avg_daily_volume.toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">OBVæŒ‡æ ‡:</strong> <span style="color: #e0e0e0;">${coin.money_flow.obv.toFixed(2)}</span></div>
                                </div>
                                <button class="btn btn-info" onclick="showMoneyFlowChart('${coin.symbol}')" style="margin-top: 10px;">
                                    ğŸ“Š æŸ¥çœ‹èµ„é‡‘æµå‘å›¾è¡¨
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('hotCoinsResults').innerHTML = html;
        }
        
        // æ˜¾ç¤ºå¸ç§è¯¦æƒ…ï¼ˆå¼¹çª—ï¼‰
        function showCoinDetail(symbol, index) {
            const coin = historicalAnalysisData.results[index];
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: #1a1a1a; padding: 30px; border-radius: 15px; max-width: 800px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;" onclick="event.stopPropagation()">
                        <h2 style="color: #e0e0e0;">${coin.symbol} - è¯¦ç»†æŠ¥å‘Š</h2>
                        <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; right: 20px; top: 20px; background: #dc3545; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">å…³é—­</button>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                            <h3 style="color: #28a745;">ğŸ’¹ æ¶¨å¹…æ•°æ®</h3>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">æœ€é«˜ç‚¹æ¶¨å¹…:</strong> ${coin.gain_ratio.toFixed(2)}x (+${coin.gain_percent.toFixed(2)}%)</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">å½“å‰æ¶¨å¹…:</strong> ${coin.current_gain_ratio ? coin.current_gain_ratio.toFixed(2) : 'N/A'}x (+${coin.current_gain_percent ? coin.current_gain_percent.toFixed(2) : 'N/A'}%)</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">ä»·æ ¼å˜åŒ–:</strong> $${coin.start_price.toFixed(6)} â†’ $${coin.end_price.toFixed(6)}</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">ä»·æ ¼åŒºé—´:</strong> æœ€ä½ <span style="color: #dc3545;">$${coin.min_price.toFixed(6)}</span>, æœ€é«˜ <span style="color: #28a745;">$${coin.max_price.toFixed(6)}</span></p>
                        </div>
                        
                        ${coin.project_info ? `
                            <div style="margin-top: 20px; padding: 15px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                                <h3 style="color: #17a2b8;">ğŸ“‹ é¡¹ç›®è¯¦æƒ…</h3>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">å®Œæ•´åç§°:</strong> ${coin.project_info.name}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">å¸‚å€¼æ’å:</strong> #${coin.project_info.market_cap_rank}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">æŠ€æœ¯èµ›é“:</strong> <span style="color: #28a745;">${coin.project_info.categories.join(', ')}</span></p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">æµé€šé‡:</strong> ${coin.project_info.circulating_supply.toLocaleString()}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">æ€»ä¾›åº”é‡:</strong> ${coin.project_info.total_supply.toLocaleString()}</p>
                                
                                <h4 style="margin-top: 15px; color: #20c997;">ç¤¾åŒºæ´»è·ƒåº¦</h4>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Twitter:</strong> ${coin.project_info.twitter_followers.toLocaleString()} ç²‰ä¸</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Reddit:</strong> ${coin.project_info.reddit_subscribers.toLocaleString()} è®¢é˜…è€…</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Telegram:</strong> ${coin.project_info.telegram_users.toLocaleString()} ç”¨æˆ·</p>
                                
                                <h4 style="margin-top: 15px; color: #ffc107;">å¼€å‘æ´»è·ƒåº¦</h4>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">GitHubæ˜Ÿæ ‡:</strong> ${coin.project_info.github_stars}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Forks:</strong> ${coin.project_info.github_forks}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">æœ€è¿‘4å‘¨æäº¤:</strong> ${coin.project_info.github_commits_4w} æ¬¡</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Issues:</strong> ${coin.project_info.github_total_issues} (å·²å…³é—­: ${coin.project_info.github_closed_issues})</p>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // æ˜¾ç¤ºå¸ç§ä»·æ ¼å›¾è¡¨
        async function showCoinChart(symbol) {
            try {
                showStatus(`æ­£åœ¨åŠ è½½ ${symbol} çš„å†å²å›¾è¡¨...`, 'info');
                
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                
                const response = await safeFetch('/crypto_advanced/get_historical_chart', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbol: symbol,
                        start_date: startDate,
                        end_date: endDate || null,
                        interval: '1d'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayPriceChart(result.symbol, result.data);
                } else {
                    showStatus(`åŠ è½½å›¾è¡¨å¤±è´¥: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('åŠ è½½å›¾è¡¨å¤±è´¥:', error);
                showStatus(`åŠ è½½å›¾è¡¨å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æ˜¾ç¤ºä»·æ ¼å›¾è¡¨ï¼ˆä½¿ç”¨Chart.jsï¼‰
        function displayPriceChart(symbol, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = () => modal.remove();
            
            const chartContainer = document.createElement('div');
            chartContainer.style.cssText = 'background: #1a1a1a; padding: 30px; border-radius: 15px; width: 90%; max-width: 1200px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;';
            chartContainer.onclick = (e) => e.stopPropagation();
            
            chartContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; background: #1a1a1a; padding: 15px; border-radius: 8px;">
                    <h2 style="color: #e0e0e0; margin: 0;">${symbol} - å†å²ä»·æ ¼èµ°åŠ¿</h2>
                    <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">å…³é—­</button>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px;">
                    <canvas id="priceChart" style="max-height: 500px;"></canvas>
                </div>
            `;
            
            modal.appendChild(chartContainer);
            document.body.appendChild(modal);
            
            // ç»˜åˆ¶å›¾è¡¨
            const ctx = document.getElementById('priceChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'ä»·æ ¼ (USD)',
                        data: data.prices,
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0',
                            borderColor: '#444',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: {
                                display: true,
                                text: 'ä»·æ ¼ (USD)',
                                color: '#e0e0e0'
                            }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: {
                                display: true,
                                text: 'æ—¥æœŸ',
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }
        
        // æ˜¾ç¤ºèµ„é‡‘æµå‘å›¾è¡¨
        async function showMoneyFlowChart(symbol) {
            try {
                showStatus(`æ­£åœ¨åŠ è½½ ${symbol} çš„èµ„é‡‘æµå‘å›¾è¡¨...`, 'info');
                
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                
                const response = await safeFetch('/crypto_advanced/get_money_flow_chart', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbol: symbol,
                        start_date: startDate,
                        end_date: endDate || null
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayMoneyFlowChart(result.symbol, result.data);
                } else {
                    showStatus(`åŠ è½½èµ„é‡‘æµå‘å¤±è´¥: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('åŠ è½½èµ„é‡‘æµå‘å¤±è´¥:', error);
                showStatus(`åŠ è½½èµ„é‡‘æµå‘å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æ˜¾ç¤ºèµ„é‡‘æµå‘å›¾è¡¨
        function displayMoneyFlowChart(symbol, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = () => modal.remove();
            
            const chartContainer = document.createElement('div');
            chartContainer.style.cssText = 'background: #1a1a1a; padding: 30px; border-radius: 15px; width: 90%; max-width: 1200px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;';
            chartContainer.onclick = (e) => e.stopPropagation();
            
            chartContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; background: #2b2b2b; padding: 15px; border-radius: 8px;">
                    <h2 style="color: #e0e0e0; margin: 0;">${symbol} - èµ„é‡‘æµå‘åˆ†æ</h2>
                    <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">å…³é—­</button>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <canvas id="moneyFlowChart" style="max-height: 400px;"></canvas>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px;">
                    <canvas id="obvChart" style="max-height: 300px;"></canvas>
                </div>
            `;
            
            modal.appendChild(chartContainer);
            document.body.appendChild(modal);
            
            // èµ„é‡‘æµå‘å›¾è¡¨
            const ctx1 = document.getElementById('moneyFlowChart').getContext('2d');
            new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'æ¯æ—¥èµ„é‡‘æµå‘',
                        data: data.money_flow,
                        backgroundColor: data.money_flow.map(v => v >= 0 ? 'rgba(40, 167, 69, 0.7)' : 'rgba(220, 53, 69, 0.7)'),
                        borderColor: data.money_flow.map(v => v >= 0 ? '#28a745' : '#dc3545'),
                        borderWidth: 1
                    }, {
                        label: 'ç´¯è®¡èµ„é‡‘æµ',
                        data: data.cumulative_flow,
                        type: 'line',
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        tension: 0.4,
                        fill: false,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0'
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: { 
                                display: true, 
                                text: 'æ¯æ—¥èµ„é‡‘æµ',
                                color: '#e0e0e0'
                            }
                        },
                        y1: {
                            position: 'right',
                            ticks: { color: '#e0e0e0' },
                            grid: { drawOnChartArea: false },
                            title: { 
                                display: true, 
                                text: 'ç´¯è®¡èµ„é‡‘æµ',
                                color: '#e0e0e0'
                            }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
            
            // OBVå›¾è¡¨
            const ctx2 = document.getElementById('obvChart').getContext('2d');
            new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'OBV (èƒ½é‡æ½®)',
                        data: data.obv,
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(255, 193, 7, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0'
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        
        // æ˜¾ç¤ºç¤ºä¾‹
        function showAdvancedExample() {
            alert(`ç¤ºä¾‹è¯´æ˜ï¼š

ğŸ“… å¼€å§‹æ—¥æœŸï¼š2025-08-20
ğŸ“… ç»“æŸæ—¥æœŸï¼šä»Šå¤©ï¼ˆé»˜è®¤è‡ªåŠ¨å¡«å……ï¼‰
ğŸ¯ æœ€é«˜ç‚¹æ¶¨å¹…å€æ•°ï¼š3ï¼ˆè¡¨ç¤ºç­›é€‰æœŸé—´æœ€é«˜ç‚¹è¾¾åˆ°3å€çš„å¸ç§ï¼‰

âš ï¸ æ³¨æ„ï¼šæ¶¨å¹…è®¡ç®—ä½¿ç”¨æœŸé—´æœ€é«˜ä»·ï¼Œä¸æ˜¯å½“å‰ä»·æ ¼ï¼
ä¾‹å¦‚ï¼šæŸå¸ä»$1æ¶¨åˆ°$5åå›è½è‡³$2ï¼Œç®—5å€æ¶¨å¹…âœ…

å‹¾é€‰é€‰é¡¹ï¼š
âœ… åŒ…å«é¡¹ç›®è¯¦æƒ… - æ˜¾ç¤ºé¡¹ç›®åç§°ã€æè¿°ã€æŠ€æœ¯èµ›é“ã€ç¤¾äº¤åª’ä½“ã€å¼€å‘è¿›åº¦ç­‰
âœ… åŒ…å«èµ„é‡‘æµå‘ - æ˜¾ç¤ºæ¯æ—¥èµ„é‡‘æµå…¥æµå‡ºã€ç´¯è®¡èµ„é‡‘æµå‘ã€OBVæŒ‡æ ‡ç­‰

åˆ†æç»“æœå°†åŒ…æ‹¬ï¼š
â€¢ æ¶¨å¹…æ’è¡Œæ¦œ
â€¢ é¡¹ç›®åŸºæœ¬ä¿¡æ¯å’Œåˆ†ç±»
â€¢ GitHubä»£ç æäº¤è®°å½•
â€¢ Twitter/Reddit/Telegramç¤¾åŒºæ•°æ®
â€¢ èµ„é‡‘æµå‘å¯è§†åŒ–å›¾è¡¨
â€¢ å†å²ä»·æ ¼èµ°åŠ¿å›¾

âš ï¸ æ³¨æ„ï¼šå®Œæ•´åˆ†æéœ€è¦è¾ƒé•¿æ—¶é—´ï¼ˆçº¦3-5åˆ†é’Ÿï¼‰ï¼Œè¯·è€å¿ƒç­‰å¾…`);
        }
        
        // æ˜¾ç¤ºå¤±è´¥è®°å½•
        function showFailedRecords() {
            if (!historicalAnalysisData || !historicalAnalysisData.failed_records) {
                showStatus('æ²¡æœ‰å¤±è´¥è®°å½•', 'info');
                return;
            }
            
            const failedRecords = historicalAnalysisData.failed_records;
            
            // æŒ‰å¤±è´¥åŸå› åˆ†ç±»
            const byReason = {};
            failedRecords.forEach(record => {
                if (!byReason[record.reason]) {
                    byReason[record.reason] = [];
                }
                byReason[record.reason].push(record);
            });
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center; overflow-y: auto;" onclick="this.remove()">
                    <div style="background: #1a1a1a; padding: 30px; border-radius: 15px; max-width: 900px; width: 90%; max-height: 90vh; overflow-y: auto; margin: 20px; border: 2px solid #444;" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ffc107; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #e0e0e0;">âš ï¸ å¤±è´¥è®°å½•</h2>
                            <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">å…³é—­</button>
                        </div>
                        
                        <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                            <strong style="color: #ffc107;">ğŸ“Š ç»Ÿè®¡æ¦‚è§ˆ</strong>
                            <div style="margin-top: 10px; color: #e0e0e0;">
                                <p>â€¢ æ€»åˆ†ææ•°: ${historicalAnalysisData.total_analyzed} ä¸ªå¸ç§</p>
                                <p>â€¢ æˆåŠŸæ•°: ${historicalAnalysisData.qualified_count} ä¸ª</p>
                                <p>â€¢ å¤±è´¥æ•°: ${historicalAnalysisData.failed_count} ä¸ª</p>
                                <p>â€¢ æˆåŠŸç‡: ${((historicalAnalysisData.total_analyzed - historicalAnalysisData.failed_count) / historicalAnalysisData.total_analyzed * 100).toFixed(1)}%</p>
                            </div>
                        </div>
            `;
            
            // æŒ‰å¤±è´¥åŸå› åˆ†ç»„æ˜¾ç¤º
            Object.keys(byReason).forEach(reason => {
                const records = byReason[reason];
                const reasonColor = {
                    'æ— æ³•è·å–å†å²æ•°æ®': '#dc3545',
                    'éƒ¨åˆ†æ•°æ®è·å–å¤±è´¥': '#ffc107',
                    'åˆ†æå¼‚å¸¸': '#fd7e14'
                }[reason] || '#6c757d';
                
                html += `
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: ${reasonColor}; border-bottom: 2px solid ${reasonColor}; padding-bottom: 10px;">
                            ${reason} (${records.length}ä¸ª)
                        </h3>
                        <div style="max-height: 200px; overflow-y: auto; background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 10px; border: 1px solid #444;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #1a1a1a;">
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">åºå·</th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">å¸ç§</th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">è¯¦ç»†åŸå› </th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                records.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid #444;">
                            <td style="padding: 8px; color: #999;">${index + 1}</td>
                            <td style="padding: 8px;"><strong style="color: #e0e0e0;">${record.symbol}</strong></td>
                            <td style="padding: 8px; color: #bbb;">${record.detail}</td>
                        </tr>
                    `;
                });
                
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });
            
            // æ·»åŠ å¯¼å‡ºåŠŸèƒ½
            html += `
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 2px solid #444;">
                    <button class="btn btn-info" onclick="exportFailedRecords()">
                        ğŸ“¥ å¯¼å‡ºå¤±è´¥è®°å½•ï¼ˆCSVï¼‰
                    </button>
                    <button class="btn btn-secondary" onclick="this.closest('[style*=fixed]').remove()" style="margin-left: 10px;">
                        å…³é—­
                    </button>
                </div>
            `;
            
            html += '</div></div>';
            
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // å¯¼å‡ºå¤±è´¥è®°å½•ä¸ºCSV
        function exportFailedRecords() {
            if (!historicalAnalysisData || !historicalAnalysisData.failed_records) {
                showStatus('æ²¡æœ‰å¤±è´¥è®°å½•', 'error');
                return;
            }
            
            try {
                const failedRecords = historicalAnalysisData.failed_records;
                
                // åˆ›å»ºCSVå†…å®¹
                let csv = '\uFEFF';  // UTF-8 BOM
                csv += 'å¸ç§,å¤±è´¥åŸå› ,è¯¦ç»†ä¿¡æ¯\n';
                
                failedRecords.forEach(record => {
                    csv += `${record.symbol},"${record.reason}","${record.detail}"\n`;
                });
                
                // ä¸‹è½½CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                link.setAttribute('href', url);
                link.setAttribute('download', `å¤±è´¥è®°å½•_${timestamp}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`æˆåŠŸå¯¼å‡º ${failedRecords.length} æ¡å¤±è´¥è®°å½•`, 'success');
                
            } catch (error) {
                console.error('å¯¼å‡ºå¤±è´¥è®°å½•å¤±è´¥:', error);
                showStatus(`å¯¼å‡ºå¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // ==================== é«˜çº§å†å²åˆ†æåŠŸèƒ½ç»“æŸ ====================
        
        // ==================== è¶…çŸ­BTCä¿¡å·ç³»ç»Ÿ ====================
        
        let ultraShortChart = null;
        let ultraShortCandleSeries = null;
        let ultraShortBbLowerSeries = null;
        let ultraShortBbUpperSeries = null;
        let ultraShortSupportLines = [];
        let ultraShortMonitorInterval = null;
        let ultraShortSignalCheckInterval = null;
        
        // åˆå§‹åŒ–å›¾è¡¨
        function ultraShortInitChart() {
            if (ultraShortChart) return;
            
            if (!window.LightweightCharts) {
                document.getElementById('ultraShortChartStatus').textContent = 'Kçº¿åº“æœªåŠ è½½';
                return;
            }
            
            const container = document.getElementById('ultraShortChart');
            if (!container) return;
            
            ultraShortChart = LightweightCharts.createChart(container, {
                layout: { background: { color: '#0f111a' }, textColor: '#e5e5e5' },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                rightPriceScale: { borderVisible: false },
                timeScale: { borderVisible: false },
                grid: { vertLines: { color: '#1f2335' }, horzLines: { color: '#1f2335' } },
            });
            
            ultraShortCandleSeries = ultraShortChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
                borderVisible: false
            });
            
            // å¸ƒæ—å¸¦ä¸Šè½¨
            ultraShortBbUpperSeries = ultraShortChart.addLineSeries({
                color: '#ff9800',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'å¸ƒæ—å¸¦ä¸Šè½¨'
            });
            
            // å¸ƒæ—å¸¦ä¸‹è½¨
            ultraShortBbLowerSeries = ultraShortChart.addLineSeries({
                color: '#2196f3',
                lineWidth: 2,
                title: 'å¸ƒæ—å¸¦ä¸‹è½¨'
            });
            
            // è‡ªé€‚åº”å°ºå¯¸
            setTimeout(() => ultraShortResizeChart(), 0);
            if (window.ResizeObserver) {
                new ResizeObserver(ultraShortResizeChart).observe(container);
            } else {
                window.addEventListener('resize', ultraShortResizeChart);
            }
            
            // åŠ è½½Kçº¿æ•°æ®
            ultraShortLoadChartData();
        }
        
        function ultraShortResizeChart() {
            if (!ultraShortChart) return;
            const container = document.getElementById('ultraShortChart');
            if (!container) return;
            const rect = container.getBoundingClientRect();
            const w = Math.max(300, Math.floor(rect.width || container.clientWidth || 0));
            const h = Math.max(300, Math.floor(rect.height || container.clientHeight || 600));
            if (w > 0 && h > 0) {
                ultraShortChart.resize(w, h);
            }
        }
        
        async function ultraShortLoadChartData() {
            try {
                const timeframe = document.getElementById('ultraShortTimeframe').value || '5m';
                const response = await fetch('/ultra_short/get_klines', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol: 'BTC', interval: timeframe, limit: 200 })
                });
                
                const data = await response.json();
                if (data.success && data.klines) {
                    ultraShortUpdateChart(data.klines);
                    document.getElementById('ultraShortChartStatus').textContent = 'å·²åŠ è½½ ' + data.klines.length + ' æ ¹Kçº¿';
                } else {
                    document.getElementById('ultraShortChartStatus').textContent = 'åŠ è½½Kçº¿æ•°æ®å¤±è´¥';
                }
            } catch (error) {
                console.error('åŠ è½½Kçº¿æ•°æ®å¤±è´¥:', error);
                document.getElementById('ultraShortChartStatus').textContent = 'åŠ è½½å¤±è´¥: ' + error.message;
            }
        }
        
        function ultraShortUpdateChart(klines) {
            if (!ultraShortCandleSeries) return;
            
            // è½¬æ¢æ•°æ®æ ¼å¼
            const candles = klines.map(k => ({
                time: k.time,
                open: k.open,
                high: k.high,
                low: k.low,
                close: k.close
            }));
            
            ultraShortCandleSeries.setData(candles);
            ultraShortChart.timeScale().fitContent();
        }
        
        async function ultraShortCheckSignal() {
            try {
                document.getElementById('ultraShortLastCheck').textContent = new Date().toLocaleTimeString();
                document.getElementById('ultraShortMonitorStatus').textContent = 'æ£€æŸ¥ä¸­...';
                
                const response = await fetch('/ultra_short/check_signal?symbol=BTC');
                const data = await response.json();
                
                if (data.success && data.has_signal) {
                    ultraShortDisplaySignal(data.signal);
                    ultraShortLoadActiveSignals();
                } else {
                    document.getElementById('ultraShortMonitorStatus').textContent = 'æ— ä¿¡å·';
                }
                
            } catch (error) {
                console.error('æ£€æŸ¥ä¿¡å·å¤±è´¥:', error);
                document.getElementById('ultraShortMonitorStatus').textContent = 'æ£€æŸ¥å¤±è´¥';
            }
        }
        
        async function ultraShortLoadActiveSignals() {
            try {
                const response = await fetch('/ultra_short/get_active_signals');
                const data = await response.json();
                
                const container = document.getElementById('ultraShortActiveSignals');
                if (data.success && data.signals && data.signals.length > 0) {
                    container.innerHTML = data.signals.map(signal => {
                        return '<div style="padding: 10px; margin: 5px 0; background: rgba(33, 150, 243, 0.2); border-radius: 5px; border-left: 3px solid #2196f3;">' +
                            '<div><strong>å…¥åœº: ' + signal.entry_price + '</strong></div>' +
                            '<div>æ­¢æŸ: ' + signal.stop_loss + ' (' + (signal.entry_price - signal.stop_loss).toFixed(2) + 'ç‚¹)</div>' +
                            '<div>æ­¢ç›ˆ: ' + signal.take_profit_price + ' (' + (signal.take_profit_price - signal.entry_price).toFixed(2) + 'ç‚¹)</div>' +
                            '<div>ç›ˆäºæ¯”: 1:' + signal.risk_reward_ratio + '</div>' +
                            '<div>ä¿¡å·å¼ºåº¦: ' + signal.signal_strength + '</div>' +
                            '<div style="font-size: 12px; color: #999;">' + new Date(signal.created_at).toLocaleString() + '</div>' +
                            '</div>';
                    }).join('');
                } else {
                    container.innerHTML = '<p class="muted">æš‚æ— æ´»è·ƒä¿¡å·</p>';
                }
            } catch (error) {
                console.error('åŠ è½½æ´»è·ƒä¿¡å·å¤±è´¥:', error);
            }
        }
        
        async function ultraShortLoadHistorySignals() {
            try {
                const response = await fetch('/ultra_short/get_history_signals?limit=20');
                const data = await response.json();
                
                const container = document.getElementById('ultraShortHistorySignals');
                if (data.success && data.signals && data.signals.length > 0) {
                    container.innerHTML = data.signals.map(signal => {
                        return '<div style="padding: 8px; margin: 3px 0; background: rgba(100, 100, 100, 0.2); border-radius: 5px; font-size: 13px;">' +
                            '<div>å…¥åœº: ' + signal.entry_price + ' | çŠ¶æ€: ' + signal.status + '</div>' +
                            '<div style="font-size: 11px; color: #999;">' + new Date(signal.created_at).toLocaleString() + '</div>' +
                            '</div>';
                    }).join('');
                } else {
                    container.innerHTML = '<p class="muted">æš‚æ— å†å²è®°å½•</p>';
                }
            } catch (error) {
                console.error('åŠ è½½å†å²ä¿¡å·å¤±è´¥:', error);
            }
        }
        
        function ultraShortDisplaySignal(signal) {
            console.log('æ–°ä¿¡å·:', signal);
        }
        
        function ultraShortStartMonitor() {
            if (ultraShortMonitorInterval) return;
            
            ultraShortCheckSignal();
            ultraShortLoadActiveSignals();
            ultraShortLoadHistorySignals();
            
            ultraShortMonitorInterval = setInterval(function() {
                ultraShortCheckSignal();
                ultraShortLoadActiveSignals();
            }, 60000);
            
            ultraShortSignalCheckInterval = setInterval(function() {
                ultraShortCheckSignal();
            }, 5000);
            
            setInterval(function() {
                ultraShortLoadChartData();
            }, 30000);
            
            document.getElementById('ultraShortMonitorStatus').textContent = 'ç›‘æ§ä¸­';
        }
        
        function ultraShortStopMonitor() {
            if (ultraShortMonitorInterval) {
                clearInterval(ultraShortMonitorInterval);
                ultraShortMonitorInterval = null;
            }
            if (ultraShortSignalCheckInterval) {
                clearInterval(ultraShortSignalCheckInterval);
                ultraShortSignalCheckInterval = null;
            }
            document.getElementById('ultraShortMonitorStatus').textContent = 'å·²åœæ­¢';
        }
        
        // Tabåˆ‡æ¢æ—¶åˆå§‹åŒ–å›¾è¡¨
        const originalShowTab = window.showTab;
        window.showTab = function(tabName, event) {
            originalShowTab(tabName, event);
            if (tabName === 'ultraShort') {
                setTimeout(function() {
                    ultraShortInitChart();
                    ultraShortLoadActiveSignals();
                    ultraShortLoadHistorySignals();
                }, 100);
            }
        };
        
        // ==================== è¶…çŸ­BTCä¿¡å·ç³»ç»Ÿç»“æŸ ====================
        
    </script>
</body>
</html>
