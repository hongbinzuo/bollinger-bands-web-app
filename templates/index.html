<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>布林带策略系统</title>
    <!-- Chart.js 图表库 - 主页面使用 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" onerror="console.error('Chart.js加载失败')"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js" onerror="console.error('Chart.js适配器加载失败')"></script>
    <!-- Lightweight Charts 本地静态库（用于K线绘制Tab） -->
    <script src="/static/vendor/lightweight-charts/lightweight-charts.standalone.production.min.js"></script>
    
    <script>
        // 显示Tab函数 - 需要在HTML之前定义
        function showTab(tabName, event) {
            // 隐藏所有tab内容
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // 移除所有tab的active类
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // 显示选中的tab
            const targetContent = document.getElementById(tabName);
            if (targetContent) {
                targetContent.classList.add('active');
            }
            
            // 添加active类到点击的tab
            if (event && event.target) {
                event.target.classList.add('active');
            }
            // 如果切到K线绘制，初始化一次
            try {
                if (tabName === 'klineDraw' && window.KLINE && typeof KLINE.init === 'function') {
                    KLINE.init();
                }
            } catch (e) { console.warn('KLINE init error', e); }
        }
        
        // 显示交叉点Tab函数
        function showCrossTab(tabType, event) {
            // 更新标签按钮状态
            document.querySelectorAll('.cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // 更新内容显示
            document.querySelectorAll('.cross-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabType === 'price') {
                document.getElementById('priceCrossPoints').classList.add('active');
            } else {
                document.getElementById('indicatorCrossPoints').classList.add('active');
            }
        }
        
        // 多时间框架相关函数 - 需要在HTML之前定义
        async function analyzeMultiTimeframeSymbols() {
            try {
                // 获取策略类型
                const strategyType = document.getElementById('strategyTypeSelect').value;
                showStatus(`正在获取前500个币种 (策略: ${strategyType === 'original' ? '原策略' : '修改策略'})...`, 'info');
                
                // 使用安全的fetch函数
                const response = await safeFetch('/multi_timeframe/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`成功获取 ${data.count} 个币种`, 'success');
                    
                    // 设置全局变量
                    if (typeof allSymbols === 'undefined') {
                        window.allSymbols = [];
                    }
                    allSymbols = data.symbols;
                    
                    // 重置分页和缓存
                    if (typeof currentPage === 'undefined') {
                        window.currentPage = 1;
                    }
                    currentPage = 1;
                    
                    // 【修复】重置信号缓存和分析状态，强制重新分析
                    allCachedSignals = [];
                    analysisProgress = {
                        total: 0,
                        analyzed: 0,
                        isAnalyzing: false
                    };
                    
                    // 开始分析，传递策略类型
                    await analyzeCurrentPage(strategyType);
                } else {
                    showStatus(`获取币种失败: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('analyzeMultiTimeframeSymbols error:', error);
                showStatus(`获取币种失败: ${error.message}`, 'error');
            }
        }
        
        async function getMultiTimeframeTopSymbols() {
            try {
                showStatus('正在获取前500个币种...', 'info');
                
                // 使用安全的fetch函数
                const response = await safeFetch('/multi_timeframe/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`成功获取 ${data.count} 个币种`, 'success');
                    
                    // 设置全局变量
                    if (typeof allSymbols === 'undefined') {
                        window.allSymbols = [];
                    }
                    allSymbols = data.symbols;
                    
                    // 显示币种列表
                    let symbolsHtml = '<h4>前50个币种:</h4><ul>';
                    data.symbols.slice(0, 50).forEach((symbol, index) => {
                        symbolsHtml += `<li>${index + 1}. ${symbol}</li>`;
                    });
                    symbolsHtml += '</ul>';
                    symbolsHtml += `<p><strong>总计: ${data.count} 个币种</strong></p>`;
                    symbolsHtml += '<p><em>现在可以点击"分析前500币种"按钮开始分析</em></p>';
                    
                    document.getElementById('multiTimeframeResults').innerHTML = symbolsHtml;
                } else {
                    showStatus(`获取币种失败: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('getMultiTimeframeTopSymbols error:', error);
                showStatus(`获取币种失败: ${error.message}`, 'error');
            }
        }
        
        function clearMultiTimeframeCache() {
            // 清除缓存和重置状态
            allCachedSignals = [];
            analysisProgress = {
                total: 0,
                analyzed: 0,
                isAnalyzing: false
            };
            currentPage = 1;
            totalPages = 0;
            updatePaginationControls();
            
            // 清空显示区域
            const resultsDiv = document.getElementById('multiTimeframeResults');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<p>缓存已清除，请重新开始分析</p>';
            }
            
            showStatus('多时间框架缓存已清除', 'success');
        }
        
        // 【新增】分页功能测试
        function testPagination() {
            console.log('开始测试分页功能...');
            console.log(`当前状态: 第${currentPage}页，共${totalPages}页`);
            console.log(`缓存信号数量: ${allCachedSignals.length}`);
            
            if (allCachedSignals.length === 0) {
                showStatus('请先分析币种以获取信号数据', 'warning');
                return;
            }
            
            // 测试显示第一页
            currentPage = 1;
            displayCurrentPageSignals(50);
            updatePaginationControls();
            
            showStatus(`分页测试: 显示第${currentPage}页 (共${totalPages}页)`, 'info');
            
            // 2秒后测试下一页
            if (totalPages > 1) {
                setTimeout(() => {
                    currentPage = 2;
                    displayCurrentPageSignals(50);
                    updatePaginationControls();
                    showStatus(`分页测试: 切换到第${currentPage}页`, 'success');
                    
                    // 再2秒后回到第一页
                    setTimeout(() => {
                        currentPage = 1;
                        displayCurrentPageSignals(50);
                        updatePaginationControls();
                        showStatus('分页测试完成: 回到第1页', 'success');
                    }, 2000);
                }, 2000);
            }
        }
        
        // 【新增】自动测试功能
        async function runAutoTest() {
            showStatus('开始运行自动测试...', 'info');
            
            try {
                // 测试1: 获取币种列表
                showStatus('测试1: 获取币种列表...', 'info');
                const symbolsResponse = await safeFetch('/multi_timeframe/get_top_symbols');
                const symbolsData = await symbolsResponse.json();
                
                if (!symbolsData.success) {
                    throw new Error(`获取币种失败: ${symbolsData.error}`);
                }
                
                const testSymbols = symbolsData.symbols.slice(0, 3); // 只测试前3个币种
                showStatus(`[PASS] 测试1通过: 获取到 ${symbolsData.symbols.length} 个币种，测试用 ${testSymbols.length} 个`, 'success');
                
                // 测试2: 单币种分析
                showStatus(`测试2: 单币种分析 ${testSymbols[0]}...`, 'info');
                const singleResponse = await safeFetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    body: JSON.stringify({ symbol: testSymbols[0] })
                });
                const singleData = await singleResponse.json();
                
                if (!singleData.success) {
                    throw new Error(`单币种分析失败: ${singleData.error}`);
                }
                
                showStatus(`[PASS] 测试2通过: 分析了 ${singleData.total_timeframes_analyzed} 个时间框架`, 'success');
                
                // 测试3: 小批量分析
                showStatus(`测试3: 批量分析 ${testSymbols.length} 个币种...`, 'info');
                const batchResponse = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbols: testSymbols,
                        page: 1,
                        page_size: 50
                    })
                });
                const batchData = await batchResponse.json();
                
                if (!batchData.success) {
                    throw new Error(`批量分析失败: ${batchData.error}`);
                }
                
                const signals = batchData.signals || [];
                showStatus(`[PASS] 测试3通过: 生成 ${signals.length} 个信号`, 'success');
                
                // 测试4: 分页功能
                showStatus('测试4: 分页功能...', 'info');
                const pagination = batchData.pagination || {};
                if (pagination.total_pages > 1) {
                    // 测试第2页
                    const page2Response = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                        method: 'POST',
                        body: JSON.stringify({
                            symbols: testSymbols,
                            page: 2,
                            page_size: 10
                        })
                    });
                    const page2Data = await page2Response.json();
                    
                    if (page2Data.success) {
                        showStatus(`[PASS] 测试4通过: 分页功能正常，第2页有 ${page2Data.signals.length} 个信号`, 'success');
                    } else {
                        showStatus(`[WARN] 测试4警告: 第2页获取失败`, 'warning');
                    }
                } else {
                    showStatus(`[PASS] 测试4通过: 分页信息正确 (总计 ${pagination.total_pages} 页)`, 'success');
                }
                
                // 测试5: 错误处理
                showStatus('测试5: 错误处理...', 'info');
                const errorResponse = await safeFetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    body: JSON.stringify({ symbol: 'INVALIDCOIN12345' })
                });
                const errorData = await errorResponse.json();
                
                // 错误处理应该返回成功但结果可能为空或包含错误
                showStatus('[PASS] 测试5通过: 错误处理正常', 'success');
                
                // 全部测试完成
                showStatus('[SUCCESS] 所有自动测试通过！系统工作正常', 'success');
                
            } catch (error) {
                console.error('自动测试失败:', error);
                showStatus(`[FAIL] 自动测试失败: ${error.message}`, 'error');
            }
        }
        
        // 通用工具函数
        // showStatus函数已在后面定义，这里删除重复定义
        
        // 连接状态监控
        let connectionStatus = 'connected';
        let lastHeartbeat = Date.now();
        
        // 心跳检测函数
        async function checkConnection() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/health', { 
                    method: 'HEAD',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    connectionStatus = 'connected';
                    lastHeartbeat = Date.now();
                    return true;
                }
                return false;
            } catch (error) {
                // 静默处理连接检测失败，避免控制台噪音
                if (error.name !== 'AbortError') {
                    console.warn('连接检测失败:', error.message);
                }
                connectionStatus = 'disconnected';
                return false;
            }
        }
        
        // 定期心跳检测（仅在必要时）
        let heartbeatInterval = null;
        function startHeartbeat() {
            if (!heartbeatInterval) {
                heartbeatInterval = setInterval(async () => {
                    const now = Date.now();
                    if (now - lastHeartbeat > 60000) { // 60秒无心跳
                        await checkConnection();
                    }
                }, 30000); // 每30秒检查一次
            }
        }
        
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }
        
        // 页面可见性变化时控制心跳
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopHeartbeat();
            } else {
                startHeartbeat();
                checkConnection(); // 页面恢复时立即检查一次
            }
        });
        
        // 页面加载时启动心跳
        if (!document.hidden) {
            startHeartbeat();
        }
        
        // 全局错误处理
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            if (event.error && event.error.message && 
                (event.error.message.includes('port closed') ||
                 event.error.message.includes('runtime.lastError') ||
                 event.error.message.includes('message port closed'))) {
                
                connectionStatus = 'error';
                showStatus('检测到连接问题，正在尝试自动恢复...', 'warning');
                
                // 尝试自动恢复
                setTimeout(async () => {
                    const recovered = await checkConnection();
                    if (recovered) {
                        showStatus('连接已恢复', 'success');
                    } else {
                        showStatus('连接恢复失败，请刷新页面', 'error');
                    }
                }, 2000);
            }
        });
        
        // 处理未捕获的Promise错误
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('port closed') ||
                 event.reason.message.includes('runtime.lastError') ||
                 event.reason.message.includes('message port closed'))) {
                
                connectionStatus = 'error';
                showStatus('检测到连接问题，正在尝试自动恢复...', 'warning');
                
                // 尝试自动恢复
                setTimeout(async () => {
                    const recovered = await checkConnection();
                    if (recovered) {
                        showStatus('连接已恢复', 'success');
                    } else {
                        showStatus('连接恢复失败，请刷新页面', 'error');
                    }
                }, 2000);
            }
        });
        
        // 连接状态检测
        let connectionRetryCount = 0;
        const maxRetries = 3;
        
        // 检测浏览器扩展冲突
        let extensionDetected = false;
        function detectExtensionConflicts() {
            if (extensionDetected !== null && extensionDetected !== undefined) {
                return extensionDetected;
            }
            
            const hasExtensions = window.chrome && window.chrome.runtime;
            extensionDetected = hasExtensions;
            
            if (hasExtensions) {
                console.warn('检测到浏览器扩展，可能存在消息端口冲突');
            }
            return hasExtensions;
        }
        
        // 显示扩展冲突提示
        function showExtensionConflictWarning() {
            const warningDiv = document.createElement('div');
            warningDiv.id = 'extensionWarning';
            warningDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                color: #856404;
                padding: 15px;
                border-radius: 5px;
                z-index: 10000;
                max-width: 300px;
                font-size: 14px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            `;
            warningDiv.innerHTML = `
                <strong>⚠️ 浏览器扩展冲突检测</strong><br>
                检测到浏览器扩展，可能导致连接问题。<br>
                建议：<br>
                1. 使用无痕模式<br>
                2. 禁用广告拦截器<br>
                3. 禁用其他可能干扰的扩展<br>
                <button onclick="this.parentElement.remove()" style="margin-top:10px;padding:5px 10px;background:#007bff;color:white;border:none;border-radius:3px;cursor:pointer;">知道了</button>
            `;
            document.body.appendChild(warningDiv);
            
            // 5秒后自动隐藏
            setTimeout(() => {
                if (warningDiv.parentElement) {
                    warningDiv.remove();
                }
            }, 10000);
        }
        
        // 页面加载时检测扩展冲突
        if (detectExtensionConflicts()) {
            showExtensionConflictWarning();
        }
        
        // 智能超时配置
        function getTimeoutForUrl(url) {
            if (url.includes('/multi_timeframe/analyze_multiple_symbols')) {
                return 600000; // 10分钟 - 多币种分析
            } else if (url.includes('/analyze') || url.includes('/signals')) {
                return 300000; // 5分钟 - 分析请求
            } else if (url.includes('/health')) {
                return 5000; // 5秒 - 健康检查
            } else {
                return 60000; // 1分钟 - 默认请求
            }
        }
        
        // 安全的fetch包装函数
        async function safeFetch(url, options = {}) {
            const timeout = getTimeoutForUrl(url);
            let attempt = 0;
            const maxAttempts = 3;
            
            // 更新心跳时间戳
            lastHeartbeat = Date.now();
            
            while (attempt < maxAttempts) {
                attempt++;
                
                try {
                    // 创建AbortController用于超时控制
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal,
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache',
                            ...options.headers
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    connectionRetryCount = 0; // 重置重试计数
                    
                    if (!response.ok) {
                        let errorMessage = `HTTP error! status: ${response.status}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error) {
                                errorMessage += ` - ${errorData.error}`;
                            }
                        } catch (e) {
                            // 忽略JSON解析错误
                        }
                        throw new Error(errorMessage);
                    }
                    
                    return response;
                    
                } catch (error) {
                    console.error(`Safe fetch error (attempt ${attempt}/${maxAttempts}):`, error);
                    
                    // 如果是最后一次尝试，直接抛出错误
                    if (attempt === maxAttempts) {
                        if (error.name === 'AbortError') {
                            throw new Error(`请求超时 (${timeout/1000}秒)，请稍后重试`);
                        }
                        throw error;
                    }
                    
                    // 处理消息端口关闭错误
                    if (error.message.includes('port closed') || 
                        error.message.includes('runtime.lastError') ||
                        error.message.includes('message port closed') ||
                        error.message.includes('The message port closed')) {
                        
                        console.warn(`连接中断，等待重试 (${attempt}/${maxAttempts})`);
                        showStatus(`连接中断，正在重试 (${attempt}/${maxAttempts})...`, 'warning');
                        
                        // 指数退避重试
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    // 其他错误也进行重试
                    if (error.name === 'AbortError') {
                        console.warn(`请求超时，等待重试 (${attempt}/${maxAttempts})`);
                        showStatus(`请求超时，正在重试 (${attempt}/${maxAttempts})...`, 'warning');
                        
                        const delay = Math.min(1000 * attempt, 3000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    // 其他错误直接抛出
                    throw error;
                }
            }
        }
        
        // 分析相关函数
        async function analyzeDefault() {
            showStatus('正在分析全部币种...', 'success');
            // 实现分析逻辑
        }
        
        function showAddSymbolModal() {
            document.getElementById('addSymbolModal').style.display = 'block';
        }
        
        function closeAddSymbolModal() {
            document.getElementById('addSymbolModal').style.display = 'none';
        }
        
        function analyzeCustom() {
            showStatus('自定义分析功能', 'info');
        }
        
        function getSymbols() {
            showStatus('获取币种列表功能', 'info');
        }
        
        function toggleSortOrder() {
            showStatus('切换排序功能', 'info');
        }
        
        function changePage(direction) {
            if (direction === -1 && currentPage > 1) {
                currentPage--;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`切换到第${currentPage}页`, 'success');
            } else if (direction === 1 && currentPage < totalPages) {
                currentPage++;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`切换到第${currentPage}页`, 'success');
            }
        }
        
        // 日内交易相关函数
        function analyzeIntradaySymbols() {
            showStatus('分析日内交易信号', 'info');
        }
        
        function analyzeIntradayCustom() {
            showStatus('自定义日内分析', 'info');
        }
        
        function getIntradaySignals() {
            showStatus('获取日内信号', 'info');
        }
        
        function clearIntradayCache() {
            showStatus('清除日内缓存', 'info');
        }
        
        // 图表相关函数
        function refreshChart() {
            showStatus('刷新图表', 'info');
        }
        
        function toggleChartVisibility() {
            showStatus('切换图表显示', 'info');
        }
        
        // 超短交易相关函数
        function analyzeUltraShortSymbols() {
            showStatus('分析超短交易', 'info');
        }
        
        function analyzeUltraShortCustom() {
            showStatus('自定义超短分析', 'info');
        }
        
        function getTopSymbols() {
            showStatus('获取币种列表', 'info');
        }
        
        function validateSymbol() {
            showStatus('验证币种', 'info');
        }
        
        function clearUltraShortCache() {
            showStatus('清除超短缓存', 'info');
        }
        
        function applyRiskRewardFilter() {
            showStatus('应用风险收益过滤', 'info');
        }
        
        // 多时间框架相关函数
        function validateMultiTimeframeSymbol() {
            showStatus('验证多时间框架币种', 'info');
        }
        
        function analyzeCustomMultiTimeframeSymbols() {
            showStatus('自定义多时间框架分析', 'info');
        }
        
        function applyMultiTimeframeFilter() {
            showStatus('应用多时间框架过滤', 'info');
        }
        
        function changePageSize() {
            const newPageSize = parseInt(document.getElementById('pageSizeSelect').value);
            if (newPageSize !== 50) {
                showStatus('每页信号数量现在固定为50个，请使用分页按钮浏览', 'info');
            }
        }
        
        function previousPage() {
            changePage(-1);
        }
        
        function nextPage() {
            changePage(1);
        }
        
        // 日志相关函数
        function startLogMonitoring() {
            showStatus('开始监控日志', 'info');
        }
        
        function clearLogs() {
            showStatus('清空日志', 'info');
        }
        
        function testUltraShortWithLogs() {
            showStatus('测试超短交易', 'info');
        }
        
        function exportLogs() {
            showStatus('导出日志', 'info');
        }
        
        // 订单相关函数
        
        // 系统管理相关函数
        function clearCache() {
            showStatus('清除缓存', 'info');
        }
        
        function downloadCSV() {
            showStatus('下载CSV报告', 'info');
        }
        
        function exportData() {
            showStatus('导出数据', 'info');
        }
        
        function importData() {
            showStatus('导入数据', 'info');
        }
        
        // 斐波规律研究相关函数
        function openFibonacciPage() {
            window.open('/fibonacci-research', '_blank');
        }

        // 多空势能场模型相关函数
        let momentumFieldData = [];
        let momentumFieldChart = null;

        // 势能场分析主函数
        async function runMomentumFieldAnalysis() {
            try {
                const symbol = document.getElementById('momentumSymbol').value;
                const timeframe = document.getElementById('momentumTimeframe').value;
                const alpha = parseFloat(document.getElementById('alphaParam').value);
                const beta = parseFloat(document.getElementById('betaParam').value);

                showStatus(`开始分析 ${symbol} 的势能场模型...`, 'info');

                // 获取价格数据
                const priceData = await fetchMomentumFieldData(symbol, timeframe);
                if (!priceData || priceData.length === 0) {
                    showStatus('获取价格数据失败', 'error');
                    return;
                }

                // 计算势能场
                const momentumResults = calculateMomentumField(priceData, alpha, beta);
                
                // 显示结果
                displayMomentumFieldResults(momentumResults);
                
                // 绘制图表
                drawMomentumFieldChart(priceData, momentumResults);

                showStatus(`势能场分析完成，共分析 ${priceData.length} 个数据点`, 'success');

            } catch (error) {
                console.error('势能场分析错误:', error);
                showStatus(`势能场分析失败: ${error.message}`, 'error');
            }
        }

        // 势能场回测函数
        async function runMomentumFieldBacktest() {
            try {
                const symbol = document.getElementById('momentumSymbol').value;
                const timeframe = document.getElementById('momentumTimeframe').value;
                const alpha = parseFloat(document.getElementById('alphaParam').value);
                const beta = parseFloat(document.getElementById('betaParam').value);

                showStatus(`开始回测 ${symbol} 的势能场模型...`, 'info');

                // 获取历史数据
                const priceData = await fetchMomentumFieldData(symbol, timeframe);
                if (!priceData || priceData.length === 0) {
                    showStatus('获取历史数据失败', 'error');
                    return;
                }

                // 运行回测
                const backtestResults = runMomentumFieldBacktestAnalysis(priceData, alpha, beta);
                
                // 显示回测结果
                displayMomentumFieldBacktestResults(backtestResults);

                showStatus(`回测完成，总收益率: ${backtestResults.totalReturn.toFixed(2)}%`, 'success');

            } catch (error) {
                console.error('势能场回测错误:', error);
                showStatus(`势能场回测失败: ${error.message}`, 'error');
            }
        }

        // 获取势能场数据
        async function fetchMomentumFieldData(symbol, timeframe) {
            try {
                const response = await fetch(`/momentum-field/api/data?symbol=${symbol}&timeframe=${timeframe}`);
                const data = await response.json();
                
                if (data.success) {
                    return data.data;
                } else {
                    throw new Error(data.error || '获取数据失败');
                }
            } catch (error) {
                console.error('获取势能场数据失败:', error);
                // 返回模拟数据用于测试
                return generateMockMomentumFieldData(symbol, timeframe);
            }
        }

        // 计算势能场核心算法
        function calculateMomentumField(priceData, alpha, beta) {
            const results = {
                potentialEnergy: [],
                gradient: [],
                keyLevels: [],
                signals: [],
                statistics: {}
            };

            // 1. 识别关键中枢
            const keyLevels = identifyKeyLevels(priceData);
            results.keyLevels = keyLevels;

            // 2. 计算势能函数
            for (let i = 0; i < priceData.length; i++) {
                const currentPrice = priceData[i].close;
                const timestamp = priceData[i].timestamp;
                
                // 计算趋势动能
                const trendMomentum = calculateTrendMomentum(priceData, i);
                
                // 计算关键位引力
                const keyLevelAttraction = calculateKeyLevelAttraction(currentPrice, keyLevels);
                
                // 势能函数 Φ(P,t) = α * 趋势动能 + β * 关键位引力
                const potentialEnergy = alpha * trendMomentum + beta * keyLevelAttraction;
                results.potentialEnergy.push({
                    timestamp: timestamp,
                    price: currentPrice,
                    potentialEnergy: potentialEnergy,
                    trendMomentum: trendMomentum,
                    keyLevelAttraction: keyLevelAttraction
                });
            }

            // 3. 计算势能梯度
            for (let i = 1; i < results.potentialEnergy.length; i++) {
                const gradient = results.potentialEnergy[i].potentialEnergy - results.potentialEnergy[i-1].potentialEnergy;
                results.gradient.push({
                    timestamp: results.potentialEnergy[i].timestamp,
                    gradient: gradient
                });
            }

            // 4. 生成交易信号
            const threshold = calculateGradientThreshold(results.gradient);
            results.signals = generateTradingSignals(results.gradient, threshold);

            // 5. 计算统计信息
            results.statistics = calculateMomentumFieldStatistics(results);

            return results;
        }

        // 识别关键中枢
        function identifyKeyLevels(priceData) {
            const keyLevels = [];
            const windowSize = Math.min(20, Math.floor(priceData.length / 10));
            
            // 使用滑动窗口寻找关键价位
            for (let i = windowSize; i < priceData.length - windowSize; i++) {
                const currentPrice = priceData[i].close;
                let isKeyLevel = true;
                
                // 检查是否为局部极值
                for (let j = i - windowSize; j <= i + windowSize; j++) {
                    if (j !== i && Math.abs(priceData[j].close - currentPrice) < currentPrice * 0.01) {
                        isKeyLevel = false;
                        break;
                    }
                }
                
                if (isKeyLevel) {
                    keyLevels.push({
                        price: currentPrice,
                        timestamp: priceData[i].timestamp,
                        strength: calculateKeyLevelStrength(priceData, i, windowSize)
                    });
                }
            }
            
            return keyLevels;
        }

        // 计算趋势动能
        function calculateTrendMomentum(priceData, index) {
            if (index < 5) return 0;
            
            const currentPrice = priceData[index].close;
            const pastPrice = priceData[index - 5].close;
            const priceChange = (currentPrice - pastPrice) / pastPrice;
            
            // 考虑成交量权重
            const volumeWeight = priceData[index].volume || 1;
            const avgVolume = calculateAverageVolume(priceData, index, 10);
            const volumeRatio = volumeWeight / avgVolume;
            
            return priceChange * volumeRatio;
        }

        // 计算关键位引力
        function calculateKeyLevelAttraction(currentPrice, keyLevels) {
            let totalAttraction = 0;
            
            for (const keyLevel of keyLevels) {
                const distance = Math.abs(currentPrice - keyLevel.price) / keyLevel.price;
                const attraction = keyLevel.strength / (1 + distance * 10); // 距离越近引力越强
                totalAttraction += attraction;
            }
            
            return totalAttraction;
        }

        // 计算势能梯度阈值
        function calculateGradientThreshold(gradients) {
            const gradientValues = gradients.map(g => Math.abs(g.gradient));
            const mean = gradientValues.reduce((a, b) => a + b, 0) / gradientValues.length;
            const variance = gradientValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / gradientValues.length;
            const stdDev = Math.sqrt(variance);
            
            return mean + 0.5 * stdDev; // 降低阈值，从2倍标准差改为0.5倍
        }

        // 生成交易信号
        function generateTradingSignals(gradients, threshold) {
            const signals = [];
            
            for (let i = 0; i < gradients.length; i++) {
                const gradient = gradients[i].gradient;
                
                if (gradient > threshold) {
                    signals.push({
                        timestamp: gradients[i].timestamp,
                        type: 'BUY',
                        strength: gradient / threshold,
                        signal: '多头突破'
                    });
                } else if (gradient < -threshold) {
                    signals.push({
                        timestamp: gradients[i].timestamp,
                        type: 'SELL',
                        strength: Math.abs(gradient) / threshold,
                        signal: '空头突破'
                    });
                }
            }
            
            return signals;
        }

        // 计算统计信息
        function calculateMomentumFieldStatistics(results) {
            const potentialEnergies = results.potentialEnergy.map(p => p.potentialEnergy);
            const gradients = results.gradient.map(g => g.gradient);
            
            return {
                avgPotentialEnergy: potentialEnergies.reduce((a, b) => a + b, 0) / potentialEnergies.length,
                maxPotentialEnergy: Math.max(...potentialEnergies),
                minPotentialEnergy: Math.min(...potentialEnergies),
                avgGradient: gradients.reduce((a, b) => a + b, 0) / gradients.length,
                maxGradient: Math.max(...gradients),
                minGradient: Math.min(...gradients),
                signalCount: results.signals.length,
                buySignals: results.signals.filter(s => s.type === 'BUY').length,
                sellSignals: results.signals.filter(s => s.type === 'SELL').length
            };
        }

        // 生成模拟数据
        function generateMockMomentumFieldData(symbol, timeframe) {
            const data = [];
            const now = Date.now();
            const interval = getTimeframeInterval(timeframe);
            let price = 100; // 起始价格
            
            for (let i = 0; i < 500; i++) {
                const timestamp = now - (500 - i) * interval;
                const change = (Math.random() - 0.5) * 0.02; // ±1%随机变化
                price = price * (1 + change);
                
                data.push({
                    timestamp: timestamp,
                    open: price * (1 + (Math.random() - 0.5) * 0.001),
                    high: price * (1 + Math.random() * 0.01),
                    low: price * (1 - Math.random() * 0.01),
                    close: price,
                    volume: Math.random() * 1000000
                });
            }
            
            return data;
        }

        // 获取时间周期间隔
        function getTimeframeInterval(timeframe) {
            const intervals = {
                '5m': 5 * 60 * 1000,
                '15m': 15 * 60 * 1000,
                '1h': 60 * 60 * 1000,
                '4h': 4 * 60 * 60 * 1000
            };
            return intervals[timeframe] || 60 * 60 * 1000;
        }

        // 计算平均成交量
        function calculateAverageVolume(priceData, index, window) {
            const start = Math.max(0, index - window);
            const end = Math.min(priceData.length, index + 1);
            let totalVolume = 0;
            let count = 0;
            
            for (let i = start; i < end; i++) {
                totalVolume += priceData[i].volume || 0;
                count++;
            }
            
            return count > 0 ? totalVolume / count : 1;
        }

        // 计算关键位强度
        function calculateKeyLevelStrength(priceData, index, windowSize) {
            let volumeSum = 0;
            let count = 0;
            
            for (let i = Math.max(0, index - windowSize); i <= Math.min(priceData.length - 1, index + windowSize); i++) {
                volumeSum += priceData[i].volume || 0;
                count++;
            }
            
            return count > 0 ? volumeSum / count : 1;
        }

        // 显示势能场结果
        function displayMomentumFieldResults(results) {
            const resultsDiv = document.getElementById('momentumFieldResults');
            const stats = results.statistics;
            
            resultsDiv.innerHTML = `
                <div class="info-box">
                    <h4>势能场分析结果</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>平均势能:</strong> ${stats.avgPotentialEnergy.toFixed(4)}
                        </div>
                        <div class="stat-item">
                            <strong>最大势能:</strong> ${stats.maxPotentialEnergy.toFixed(4)}
                        </div>
                        <div class="stat-item">
                            <strong>平均梯度:</strong> ${stats.avgGradient.toFixed(4)}
                        </div>
                        <div class="stat-item">
                            <strong>信号总数:</strong> ${stats.signalCount}
                        </div>
                        <div class="stat-item">
                            <strong>多头信号:</strong> ${stats.buySignals}
                        </div>
                        <div class="stat-item">
                            <strong>空头信号:</strong> ${stats.sellSignals}
                        </div>
                    </div>
                </div>
                <div class="signals-container">
                    <h4>交易信号</h4>
                    <div class="signals-list">
                        ${results.signals.slice(-10).map(signal => `
                            <div class="signal-item ${signal.type.toLowerCase()}">
                                <span class="signal-time">${new Date(signal.timestamp).toLocaleString()}</span>
                                <span class="signal-type">${signal.signal}</span>
                                <span class="signal-strength">强度: ${signal.strength.toFixed(2)}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // 显示回测结果
        function displayMomentumFieldBacktestResults(results) {
            const resultsDiv = document.getElementById('momentumFieldResults');
            
            resultsDiv.innerHTML = `
                <div class="info-box">
                    <h4>回测结果</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>总收益率:</strong> ${results.totalReturn.toFixed(2)}%
                        </div>
                        <div class="stat-item">
                            <strong>胜率:</strong> ${results.winRate.toFixed(2)}%
                        </div>
                        <div class="stat-item">
                            <strong>最大回撤:</strong> ${results.maxDrawdown.toFixed(2)}%
                        </div>
                        <div class="stat-item">
                            <strong>夏普比率:</strong> ${results.sharpeRatio.toFixed(2)}
                        </div>
                        <div class="stat-item">
                            <strong>交易次数:</strong> ${results.totalTrades}
                        </div>
                        <div class="stat-item">
                            <strong>平均持仓时间:</strong> ${results.avgHoldTime.toFixed(1)}小时
                        </div>
                    </div>
                </div>
            `;
        }

        // 绘制势能场图表
        function drawMomentumFieldChart(priceData, results) {
            // 使用Chart.js绘制图表
            const ctx = document.getElementById('momentumFieldChart').getContext('2d');
            
            if (momentumFieldChart) {
                momentumFieldChart.destroy();
            }
            
            const chartData = {
                labels: priceData.map(d => new Date(d.timestamp).toLocaleString()),
                datasets: [
                    {
                        label: '价格',
                        data: priceData.map(d => d.close),
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        yAxisID: 'y'
                    },
                    {
                        label: '势能',
                        data: results.potentialEnergy.map(p => p.potentialEnergy),
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        yAxisID: 'y1'
                    }
                ]
            };
            
            momentumFieldChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: '价格'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '势能'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        // 运行回测分析
        function runMomentumFieldBacktestAnalysis(priceData, alpha, beta) {
            const results = calculateMomentumField(priceData, alpha, beta);
            
            // 模拟交易
            let balance = 10000; // 初始资金
            let position = 0; // 持仓
            let trades = [];
            let maxBalance = balance;
            let maxDrawdown = 0;
            
            for (const signal of results.signals) {
                const signalIndex = priceData.findIndex(d => d.timestamp === signal.timestamp);
                if (signalIndex === -1) continue;
                
                const price = priceData[signalIndex].close;
                
                if (signal.type === 'BUY' && position <= 0) {
                    // 买入
                    if (position < 0) {
                        // 平空
                        const pnl = (trades[trades.length - 1].price - price) / trades[trades.length - 1].price;
                        balance += balance * pnl;
                    }
                    
                    position = 1;
                    trades.push({
                        type: 'BUY',
                        price: price,
                        timestamp: signal.timestamp,
                        balance: balance
                    });
                } else if (signal.type === 'SELL' && position >= 0) {
                    // 卖出
                    if (position > 0) {
                        // 平多
                        const pnl = (price - trades[trades.length - 1].price) / trades[trades.length - 1].price;
                        balance += balance * pnl;
                    }
                    
                    position = -1;
                    trades.push({
                        type: 'SELL',
                        price: price,
                        timestamp: signal.timestamp,
                        balance: balance
                    });
                }
                
                // 更新最大回撤
                if (balance > maxBalance) {
                    maxBalance = balance;
                }
                const currentDrawdown = (maxBalance - balance) / maxBalance;
                if (currentDrawdown > maxDrawdown) {
                    maxDrawdown = currentDrawdown;
                }
            }
            
            // 计算最终结果
            const totalReturn = ((balance - 10000) / 10000) * 100;
            const winningTrades = trades.filter(t => t.balance > (trades[trades.length - 1]?.balance || 10000)).length;
            const winRate = trades.length > 0 ? (winningTrades / trades.length) * 100 : 0;
            const avgHoldTime = trades.length > 0 ? 24 : 0; // 简化计算
            
            return {
                totalReturn: totalReturn,
                winRate: winRate,
                maxDrawdown: maxDrawdown * 100,
                sharpeRatio: totalReturn / (maxDrawdown * 100 + 0.01),
                totalTrades: trades.length,
                avgHoldTime: avgHoldTime
            };
        }

        // 斐波概率预测相关函数
        let fibonacciProbChart = null;
        let fibonacciProbChartDown = null;

        // 斐波概率分析主函数
        async function runFibonacciProbabilityAnalysis() {
            try {
                const symbol = document.getElementById('fibProbSymbol').value;
                const timeframe = document.getElementById('fibProbTimeframe').value;
                const days = parseInt(document.getElementById('fibProbDays').value);

                showStatus(`开始分析 ${symbol} 的斐波概率预测...`, 'info');

                const response = await fetch('/fibonacci-prob/api/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        timeframe: timeframe,
                        days: days
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayFibonacciProbabilityResults(data.result);
                    drawFibonacciProbabilityChart(data.result);
                    if (data.result && data.result.down_probabilities) {
                        drawFibonacciDownProbabilityChart(data.result);
                    }
                    showStatus(`斐波概率分析完成`, 'success');
                } else {
                    showStatus(`分析失败: ${data.error}`, 'error');
                }

            } catch (error) {
                console.error('斐波概率分析错误:', error);
                showStatus(`斐波概率分析失败: ${error.message}`, 'error');
            }
        }

        // 批量斐波分析
        async function runBatchFibonacciAnalysis() {
            try {
                const timeframe = document.getElementById('fibProbTimeframe').value;
                const days = parseInt(document.getElementById('fibProbDays').value);

                showStatus(`开始批量分析前500币种的斐波概率...`, 'info');

                const response = await fetch('/fibonacci-prob/api/batch-analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbols: ['H', 'KGEN', 'BANK', 'LA', 'F', 'LIGHT'],
                        timeframe: timeframe,
                        days: days
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayBatchFibonacciResults(data.results);
                    showStatus(`批量分析完成，共分析 ${data.count} 个币种`, 'success');
                } else {
                    showStatus(`批量分析失败: ${data.error}`, 'error');
                }

            } catch (error) {
                console.error('批量斐波分析错误:', error);
                showStatus(`批量斐波分析失败: ${error.message}`, 'error');
            }
        }

        // 显示斐波概率结果
        function displayFibonacciProbabilityResults(result) {
            const resultsDiv = document.getElementById('fibonacciProbResults');
            
            let html = `
                <div class="info-box">
                    <h4>🎯 ${result.symbol} 斐波概率预测结果</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>分析周期:</strong> ${result.timeframe}
                        </div>
                        <div class="stat-item">
                            <strong>数据点数:</strong> ${result.data_points}
                        </div>
                        <div class="stat-item">
                            <strong>数据源:</strong> ${result.data_source || 'Unknown'}
                        </div>
                        <div class="stat-item">
                            <strong>请求符号:</strong> ${result.used_symbol || result.symbol}
                        </div>
                        <div class="stat-item">
                            <strong>历史高点:</strong> ${result.historical_high?.toFixed(6) || 'N/A'}
                        </div>
                        <div class="stat-item">
                            <strong>历史低点:</strong> ${result.historical_low?.toFixed(6) || 'N/A'}
                        </div>
                        <div class="stat-item">
                            <strong>假突破次数:</strong> ${result.fake_breakout_count || 0}
                        </div>
                        <div class="stat-item">
                            <strong>价格范围:</strong> ${((result.historical_high - result.historical_low) / result.historical_low * 100).toFixed(1)}%
                        </div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>📈 指标快照（ATR / RSI / ADX / +DI / -DI）</h4>
                    <div class="stats-grid">
                        ${(() => {
                            const ind = (result.analysis_results && result.analysis_results.indicators) ? result.analysis_results.indicators : {};
                            const atr = (ind.atr_last ?? 0).toFixed(6);
                            const rsi = (ind.rsi_last ?? 50).toFixed(1);
                            const adx = (ind.adx_last ?? 0).toFixed(1);
                            const pdi = (ind.pdi_last ?? 0).toFixed(1);
                            const mdi = (ind.mdi_last ?? 0).toFixed(1);
                            const trend = (parseFloat(pdi) >= parseFloat(mdi)) ? '上行动能占优' : '下行动能占优';
                            return `
                                <div class="stat-item"><strong>ATR:</strong> ${atr}</div>
                                <div class="stat-item"><strong>RSI:</strong> ${rsi}</div>
                                <div class="stat-item"><strong>ADX:</strong> ${adx}</div>
                                <div class="stat-item"><strong>+DI:</strong> ${pdi}</div>
                                <div class="stat-item"><strong>-DI:</strong> ${mdi}</div>
                                <div class="stat-item"><strong>趋势判断:</strong> ${trend}</div>
                            `;
                        })()}
                    </div>
                </div>
                
                <div class="fibonacci-levels-info">
                    <h4>📊 斐波那契扩展位详情</h4>
                    <div class="fib-levels-detail-grid">
            `;

            // 显示每个斐波位点的详细信息
            for (const [level, probData] of Object.entries(result.probabilities)) {
                const probability = probData.probability;
                const price = probData.price;
                const factors = probData.factors;
                
                // 计算距离历史高点的百分比
                const distanceFromHigh = ((price - result.historical_high) / result.historical_high * 100).toFixed(1);
                
                // 根据概率设置颜色
                let probClass = 'low';
                let probText = '低概率';
                if (probability > 0.7) {
                    probClass = 'high';
                    probText = '高概率';
                } else if (probability > 0.4) {
                    probClass = 'medium';
                    probText = '中概率';
                }

                html += `
                    <div class="fib-level-detail-item ${probClass}">
                        <div class="fib-level-header">
                            <strong>${level}x 斐波位</strong>
                            <span class="probability-badge">${(probability * 100).toFixed(1)}%</span>
                        </div>
                        <div class="fib-level-details">
                            <div class="fib-price">价格: ${price.toFixed(6)}</div>
                            <div class="fib-distance">距离高点: ${distanceFromHigh}%</div>
                            <div class="fib-probability">概率: ${probText}</div>
                        </div>
                        <div class="fib-factors">
                            <div class="factor-item">
                                <span>速度因子:</span>
                                <span>${(factors.velocity_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>量能因子:</span>
                                <span>${(factors.volume_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>盘整因子:</span>
                                <span>${(factors.consolidation_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>假突破因子:</span>
                                <span>${(factors.fake_breakout_factor * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
                
                <div class="fibonacci-levels-container">
                    <h4>📊 斐波那契扩展位概率分析</h4>
                    <div class="fib-levels-grid">
            `;

            // 显示每个斐波位点的概率
            for (const [level, probData] of Object.entries(result.probabilities)) {
                const probability = probData.probability;
                const price = probData.price;
                const factors = probData.factors;
                
                // 根据概率设置颜色
                let probClass = 'low';
                let probText = '低概率';
                if (probability > 0.7) {
                    probClass = 'high';
                    probText = '高概率';
                } else if (probability > 0.4) {
                    probClass = 'medium';
                    probText = '中概率';
                }

                html += `
                    <div class="fib-level-item ${probClass}">
                        <div class="fib-level-header">
                            <strong>${level}x 斐波位</strong>
                            <span class="probability-badge">${(probability * 100).toFixed(1)}%</span>
                        </div>
                        <div class="fib-level-details">
                            <div class="fib-price">价格: ${price.toFixed(6)}</div>
                            <div class="fib-probability">概率: ${probText}</div>
                        </div>
                        <div class="fib-factors">
                            <div class="factor-item">
                                <span>速度因子:</span>
                                <span>${(factors.velocity_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>量能因子:</span>
                                <span>${(factors.volume_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>盘整因子:</span>
                                <span>${(factors.consolidation_factor * 100).toFixed(1)}%</span>
                            </div>
                            <div class="factor-item">
                                <span>假突破因子:</span>
                                <span>${(factors.fake_breakout_factor * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
                
                <div class="fibonacci-levels-container">
                    <h4>📉 下行斐波扩展位概率分析</h4>
                    <div class="fib-levels-grid">
            `;

            if (result.down_probabilities) {
                for (const [level, probData] of Object.entries(result.down_probabilities)) {
                    const probability = probData.probability;
                    const price = probData.price;
                    const factors = probData.factors || {};
                    let probClass = 'low';
                    let probText = '低概率';
                    if (probability > 0.7) { probClass = 'high'; probText = '高概率'; }
                    else if (probability > 0.4) { probClass = 'medium'; probText = '中概率'; }
                    html += `
                        <div class="fib-level-item ${probClass}">
                            <div class="fib-level-header">
                                <strong>${level}x 下行斐波位</strong>
                                <span class="probability-badge">${(probability * 100).toFixed(1)}%</span>
                            </div>
                            <div class="fib-level-details">
                                <div class="fib-price">价格: ${price.toFixed(6)}</div>
                                <div class="fib-probability">概率: ${probText}</div>
                            </div>
                            <div class="fib-factors">
                                <div class="factor-item"><span>速度因子:</span><span>${((factors.velocity_factor||0) * 100).toFixed(1)}%</span></div>
                                <div class="factor-item"><span>量能因子:</span><span>${((factors.volume_factor||0) * 100).toFixed(1)}%</span></div>
                                <div class="factor-item"><span>盘整因子:</span><span>${((factors.consolidation_factor||0) * 100).toFixed(1)}%</span></div>
                                <div class="factor-item"><span>假突破因子:</span><span>${((factors.fake_breakout_factor||0) * 100).toFixed(1)}%</span></div>
                            </div>
                        </div>
                    `;
                }
            } else {
                html += `<div class="info-box">无下行扩展位数据</div>`;
            }

            html += `
                    </div>
                </div>
            `;

            resultsDiv.innerHTML = html;
        }

        // 显示批量分析结果
        function displayBatchFibonacciResults(results) {
            const resultsDiv = document.getElementById('fibonacciProbResults');
            
            let html = `
                <div class="info-box">
                    <h4>📊 批量斐波概率分析结果</h4>
                    <p>共分析 ${results.length} 个币种</p>
                </div>
                
                <div class="batch-results-container">
                    <h4>🎯 各币种斐波概率汇总</h4>
                    <div class="batch-results-grid">
            `;

            for (const result of results) {
                html += `
                    <div class="batch-result-item">
                        <div class="batch-symbol">${result.symbol}</div>
                        <div class="batch-probabilities">
                `;

                for (const [level, probData] of Object.entries(result.probabilities)) {
                    const probability = probData.probability;
                    const probClass = probability > 0.7 ? 'high' : probability > 0.4 ? 'medium' : 'low';
                    
                    html += `
                        <div class="batch-prob-item ${probClass}">
                            <span>${level}x: ${(probability * 100).toFixed(1)}%</span>
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;

            resultsDiv.innerHTML = html;
        }

        // 绘制斐波概率图表
        function drawFibonacciProbabilityChart(result) {
            const ctx = document.getElementById('fibonacciProbChart').getContext('2d');
            
            if (fibonacciProbChart) {
                fibonacciProbChart.destroy();
            }

            // 准备图表数据
            const levels = Object.keys(result.probabilities);
            const probabilities = Object.values(result.probabilities).map(p => p.probability * 100);
            const prices = Object.values(result.probabilities).map(p => p.price);

            fibonacciProbChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: levels.map(l => `${l}x`),
                    datasets: [{
                        label: '突破概率 (%)',
                        data: probabilities,
                        backgroundColor: probabilities.map(p => {
                            if (p > 70) return 'rgba(76, 175, 80, 0.8)';
                            if (p > 40) return 'rgba(255, 193, 7, 0.8)';
                            return 'rgba(244, 67, 54, 0.8)';
                        }),
                        borderColor: probabilities.map(p => {
                            if (p > 70) return 'rgb(76, 175, 80)';
                            if (p > 40) return 'rgb(255, 193, 7)';
                            return 'rgb(244, 67, 54)';
                        }),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `${result.symbol} 斐波那契扩展位突破概率`
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '突破概率 (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '斐波那契扩展位'
                            }
                        }
                    }
                }
            });
        }

        // 绘制下行斐波概率图表
        function drawFibonacciDownProbabilityChart(result) {
            const container = document.getElementById('fibonacciProbChartDown');
            if (!container) return;
            const ctx = container.getContext('2d');
            if (fibonacciProbChartDown) {
                fibonacciProbChartDown.destroy();
            }
            if (!result.down_probabilities) return;
            const levels = Object.keys(result.down_probabilities);
            const probabilities = Object.values(result.down_probabilities).map(p => p.probability * 100);
            fibonacciProbChartDown = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: levels.map(l => `${l}x`),
                    datasets: [{
                        label: '向下突破概率 (%)',
                        data: probabilities,
                        backgroundColor: probabilities.map(p => {
                            if (p > 70) return 'rgba(76, 175, 80, 0.8)';
                            if (p > 40) return 'rgba(255, 193, 7, 0.8)';
                            return 'rgba(244, 67, 54, 0.8)';
                        }),
                        borderColor: probabilities.map(p => {
                            if (p > 70) return 'rgb(76, 175, 80)';
                            if (p > 40) return 'rgb(255, 193, 7)';
                            return 'rgb(244, 67, 54)';
                        }),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: `${result.symbol} 下行斐波扩展位突破概率` },
                        legend: { display: true }
                    },
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: '突破概率 (%)' } },
                        x: { title: { display: true, text: '下行斐波扩展位' } }
                    }
                }
            });
        }

        // 实时斐波分析相关函数
        let realtimeFibChart = null;
        let realtimeMonitoringInterval = null;

        // 实时斐波分析主函数
        async function runRealtimeFibonacciAnalysis() {
            try {
                const symbol = document.getElementById('realtimeSymbol').value;
                const timeframe = document.getElementById('realtimeTimeframe').value;
                const algo = document.getElementById('realtimeFibAlgo') ? document.getElementById('realtimeFibAlgo').value : 'cycle';
                const swing = {
                    lookback_days: parseInt(document.getElementById('realtimeFibLookback')?.value || '420'),
                    pivot: parseInt(document.getElementById('realtimeFibPivot')?.value || '10'),
                    min_separation_days: parseInt(document.getElementById('realtimeFibSep')?.value || '10'),
                    min_move_pct: parseFloat(document.getElementById('realtimeFibMinMove')?.value || '0.1'),
                    fallback_pivot: parseInt(document.getElementById('realtimeFibFallbackPivot')?.value || '5'),
                    orientation: (document.getElementById('fibOrientation')?.value || 'low_to_high'),
                };

                showStatus(`开始实时分析 ${symbol} 的斐波扩展位...`, 'info');

                const response = await fetch('/realtime-fib/api/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        timeframe: timeframe,
                        algo: algo,
                        swing: {
                            ...swing,
                            anchor: {
                                high_date: document.getElementById('fibAnchorHighDate')?.value || null,
                                high_price: (function(){ const v=document.getElementById('fibAnchorHighPrice')?.value; return v===''? null: parseFloat(v); })(),
                                low_date: document.getElementById('fibAnchorLowDate')?.value || null,
                                low_price: (function(){ const v=document.getElementById('fibAnchorLowPrice')?.value; return v===''? null: parseFloat(v); })(),
                            }
                        },
                        include_series: true
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayRealtimeFibonacciResults(data.result);
                    drawRealtimeFibonacciChart(data.result);
                    showStatus(`实时斐波分析完成`, 'success');
                } else {
                    showStatus(`分析失败: ${data.error}`, 'error');
                }

            } catch (error) {
                console.error('实时斐波分析错误:', error);
                showStatus(`实时斐波分析失败: ${error.message}`, 'error');
            }
        }

        // 取消实时监控：该功能已关闭，保持图表稳定
        function startRealtimeMonitoring() { showStatus('实时监控已关闭（图表保持稳定）', 'info'); }

        // 显示实时斐波分析结果
        function displayRealtimeFibonacciResults(result) {
            const resultsDiv = document.getElementById('realtimeFibResults');
            
            const cp = Number(result.current_price || 0);
            const rLow = Number(result.recent_low || 0);
            const rHigh = Number(result.recent_high || 0);
            let html = `
                <div class="info-box">
                    <h4>⚡ ${result.symbol} 实时斐波分析</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>当前价格:</strong> ${cp ? cp.toFixed(6) : '-'}
                        </div>
                        <div class="stat-item">
                            <strong>最近高点:</strong> ${rHigh ? rHigh.toFixed(6) : '-'}
                        </div>
                        <div class="stat-item">
                            <strong>最近低点:</strong> ${rLow ? rLow.toFixed(6) : '-'}
                        </div>
                    </div>
                </div>
            `;

            // 显示当前斐波位置
            if (result.position) {
                const pos = result.position;
                html += `
                    <div class="fib-position-container">
                        <h4>📍 当前斐波位置</h4>
                        <div class="fib-position-info">
                            <div class="position-item">
                                <strong>当前比例:</strong> ${(Number(pos.ratio || 0)).toFixed(3)}
                            </div>
                            <div class="position-item">
                                <strong>最近位点:</strong> ${(Number(pos.nearest_level || 0)).toFixed(3)}
                            </div>
                            <div class="position-item">
                                <strong>位点价格:</strong> ${pos.nearest_price ? Number(pos.nearest_price).toFixed(6) : '-'}
                            </div>
                        </div>
                    </div>
                `;

                // 简化显示：只展示最近位点，不展示上下方列表
            }

            // 显示近期变化分析
            if (result.recent_analysis) {
                const recent = result.recent_analysis;
                html += `
                    <div class="recent-analysis-container">
                        <h4>📊 近期变化分析 (${recent.time_hours.toFixed(1)}小时)</h4>
                        <div class="recent-stats-grid">
                            <div class="stat-item">
                                <strong>价格变化:</strong> ${(recent.price_change * 100).toFixed(2)}%
                            </div>
                            <div class="stat-item">
                                <strong>变化速度:</strong> ${(recent.price_velocity * 100).toFixed(2)}%/小时
                            </div>
                            <div class="stat-item">
                                <strong>量能波动:</strong> ${(recent.volume_volatility * 100).toFixed(1)}%
                            </div>
                            <div class="stat-item">
                                <strong>多空比例:</strong> ${(recent.bullish_ratio * 100).toFixed(1)}% 多头
                            </div>
                            <div class="stat-item">
                                <strong>多头强度:</strong> ${recent.bullish_strength.toFixed(0)}
                            </div>
                            <div class="stat-item">
                                <strong>空头强度:</strong> ${recent.bearish_strength.toFixed(0)}
                            </div>
                        </div>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;
        }

        // 绘制实时斐波图表
        function drawRealtimeFibonacciChart(result) {
            const ctx = document.getElementById('realtimeFibChart').getContext('2d');
            if (realtimeFibChart) realtimeFibChart.destroy();

            const series = Array.isArray(result.series) ? result.series : [];
            const labels = series.map(p => new Date(p.t).toLocaleDateString());
            const closes = series.map(p => p.close);

            // 斐波位水平线作为多条 line 数据集
            const fibDatasets = [];
            const levels = Object.keys(result.fib_levels).map(parseFloat).sort((a,b)=>a-b);
            for (const lv of levels) {
                const y = result.fib_levels[lv];
                fibDatasets.push({
                    type: 'line',
                    label: `${lv}`,
                    data: Array(labels.length).fill(y),
                    borderColor: 'rgba(200,200,200,0.35)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: false,
                    borderDash: lv===0.5?[]:[5,5]
                });
            }

            // 当前价格线
            const cp = Number(result.current_price || 0);
            if (cp) {
                fibDatasets.push({
                    type: 'line',
                    label: '当前价格',
                    data: Array(labels.length).fill(cp),
                    borderColor: 'rgba(76,175,80,0.8)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false
                });
            }

            // K线替代：收盘价折线（无需额外插件）
            const priceLine = {
                type: 'line',
                label: '收盘价',
                data: closes,
                borderColor: 'rgba(52,152,219,0.9)',
                borderWidth: 1.5,
                pointRadius: 0,
                fill: false
            };

            // 右侧文字标签插件（显示各斐波位的价格和标签）
            const rightLabelPlugin = {
                id: 'rightLabels',
                afterDraw(chart, args, opts) {
                    const {ctx, scales} = chart;
                    const yScale = scales.y;
                    ctx.save();
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#ccc';
                    for (const lv of levels) {
                        const y = result.fib_levels[lv];
                        const py = yScale.getPixelForValue(y);
                        const text = `${lv} (${Number(y).toFixed(2)})`;
                        ctx.fillText(text, chart.chartArea.right - 4, py - 2);
                    }
                    // 当前价格
                    if (cp) {
                        const py = yScale.getPixelForValue(cp);
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText(`P (${cp.toFixed(2)})`, chart.chartArea.right - 4, py - 2);
                    }
                    ctx.restore();
                }
            };
            // Swing标记
            const swingMarkers = {
                id: 'swingMarkers',
                afterDraw(chart){
                    if (!result.recent_low_ts || !result.recent_high_ts) return;
                    const {ctx, chartArea, scales} = chart; const xScale = scales.x; const yScale = scales.y;
                    const labelsArr = labels;
                    function idxByTs(ts){
                        const dstr = new Date(ts).toLocaleDateString();
                        let idx = labelsArr.indexOf(dstr);
                        if (idx >= 0) return idx;
                        let best=0,bestDiff=1e18; for (let i=0;i<labelsArr.length;i++){ const diff=Math.abs(new Date(labelsArr[i]).getTime()-ts); if(diff<bestDiff){best=i;bestDiff=diff;} } return best;
                    }
                    function drawMarker(ts, price, color, text){
                        const idx = idxByTs(ts); const x = xScale.getPixelForValue(labelsArr[idx]); const y = yScale.getPixelForValue(price);
                        ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x, chartArea.top); ctx.lineTo(x, chartArea.bottom); ctx.stroke(); ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.font='12px sans-serif'; ctx.textAlign='left'; ctx.fillStyle='#fff'; ctx.fillText(text, x+6, y-6); ctx.restore();
                    }
                    drawMarker(result.recent_low_ts, result.recent_low, '#f1c40f', `低点(0) ${new Date(result.recent_low_ts).toLocaleDateString()} ${Number(result.recent_low).toFixed(2)}`);
                    drawMarker(result.recent_high_ts, result.recent_high, '#e74c3c', `高点(1) ${new Date(result.recent_high_ts).toLocaleDateString()} ${Number(result.recent_high).toFixed(2)}`);
                }
            };

            realtimeFibChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [priceLine, ...fibDatasets]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: `${result.symbol} 斐波图表` },
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: true },
                        y: { display: true }
                    }
                },
                plugins: [rightLabelPlugin, swingMarkers]
            });
        }
        function exportFibChartPng(){
            const canvas = document.getElementById('realtimeFibChart');
            try {
                const url = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url; a.download = `${document.getElementById('realtimeSymbol').value}_${document.getElementById('realtimeTimeframe').value}_fib.png`;
                document.body.appendChild(a); a.click(); a.remove();
            } catch (e){ console.error('导出失败', e); }
        }

        // ======= 实时斐波 扫描列表 =======
        let realtimeFibQuery = { page: 1, totalPages: 1 };

        function readRealtimeFibQueryFromUI() {
            const sort = document.getElementById('realtimeFibSort').value;
            const [sort_by, sort_dir] = sort.split('-');
            return {
                source: document.getElementById('realtimeFibSource').value,
                limit: parseInt(document.getElementById('realtimeFibLimit').value) || 1000,
                timeframe: document.getElementById('realtimeFibScanTf').value,
                only_extension: document.getElementById('realtimeFibOnlyExt').checked,
                min_ratio: (function(){ const v = document.getElementById('realtimeFibMinRatio').value; return v === '' ? null : parseFloat(v); })(),
                sort_by, sort_dir,
                page: 1,
                page_size: parseInt(document.getElementById('realtimeFibPageSize').value) || 50,
                algo: (document.getElementById('realtimeFibAlgo')?.value || 'cycle'),
                swing: {
                    lookback_days: parseInt(document.getElementById('realtimeFibLookback')?.value || '420'),
                    pivot: parseInt(document.getElementById('realtimeFibPivot')?.value || '10'),
                    min_separation_days: parseInt(document.getElementById('realtimeFibSep')?.value || '10'),
                    min_move_pct: parseFloat(document.getElementById('realtimeFibMinMove')?.value || '0.1'),
                    fallback_pivot: parseInt(document.getElementById('realtimeFibFallbackPivot')?.value || '5'),
                },
                max_workers: parseInt(document.getElementById('realtimeFibMaxWorkers')?.value || '8'),
                batch_size: parseInt(document.getElementById('realtimeFibBatchSize')?.value || '50'),
                throttle_sec: parseFloat(document.getElementById('realtimeFibThrottle')?.value || '0.2'),
            };
        }

        async function scanRealtimeFibList() {
            try {
                realtimeFibQuery = readRealtimeFibQueryFromUI();
                showStatus(`开始扫描 ${realtimeFibQuery.source.toUpperCase()} 前 ${realtimeFibQuery.limit} 个交易对...`, 'info');
                const resp = await fetch('/realtime-fib/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(realtimeFibQuery)
                });
                const data = await resp.json();
                if (!data.success) {
                    showStatus('扫描失败: ' + (data.error || '未知错误'), 'error');
                    return;
                }
                realtimeFibQuery.page = data.pagination?.page || 1;
                realtimeFibQuery.page_size = data.pagination?.page_size || realtimeFibQuery.page_size;
                realtimeFibQuery.totalPages = data.pagination?.total_pages || 1;
                renderRealtimeFibList(data.rows, data.source, data.timeframe);
                updateRealtimeFibPager();
                showStatus(`扫描完成，共 ${data.total} 条`, 'success');
            } catch (e) {
                console.error('扫描失败', e);
                showStatus('扫描失败: ' + e.message, 'error');
            }
        }

        function updateRealtimeFibPager() {
            const el = document.getElementById('realtimeFibPageInfo');
            if (el) el.textContent = `第 ${realtimeFibQuery.page || 1} / ${realtimeFibQuery.totalPages || 1} 页`;
        }

        async function applyRealtimeFibSortFilter() {
            const q = readRealtimeFibQueryFromUI();
            realtimeFibQuery = q;
            await scanRealtimeFibGoToPage(1);
        }

        async function scanRealtimeFibGoToPage(page) {
            try {
                realtimeFibQuery.page = Math.max(1, page);
                const resp = await fetch('/realtime-fib/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(realtimeFibQuery)
                });
                const data = await resp.json();
                if (!data.success) return;
                realtimeFibQuery.page = data.pagination?.page || realtimeFibQuery.page;
                realtimeFibQuery.totalPages = data.pagination?.total_pages || 1;
                renderRealtimeFibList(data.rows, data.source, data.timeframe);
                updateRealtimeFibPager();
            } catch (e) {
                showStatus('分页加载失败: ' + e.message, 'error');
            }
        }

        function realtimeFibPrevPage() { if ((realtimeFibQuery.page || 1) > 1) scanRealtimeFibGoToPage((realtimeFibQuery.page || 1) - 1); }
        function realtimeFibNextPage() { scanRealtimeFibGoToPage((realtimeFibQuery.page || 1) + 1); }

        function renderRealtimeFibList(rows, source, timeframe) {
            const el = document.getElementById('realtimeFibList');
            if (!rows || rows.length === 0) {
                el.innerHTML = '<p>暂无数据</p>';
                return;
            }
            let html = `
                <table class="results-table">
                  <thead>
                    <tr>
                      <th>交易对</th>
                      <th>趋势</th>
                      <th>当前价格</th>
                      <th>最近低点</th>
                      <th>最近高点</th>
                      <th>斐波比例</th>
                      <th>最近位点</th>
                      <th>位点价格</th>
                    </tr>
                  </thead>
                  <tbody>
            `;
            for (const r of rows.slice(0, 1000)) {
                const ratio = (r.ratio !== null && r.ratio !== undefined) ? Number(r.ratio).toFixed(3) : '-';
                const near = (r.nearest_level !== null && r.nearest_level !== undefined) ? Number(r.nearest_level).toFixed(3) : '-';
                const nearPrice = (r.nearest_price !== null && r.nearest_price !== undefined) ? Number(r.nearest_price).toFixed(6) : '-';
                html += `
                  <tr>
                    <td>${r.symbol}</td>
                    <td>${r.trend || '-'}</td>
                    <td>${Number(r.current_price).toFixed(6)}</td>
                    <td>${Number(r.recent_low).toFixed(6)}</td>
                    <td>${Number(r.recent_high).toFixed(6)}</td>
                    <td>${ratio}</td>
                    <td>${near}</td>
                    <td>${nearPrice}</td>
                  </tr>`;
            }
            html += '</tbody></table>';
            el.innerHTML = html;
        }
        
        function toggleVideoBackground() {
            showStatus('切换背景模式', 'info');
        }
        
        function toggleBackground() {
            showStatus('开关背景', 'info');
        }
        
        function addNewSymbols() {
            showStatus('添加新币种', 'info');
        }
        
        // 详情查看函数
        function viewIntradayDetails(symbol) {
            showStatus(`查看${symbol}日内详情`, 'info');
        }
        
        function showChart(symbol) {
            showStatus(`显示${symbol}图表`, 'info');
        }
        
        function showUltraShortDetails(symbol) {
            showStatus(`查看${symbol}超短详情`, 'info');
        }
        
        function showMultiTimeframeDetails(symbol, timeframe) {
            showStatus(`查看${symbol} ${timeframe}多时间框架详情`, 'info');
        }
        
        function showSignalDetails(symbol, timeframe, condition, description) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h3>信号详情 - ${symbol} (${timeframe})</h3>
                    <div class="signal-details">
                        <div class="detail-item">
                            <strong>信号条件:</strong>
                            <p>${condition}</p>
                        </div>
                        <div class="detail-item">
                            <strong>详细描述:</strong>
                            <p>${description}</p>
                        </div>
                        <div class="detail-item">
                            <strong>币种:</strong> ${symbol}
                        </div>
                        <div class="detail-item">
                            <strong>时间框架:</strong> ${timeframe}
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">关闭</button>
                    </div>
                </div>
            `;
            
            // 添加样式
            const style = document.createElement('style');
            style.textContent = `
                .signal-details {
                    margin: 20px 0;
                }
                .detail-item {
                    margin: 15px 0;
                    padding: 10px;
                    background: #f8f9fa;
                    border-radius: 5px;
                }
                .detail-item strong {
                    color: #007bff;
                }
                .detail-item p {
                    margin: 5px 0 0 0;
                    color: #333;
                    line-height: 1.5;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(modal);
            
            // 点击模态框外部关闭
            modal.onclick = function(e) {
                if (e.target === modal) {
                    modal.remove();
                    style.remove();
                }
            };
        }
        
        // 【修复超时问题】渐进式分析 + 信号缓存
        let allCachedSignals = [];
        let analysisProgress = {
            total: 0,
            analyzed: 0,
            isAnalyzing: false
        };
        
        // 多时间框架分页相关函数
        async function analyzeCurrentPage(strategyType = 'original') {
            if (typeof allSymbols === 'undefined' || allSymbols.length === 0) {
                showStatus('请先获取币种列表', 'error');
                return;
            }
            
            try {
                const signalsPerPage = 50; // 每页显示50个信号
                
                // 如果还没有开始分析，启动渐进式分析
                if (!analysisProgress.isAnalyzing && analysisProgress.analyzed === 0) {
                    await startProgressiveAnalysis(strategyType);
                }
                
                // 从缓存中获取当前页的信号
                displayCurrentPageSignals(signalsPerPage);
                
            } catch (error) {
                console.error('analyzeCurrentPage error:', error);
                handleAnalysisError(error);
            }
        }
        
        // 渐进式分析函数
        async function startProgressiveAnalysis(strategyType = 'original') {
            analysisProgress.isAnalyzing = true;
            analysisProgress.total = allSymbols.length;
            analysisProgress.analyzed = 0;
            allCachedSignals = [];
            
            const batchSize = 20; // 每批分析20个币种
            const totalBatches = Math.ceil(allSymbols.length / batchSize);
            
            showStatus(`开始渐进式分析 ${allSymbols.length} 个币种...`, 'info');
            
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * batchSize;
                const endIdx = Math.min(startIdx + batchSize, allSymbols.length);
                const batchSymbols = allSymbols.slice(startIdx, endIdx);
                
                showStatus(`正在分析第${batchIndex + 1}/${totalBatches}批币种 (${startIdx + 1}-${endIdx})...`, 'info');
                
                try {
                    const response = await safeFetch('/multi_timeframe/analyze_multiple_symbols', {
                        method: 'POST',
                        body: JSON.stringify({
                            symbols: batchSymbols,
                            page: 1,
                            page_size: 999999, // 获取这批币种的所有信号
                            strategy_type: strategyType
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // 将新信号添加到缓存中
                        const newSignals = data.signals || [];
                        allCachedSignals = allCachedSignals.concat(newSignals);
                        analysisProgress.analyzed = endIdx;
                        
                        // 更新进度
                        const progress = Math.round((analysisProgress.analyzed / analysisProgress.total) * 100);
                        console.log(`批次 ${batchIndex + 1} 完成，新增 ${newSignals.length} 个信号，总计 ${allCachedSignals.length} 个信号`);
                        
                        // 实时更新显示
                        updateTotalPagesAndDisplay();
                        
                        showStatus(`进度: ${progress}% (${analysisProgress.analyzed}/${analysisProgress.total}) - 已获得 ${allCachedSignals.length} 个信号`, 'info');
                        
                        // 添加短暂延迟避免API限制
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                    } else {
                        console.error(`批次 ${batchIndex + 1} 分析失败:`, data.error);
                        showStatus(`批次 ${batchIndex + 1} 分析失败: ${data.error}`, 'warning');
                    }
                    
                } catch (batchError) {
                    console.error(`批次 ${batchIndex + 1} 请求失败:`, batchError);
                    showStatus(`批次 ${batchIndex + 1} 请求失败: ${batchError.message}`, 'warning');
                }
            }
            
            analysisProgress.isAnalyzing = false;
            showStatus(`分析完成！总共生成 ${allCachedSignals.length} 个信号`, 'success');
            updateTotalPagesAndDisplay();
        }
        
        // 更新总页数并显示当前页
        function updateTotalPagesAndDisplay() {
            const signalsPerPage = 50;
            totalPages = Math.ceil(allCachedSignals.length / signalsPerPage);
            updatePaginationControls();
            displayCurrentPageSignals(signalsPerPage);
        }
        
        // 显示当前页信号
        function displayCurrentPageSignals(signalsPerPage) {
            const startIdx = (currentPage - 1) * signalsPerPage;
            const endIdx = startIdx + signalsPerPage;
            const pageSignals = allCachedSignals.slice(startIdx, endIdx);
            
            console.log(`显示信号范围: ${startIdx}-${endIdx}, 共${pageSignals.length}个信号`);
            
            // 【修复】统一分页逻辑，直接更新表格显示
            updateSignalDisplay(pageSignals);
            
            if (pageSignals.length > 0) {
                showStatus(`第${currentPage}页显示完成: 显示${pageSignals.length}个信号 (总计${allCachedSignals.length}个信号)`, 'success');
            }
        }
        
        // 【新增】统一的信号显示函数
        function updateSignalDisplay(signals) {
            const tbody = document.getElementById('multiTimeframeSignalsTableBody');
            if (!tbody) return;
            
            if (!signals || signals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #666;">当前页暂无信号</td></tr>';
                return;
            }
            
            let html = '';
            signals.forEach((signal, index) => {
                const rowClass = signal.signal_type === 'long' ? 'signal-long' : 'signal-short';
                const profitClass = signal.profit_pct >= 0 ? 'profit-positive' : 'profit-negative';
                
                html += `
                    <tr class="${rowClass}">
                        <td>${signal.symbol}</td>
                        <td>${signal.timeframe}</td>
                        <td class="trend-${signal.trend}">${signal.trend}</td>
                        <td class="signal-type-${signal.signal_type}">${signal.signal_type}</td>
                        <td>${parseFloat(signal.entry_price).toFixed(6)}</td>
                        <td>${signal.take_profit > 0 ? parseFloat(signal.take_profit).toFixed(6) : 'N/A'}</td>
                        <td class="${profitClass}">${signal.profit_pct.toFixed(2)}%</td>
                        <td>${signal.signal_time}</td>
                        <td class="condition-cell" title="${signal.description || '无描述'}">${signal.condition}</td>
                        <td class="actions">
                            <button class="btn-detail" onclick="showSignalDetails('${signal.symbol}', '${signal.timeframe}', '${signal.condition}', '${signal.description || ''}')">详情</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }
        
        // 处理分析错误
        function handleAnalysisError(error) {
            let errorMessage = error.message;
            if (error.message.includes('500')) {
                errorMessage = '服务器内部错误，已切换到渐进式分析模式';
            } else if (error.message.includes('timeout') || error.message.includes('超时')) {
                errorMessage = '请求超时，已优化为小批量分析';
            } else if (error.message.includes('port closed')) {
                errorMessage = '连接中断，请刷新页面重试';
            }
            
            showStatus(`分析失败: ${errorMessage}`, 'error');
        }
        
        function updatePaginationControls() {
            const paginationControls = document.getElementById('paginationControls');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (paginationControls) {
                paginationControls.style.display = 'block';
            }
            
            if (pageInfo) {
                pageInfo.textContent = `第${currentPage}页，共${totalPages}页 (${allCachedSignals.length}个信号)`;
            }
            
            if (prevBtn) {
                prevBtn.disabled = currentPage <= 1;
            }
            
            if (nextBtn) {
                nextBtn.disabled = currentPage >= totalPages;
            }
        }
        
        function showMultiTimeframeSignals(signals, minProfit = 0) {
            const resultsDiv = document.getElementById('multiTimeframeResults');
            if (!resultsDiv) return;
            
            let filteredSignals = signals;
            if (minProfit > 0) {
                filteredSignals = signals.filter(signal => 
                    signal.profit_pct >= minProfit
                );
            }
            
            if (filteredSignals.length === 0) {
                resultsDiv.innerHTML = '<p>暂无符合条件的信号</p>';
                return;
            }
            
            let html = '<h4>多时间框架信号:</h4>';
            html += '<table class="table"><tr><th>币种</th><th>时间框架</th><th>信号类型</th><th>收益率</th><th>入场价格</th><th>止盈价格</th></tr>';
            
            filteredSignals.forEach(signal => {
                const profitClass = signal.profit_pct >= 0 ? 'success' : 'error';
                html += `<tr>
                    <td>${signal.symbol}</td>
                    <td>${signal.timeframe}</td>
                    <td>${signal.signal_type}</td>
                    <td class="${profitClass}">${signal.profit_pct}%</td>
                    <td>${signal.entry_price}</td>
                    <td>${signal.take_profit_price || 'N/A'}</td>
                </tr>`;
            });
            
            html += '</table>';
            resultsDiv.innerHTML = html;
        }
    </script>
    <script>
    // K线绘制（内嵌）逻辑，封装到 KLINE 命名空间，避免与现有脚本冲突
    window.KLINE = (function(){
      let chart, series;
      let supports = [], resistances = [], sLabels = [], rLabels = [];
      let linesS = [], linesR = [];
      let autoTimer = null;
      let drag = { on:false, kind:null, idx:-1, last:0 };
      let dragTip;

      function el(id){ return document.getElementById(id); }
      function status(msg, type){ const s = el('kd_status'); if(!s) return; s.textContent = msg; s.style.color = (type==='error'?'#ef4444':'#9aa1b2'); }
      function fmt(v){ v=Number(v); if(!isFinite(v)) return ''; if(v>=100) return v.toFixed(2); if(v>=1) return v.toFixed(4); if(v>=0.01) return v.toFixed(6); return v.toFixed(8); }
      function snap(v){ const x=Math.abs(v); let step=0.0001; if(x>=10000) step=5; else if(x>=1000) step=1; else if(x>=100) step=0.5; else if(x>=10) step=0.1; else if(x>=1) step=0.01; else if(x>=0.1) step=0.001; return Math.round(v/step)*step; }
      function sortDedup(kind){ const eps=1e-8; if(kind==='support'){ let pairs=supports.map((p,i)=>({p,label:sLabels[i]||''})).sort((a,b)=>a.p-b.p); const out=[],labs=[]; pairs.forEach(it=>{ if(out.length===0||Math.abs(it.p-out[out.length-1])>eps){ out.push(it.p); labs.push(it.label);} }); supports=out; sLabels=labs; } else { let pairs=resistances.map((p,i)=>({p,label:rLabels[i]||''})).sort((a,b)=>a.p-b.p); const out=[],labs=[]; pairs.forEach(it=>{ if(out.length===0||Math.abs(it.p-out[out.length-1])>eps){ out.push(it.p); labs.push(it.label);} }); resistances=out; rLabels=labs; } }

      function ensureChart(){ if(chart) return; if(!window.LightweightCharts){ status('K线库未加载', 'error'); return; } const box=el('kd_chart'); chart = LightweightCharts.createChart(box,{ layout:{background:{color:'#0f111a'},textColor:'#e5e5e5'}, crosshair:{mode:LightweightCharts.CrosshairMode.Normal}, rightPriceScale:{borderVisible:false}, timeScale:{borderVisible:false}, grid:{ vertLines:{color:'#1f2335'}, horzLines:{color:'#1f2335'} } }); series = chart.addCandlestickSeries({ upColor:'#26a69a', downColor:'#ef5350', wickUpColor:'#26a69a', wickDownColor:'#ef5350', borderVisible:false }); setTimeout(resize,0); if(window.ResizeObserver){ new ResizeObserver(resize).observe(box);} else { window.addEventListener('resize',resize);} chart.subscribeClick(param=>{ if(!param||!param.point) return; const mode=el('kd_clickMode').value; if(mode==='none') return; if(mode==='text'){ addAnnoAt(param.point.x, param.point.y, '双击编辑'); updateTemplateText(); return; } const price = series.coordinateToPrice(param.point.y); if(!price||isNaN(price)) return; addLevel(mode, price); });
        // 覆盖层：文本模式下拦截点击，确保可点击添加
        let overlay = box.querySelector('#kd_textOverlay');
        if(!overlay){ overlay = document.createElement('div'); overlay.id='kd_textOverlay'; overlay.style.cssText='position:absolute; inset:0; z-index:20; display:none; cursor:text; background:transparent;'; box.appendChild(overlay); overlay.addEventListener('click',(e)=>{ const mode=el('kd_clickMode').value; if(mode!=='text') return; const r=overlay.getBoundingClientRect(); const x=e.clientX - r.left; const y=e.clientY - r.top; addAnnoAt(x,y,'双击编辑'); updateTemplateText(); e.stopPropagation(); }); }
        // 兜底：容器点击也能添加文本（避免订阅只响应绘图区）
        box.addEventListener('click',(e)=>{ const mode=el('kd_clickMode').value; if(mode!=='text') return; if(e.target && e.target.classList && e.target.classList.contains('kd-anno')) return; const r=box.getBoundingClientRect(); const x=e.clientX - r.left; const y=e.clientY - r.top; addAnnoAt(x,y,'双击编辑'); updateTemplateText(); });
        dragTip = document.createElement('div'); dragTip.style.cssText='position:absolute;right:8px;padding:2px 6px;background:rgba(0,0,0,0.7);color:#fff;border-radius:4px;font-size:12px;pointer-events:none;display:none;'; box.appendChild(dragTip); // 备注可拖动标签
        const noteEl = document.createElement('div'); noteEl.id='kd_note'; noteEl.style.cssText='position:absolute; left:66%; top:24px; color:#fff; background:rgba(0,0,0,0.45); padding:4px 6px; border-radius:4px; font-size:12px; cursor:move;'; noteEl.textContent=''; noteEl.setAttribute('title','拖动以移动；双击以编辑'); box.appendChild(noteEl);
        // 拖动/编辑备注
        let noteDragging=false, noteDX=0, noteDY=0, noteEditedPos=false, noteEditing=false;
        noteEl.addEventListener('mousedown', (e)=>{ if(noteEditing) return; noteDragging=true; const rect=noteEl.getBoundingClientRect(); noteDX=e.clientX-rect.left; noteDY=e.clientY-rect.top; e.preventDefault(); });
        window.addEventListener('mousemove',(e)=>{ if(!noteDragging) return; const r=box.getBoundingClientRect(); const x=e.clientX - r.left - noteDX; const y=e.clientY - r.top - noteDY; noteEl.style.left = Math.max(4, Math.min(r.width-120, x)) + 'px'; noteEl.style.right='auto'; noteEl.style.top = Math.max(4, Math.min(r.height-28, y)) + 'px'; noteEditedPos=true; });
        window.addEventListener('mouseup',()=>{ noteDragging=false; });
        noteEl.addEventListener('dblclick',()=>{ noteEditing=true; noteEl.contentEditable='true'; noteEl.focus(); });
        noteEl.addEventListener('blur',()=>{ noteEl.contentEditable='false'; noteEditing=false; try{ el('kd_remarks').value = noteEl.textContent.trim(); updateTemplateText(); }catch(_){}});
        noteEl.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); noteEl.blur(); }});
        box.addEventListener('mousedown', (e)=>{ const y=e.clientY-box.getBoundingClientRect().top; const hit=hitTest(y); if(hit){ drag.on=true; drag.kind=hit.kind; drag.idx=hit.idx; e.preventDefault(); dragTip.style.display='block'; dragTip.style.top=(y-10)+'px'; }}); window.addEventListener('mousemove', (e)=>{ if(!drag.on) return; const now=performance.now(); if(now-drag.last<25) return; drag.last=now; const y=e.clientY-box.getBoundingClientRect().top; const p=series.coordinateToPrice(y); if(!p||isNaN(p)||p<=0) return; const v=snap(p); updateLine(drag.kind,drag.idx,v); dragTip.textContent=fmt(v); dragTip.style.top=(y-10)+'px'; }); window.addEventListener('mouseup', ()=>{ if(!drag.on) return; drag.on=false; sortDedup('support'); sortDedup('resistance'); renderLists(); applyLines(); dragTip.style.display='none'; }); }
      function updateNoteAnchor(){ try{ const box=el('kd_chart'); const noteEl=box.querySelector('#kd_note'); if(!noteEl) return; const note=(el('kd_remarks').value||'').trim(); noteEl.textContent=note; if(!note) { noteEl.style.display='none'; return; } noteEl.style.display='block'; if(noteEditedPos) return; // 用户已拖动则不再自动定位
        // 选取锚点：优先最高的阻力，其次最高的支撑
        let anchor=null; if(resistances.length>0) anchor=Math.max.apply(null,resistances); else if(supports.length>0) anchor=Math.max.apply(null,supports);
        const r=box.getBoundingClientRect(); const midRight = Math.floor(r.width*0.65);
        let y=null; if(anchor && typeof series.priceToCoordinate==='function'){ const yCss=series.priceToCoordinate(anchor); y = (yCss!=null)? Math.max(4, Math.min(r.height-28, yCss-22)) : null; }
        noteEl.style.left = (midRight) + 'px'; noteEl.style.right='auto'; noteEl.style.top = (y!=null? y : 24) + 'px';
      }catch(_){}}
      function resize(){ try{ if(!chart) return; const box=el('kd_chart'); const r=box.getBoundingClientRect(); const w=Math.max(300,Math.floor(r.width||box.clientWidth||0)); const h=Math.max(300,Math.floor(r.height||540)); chart.resize(w,h);}catch(_){}}
      function hitTest(y){ const tol=6; let best=null; supports.forEach((p,i)=>{ const py=series.priceToCoordinate(p); if(py==null) return; const d=Math.abs(py-y); if(d<=tol && (!best||d<best.d)) best={kind:'support',idx:i,d}; }); resistances.forEach((p,i)=>{ const py=series.priceToCoordinate(p); if(py==null) return; const d=Math.abs(py-y); if(d<=tol && (!best||d<best.d)) best={kind:'resistance',idx:i,d}; }); return best; }
      function clearLines(arr){ if(!series) return; arr.forEach(l=>{ try{ series.removePriceLine(l);}catch(_){}}); arr.length=0; }
      // ---- 多文本注释工具 ----
      let annos = []; let annoIdSeq = 1;
      function addAnnoAt(x,y,text){ const box=el('kd_chart'); const id=annoIdSeq++; const div=document.createElement('div'); div.className='kd-anno'; div.dataset.id=String(id); div.textContent=text||'双击编辑'; div.style.cssText='position:absolute; left:'+x+'px; top:'+y+'px; color:#fff; background:rgba(0,0,0,0.45); padding:4px 6px; border-radius:4px; font-size:12px; cursor:move; user-select:text;';
        const close=document.createElement('span'); close.textContent='×'; close.style.cssText='margin-left:6px; color:#ccc; cursor:pointer;'; close.onclick=(e)=>{ e.stopPropagation(); removeAnno(id); };
        div.appendChild(close);
        // drag
        let dragging=false, dx=0, dy=0; div.addEventListener('mousedown',(e)=>{ dragging=true; const r=div.getBoundingClientRect(); dx=e.clientX-r.left; dy=e.clientY-r.top; e.stopPropagation(); e.preventDefault(); });
        window.addEventListener('mousemove',(e)=>{ if(!dragging) return; const r=box.getBoundingClientRect(); let nx=e.clientX-r.left-dx; let ny=e.clientY-r.top-dy; nx=Math.max(4, Math.min(r.width-120, nx)); ny=Math.max(4, Math.min(r.height-28, ny)); div.style.left=nx+'px'; div.style.top=ny+'px'; const a=annos.find(a=>a.id===id); if(a){ a.x=nx; a.y=ny; }});
        window.addEventListener('mouseup',()=>{ if(dragging){ dragging=false; renderAnnoList(); } });
        // edit
        let editing=false; div.addEventListener('dblclick',()=>{ editing=true; div.contentEditable='true'; div.focus(); });
        div.addEventListener('blur',()=>{ if(!editing) return; div.contentEditable='false'; editing=false; const a=annos.find(a=>a.id===id); if(a){ a.text = div.textContent.replace('×','').trim(); } updateTemplateText(); renderAnnoList(); });
        div.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); div.blur(); }});
        box.appendChild(div); annos.push({id, x, y, text: div.textContent.replace('×','').trim()}); renderAnnoList();
      }
      function removeAnno(id){ const box=el('kd_chart'); const idx=annos.findIndex(a=>a.id===id); if(idx>=0){ const node=box.querySelector('.kd-anno[data-id="'+id+'"]'); if(node) node.remove(); annos.splice(idx,1); updateTemplateText(); renderAnnoList(); }}
      function renderAnnoList(){ try{ const list=el('kd_annoList'); if(!list) return; list.innerHTML=''; if(annos.length===0){ list.innerHTML='<div class="muted">（无文本注释）</div>'; return; } annos.forEach(a=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; row.style.alignItems='center'; const inp=document.createElement('input'); inp.className='form-control'; inp.value=a.text||''; inp.onchange=()=>{ a.text=inp.value; const node=document.querySelector('.kd-anno[data-id="'+a.id+'"]'); if(node){ node.childNodes[0].nodeValue = a.text; } updateTemplateText(); }; const pos=document.createElement('span'); pos.className='muted'; pos.textContent = '('+Math.round(a.x)+', '+Math.round(a.y)+')'; const goto=document.createElement('button'); goto.className='btn'; goto.textContent='定位'; goto.onclick=()=>{ const node=document.querySelector('.kd-anno[data-id="'+a.id+'"]'); if(node){ node.style.outline='1px solid #4caf50'; setTimeout(()=>{ node.style.outline='none'; },800); } }; const del=document.createElement('button'); del.className='btn'; del.textContent='删除'; del.onclick=()=>removeAnno(a.id); row.appendChild(inp); row.appendChild(pos); row.appendChild(goto); row.appendChild(del); list.appendChild(row); }); }catch(_){}}
      function applyLines(){ ensureChart(); if(!series) return; clearLines(linesS); clearLines(linesR); supports.forEach((p,i)=>{ const lab=(sLabels[i]&&sLabels[i].trim())||`S${i+1}`; const l=series.createPriceLine({price:p,color:'#10b981',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(p)}`}); linesS.push(l); }); resistances.forEach((p,i)=>{ const lab=(rLabels[i]&&rLabels[i].trim())||`R${i+1}`; const l=series.createPriceLine({price:p,color:'#ef4444',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(p)}`}); linesR.push(l); }); }
      function addAnnoDefault(){ const box=el('kd_chart'); const r=box.getBoundingClientRect(); const x=Math.floor(r.width*0.65); let y=24; if(resistances.length>0 && typeof series.priceToCoordinate==='function'){ const yCss=series.priceToCoordinate(Math.max.apply(null,resistances)); if(yCss!=null) y=Math.max(8, Math.min(r.height-28, yCss-22)); } addAnnoAt(x,y,'双击编辑'); }
      function updateLine(kind, idx, v){ if(kind==='support'){ supports[idx]=v; if(linesS[idx]){ try{ series.removePriceLine(linesS[idx]); }catch(_){}} const lab=(sLabels[idx]&&sLabels[idx].trim())||`S${idx+1}`; linesS[idx]=series.createPriceLine({price:v,color:'#10b981',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(v)}`}); } else { resistances[idx]=v; if(linesR[idx]){ try{ series.removePriceLine(linesR[idx]); }catch(_){}} const lab=(rLabels[idx]&&rLabels[idx].trim())||`R${idx+1}`; linesR[idx]=series.createPriceLine({price:v,color:'#ef4444',lineWidth:2,lineStyle:2,title:`${lab} ${fmt(v)}`}); } }
      function renderLists(){ const boxS=el('kd_supportLevels'); const boxR=el('kd_resistanceLevels'); if(!boxS||!boxR) return; boxS.innerHTML=''; supports.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const lab=document.createElement('input'); lab.className='form-control'; lab.placeholder=`S${i+1}`; lab.value=sLabels[i]||''; lab.onchange=()=>{ sLabels[i]=lab.value.trim(); applyLines(); updateTemplateText(); }; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ supports[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='删除'; del.onclick=()=>{ supports.splice(i,1); sLabels.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(lab); row.appendChild(inp); row.appendChild(del); boxS.appendChild(row); }); boxR.innerHTML=''; resistances.forEach((v,i)=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='6px'; const lab=document.createElement('input'); lab.className='form-control'; lab.placeholder=`R${i+1}`; lab.value=rLabels[i]||''; lab.onchange=()=>{ rLabels[i]=lab.value.trim(); applyLines(); updateTemplateText(); }; const inp=document.createElement('input'); inp.type='number'; inp.className='form-control'; inp.step='0.00000001'; inp.value=fmt(v).replace(/0+$/,'').replace(/\.$/,''); inp.onchange=()=>{ resistances[i]=parseFloat(inp.value); applyLines(); updateTemplateText(); }; const del=document.createElement('button'); del.className='btn'; del.textContent='删除'; del.onclick=()=>{ resistances.splice(i,1); rLabels.splice(i,1); renderLists(); applyLines(); updateTemplateText(); }; row.appendChild(lab); row.appendChild(inp); row.appendChild(del); boxR.appendChild(row); }); }

      function updateTemplateText(){ try{ const sym=(el('kd_symbol').value||'BTCUSDT').toUpperCase(); const tf=el('kd_timeframe').value||'4h'; const note=(el('kd_remarks').value||'').trim(); const supTxt = supports.length? supports.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : ''; const resTxt = resistances.length? resistances.map(v=>fmt(v).replace(/0+$/,'').replace(/\.$/,'')).join(', ') : ''; let tpl = `币种 $${sym}，时间周期 ${tf}`; if(supTxt) tpl += `；支撑：${supTxt}`; if(resTxt) tpl += `；阻力：${resTxt}`; if(note) tpl += `；备注：${note}`; el('kd_nlp').value = tpl; }catch(_){}}

      async function loadSeries(symbol, timeframe, source){ try{ status(`加载 ${symbol} ${timeframe} (${source})...`); const resp=await fetch('/realtime-fib/api/analyze',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({symbol,timeframe,source,include_series:true})}); const data=await resp.json(); if(!data.success) throw new Error(data.error||'加载失败'); const arr=(data.result.series||[]).map(r=>({ time: Math.floor((r.t||r.timestamp)/1000), open:r.open, high:r.high, low:r.low, close:r.close })); ensureChart(); if(!series) { status('图表未初始化','error'); return; } series.setData(arr); status(`已加载：${data.result.symbol} / ${data.result.timeframe} / 源 ${data.result.source}`); } catch(e){ console.error(e); status(`加载失败：${e.message}`,'error'); } }
      function addLevel(kind, price){ const p=parseFloat(price); if(!p||isNaN(p)) return; if(kind==='support'){ supports.push(snap(p)); sLabels.push(''); sortDedup('support'); renderLists(); } else { resistances.push(snap(p)); rLabels.push(''); sortDedup('resistance'); renderLists(); } applyLines(); updateTemplateText(); }

      return {
        init(){ ensureChart(); renderLists(); updateTemplateText(); try{ el('kd_symbol').addEventListener('change', updateTemplateText); el('kd_timeframe').addEventListener('change', updateTemplateText); el('kd_remarks').addEventListener('input', ()=>{ updateTemplateText(); updateNoteAnchor(); }); const modeSel=el('kd_clickMode'); if(modeSel){ modeSel.addEventListener('change',()=>{ const box=el('kd_chart'); const v=modeSel.value; const overlay = box.querySelector('#kd_textOverlay'); box.style.cursor = (v==='text') ? 'text' : 'default'; if(overlay) overlay.style.display = (v==='text') ? 'block' : 'none'; }); // 初始隐藏
              const overlay0 = el('kd_chart').querySelector('#kd_textOverlay'); if(overlay0) overlay0.style.display='none'; } }catch(_){ } },
        addText(){ ensureChart(); addAnnoDefault(); updateTemplateText(); },
        parse(){
          const txt=(el('kd_nlp').value||'').trim(); if(!txt) return;
          // 币种解析：$BTC / 币种: BTCUSDT / 直接出现 BTCUSDT
          let sym=null; const m1=txt.match(/\$([A-Za-z]{2,15})/); if(m1) sym=m1[1]+(m1[1].toUpperCase().endsWith('USDT')?'':'USDT');
          const m2=txt.match(/币种[：: ]*([A-Za-z]{2,15})/); if(!sym && m2){ const raw=m2[1].toUpperCase(); sym=raw.endsWith('USDT')?raw:(raw+'USDT'); }
          const m3=txt.match(/([A-Z]{2,15}USDT)/); if(!sym && m3) sym=m3[1].toUpperCase(); if(!sym) sym='BTCUSDT'; el('kd_symbol').value=sym;
          // 时间周期解析
          let tf='4h'; if(/1\s*天|日线|\b1d\b/i.test(txt)) tf='1d'; else if(/4\s*小时|\b4h\b/i.test(txt)) tf='4h'; else if(/1\s*小时|\b1h\b/i.test(txt)) tf='1h'; el('kd_timeframe').value=tf;
          // 解析‘支撑位’/‘阻力位’块，严格截取到下一个关键词前
          const supportKeys = ['支撑位','支撑价','支撑区间','支撑','support'];
          const resistKeys  = ['阻力位','阻力价','阻力区间','阻力','resistance'];
          const nextLabels  = [...supportKeys, ...resistKeys, '备注','币种','symbol','时间周期','时间','周期'];
          function firstIndexOf(text, keys){ let best={idx:-1,key:null}; keys.forEach(k=>{ const i=text.indexOf(k); if(i>=0 && (best.idx<0 || i<best.idx)) best={idx:i,key:k}; }); return best; }
          function blockBetween(keys){
            const hit = firstIndexOf(txt, keys); if(hit.idx<0) return '';
            let s = txt.slice(hit.idx + hit.key.length);
            if (s[0] && /[\s:：]/.test(s[0])) s = s.slice(1);
            let end = s.length;
            nextLabels.forEach(lab=>{ const k=s.indexOf(lab); if(k>=0 && k<end) end=k; });
            ['。','；',';','\n','，',','].forEach(p=>{ const k=s.indexOf(p); if(k>=0 && k<end) end=k; });
            return s.slice(0,end);
          }
          function parseLevelBlock(block){
            const parts = block.split(/[，,\/\s、]+/).map(t=>t.trim()).filter(Boolean);
            const out=[];
            parts.forEach(t=>{
              // 忽略带单位的片段，如 4小时/1天/4h/15m
              if(/[A-Za-z\u4e00-\u9fa5]/.test(t)) return;
              if(/[时天分hHdDmM]/.test((block||'').slice((block||'').indexOf(t)+t.length, (block||'').indexOf(t)+t.length+1))) return;
              const v = parseFloat(t);
              if(isFinite(v)) out.push(v);
            });
            return out;
          }
          const supBlock = blockBetween(supportKeys);
          const resBlock = blockBetween(resistKeys);
          supports = parseLevelBlock(supBlock).sort((a,b)=>a-b);
          resistances = parseLevelBlock(resBlock).sort((a,b)=>a-b);
          sLabels = new Array(supports.length).fill('');
          rLabels = new Array(resistances.length).fill('');
          renderLists();
          // 备注
          const note = (txt.match(/备注[：:](.*)$/)||[])[1]||''; el('kd_remarks').value = note.trim();
          // 更新模板与图
          updateTemplateText();
          this.drawChart();
        },
        addLevel(kind){ const id = (kind==='support')?'kd_supportAdd':'kd_resistanceAdd'; const val=parseFloat(el(id).value); if(!val||isNaN(val)) return; addLevel(kind, val); el(id).value=''; },
        applyLevels(){ applyLines(); },
        drawChart(){ ensureChart(); const sym=el('kd_symbol').value.trim().toUpperCase(); const tf=el('kd_timeframe').value; const src=el('kd_source').value; resize(); loadSeries(sym, tf, src); applyLines(); updateNoteAnchor(); },
        toggleAutoRefresh(){ const btn=el('kd_autoBtn'); if(autoTimer){ clearInterval(autoTimer); autoTimer=null; btn.textContent='开启自动刷新'; status('自动刷新关闭'); return; } const sym=el('kd_symbol').value.trim().toUpperCase(); const tf=el('kd_timeframe').value; const src=el('kd_source').value; autoTimer=setInterval(()=>loadSeries(sym,tf,src), 30000); btn.textContent='关闭自动刷新'; status('自动刷新中，每 30s 更新一次'); },
        exportPNG(){ try{ ensureChart(); if(!chart){ status('图表未初始化','error'); return; } const sym=(el('kd_symbol').value||'SYMBOL').toUpperCase(); const tfRaw=el('kd_timeframe').value||'tf'; const tf=tfRaw.toUpperCase(); const ts=new Date().toISOString().replace(/[:.]/g,'-'); const name=`kline_${sym}_${tf}_${ts}.png`; const composeAndDownload=(baseCanvas)=>{ const w=baseCanvas.width, h=baseCanvas.height; const out=document.createElement('canvas'); out.width=w; out.height=h; const ctx=out.getContext('2d'); ctx.drawImage(baseCanvas,0,0); // DPI 缩放系数（设备像素比）
            const box=el('kd_chart'); const cssW = Math.max(1, box.clientWidth||w); const scale = w / cssW; const fontSize = 12 * scale;
            // 水印: 左上角币种+周期（加半透明底）
            ctx.save(); ctx.font=`${fontSize}px Arial`; ctx.textBaseline='top'; const wm = `${sym} ${tf}`; const wmW = ctx.measureText(wm).width; const pad=4*scale; const x=8*scale, y=8*scale; ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(x-pad, y-pad, wmW+pad*2, fontSize+pad*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(wm, x, y); ctx.restore();
            // 备注：靠近最近的支撑/阻力线（上方偏移），同样考虑DPR
            const note=(el('kd_remarks').value||'').trim(); if(note){ ctx.save(); ctx.font=`${fontSize}px Arial`; let yy=null; if(typeof series.priceToCoordinate==='function'){ let anchor=null; if(supports.length>0) anchor=supports[0]; else if(resistances.length>0) anchor=resistances[0]; const yCss=anchor?series.priceToCoordinate(anchor):null; yy = (yCss!=null) ? Math.max(8*scale, yCss*scale - (18*scale)) : null; }
              const textW=ctx.measureText(note).width; const xx = Math.max(8*scale, w - textW - 16*scale); if(yy==null) yy = 24*scale; ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(xx-4*scale, yy-4*scale, textW+8*scale, fontSize+8*scale); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(note, xx, yy); ctx.restore(); }
            // 多个文本注释：读取 DOM 叠加
            ctx.save(); ctx.font=`${fontSize}px Arial`; const nodes = box.querySelectorAll('.kd-anno'); nodes.forEach(n=>{ const text = (n.textContent||'').replace('×','').trim(); if(!text) return; const leftPx = parseFloat(n.style.left||'0'); const topPx = parseFloat(n.style.top||'0'); const xx = (isFinite(leftPx)? leftPx*scale : 16*scale); const yy = (isFinite(topPx)? topPx*scale : 24*scale); const tw = ctx.measureText(text).width; ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(xx-4*scale, yy-4*scale, tw+8*scale, fontSize+8*scale); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(text, xx, yy); }); ctx.restore();
            const url=out.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('已导出图表 PNG'); };
          if(typeof chart.takeScreenshot==='function'){ const cnv=chart.takeScreenshot(); composeAndDownload(cnv); return; }
          const box=el('kd_chart'); const cvs=box.querySelectorAll('canvas'); if(!cvs||cvs.length===0) throw new Error('未找到画布'); const w=cvs[0].width, h=cvs[0].height; const off=document.createElement('canvas'); off.width=w; off.height=h; const ctx=off.getContext('2d'); cvs.forEach(c=>{ try{ ctx.drawImage(c,0,0); }catch(_){}}); composeAndDownload(off); }catch(e){ console.error(e); status('导出失败:'+e.message,'error'); } },
        saveConfig: async function(){ try{ const payload={ name: el('kd_saveName').value.trim(), symbol: el('kd_symbol').value.trim().toUpperCase(), timeframe: el('kd_timeframe').value, source: el('kd_source').value, supports, resistances, supports_labels: sLabels, resistances_labels: rLabels, remarks: el('kd_remarks').value.trim(), annotations: annos.map(a=>({x:a.x,y:a.y,text:a.text})) }; const resp=await fetch('/kline-draw/api/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)}); const data=await resp.json(); if(!data.success) throw new Error(data.error||'保存失败'); status('已保存:'+data.id); this.loadSavedList(); }catch(e){ status('保存失败:'+e.message,'error'); } },
        loadSavedList: async function(){ try{ const sym=el('kd_symbol').value.trim().toUpperCase(); const resp=await fetch('/kline-draw/api/list?symbol='+encodeURIComponent(sym)); const data=await resp.json(); if(!data.success) throw new Error(data.error||'加载失败'); const list=data.items||[]; const box=el('kd_savedList'); box.innerHTML=''; list.forEach(item=>{ const row=document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center'; const txt=document.createElement('div'); txt.textContent=`${item.name||'(未命名)'} · ${item.symbol} ${item.timeframe} · ${new Date(item.created_at).toLocaleString()}`; const load=document.createElement('button'); load.className='btn'; load.textContent='载入'; load.onclick=()=>{ el('kd_symbol').value=item.symbol||'BTCUSDT'; el('kd_timeframe').value=item.timeframe||'4h'; el('kd_source').value=item.source||'gate'; el('kd_remarks').value=item.remarks||''; supports=(item.supports||[]).slice(); resistances=(item.resistances||[]).slice(); sLabels=(item.supports_labels||new Array(supports.length).fill('')).slice(); rLabels=(item.resistances_labels||new Array(resistances.length).fill('')).slice(); sortDedup('support'); sortDedup('resistance'); renderLists(); // 重建注释
            annos=[]; const boxChart=el('kd_chart'); boxChart.querySelectorAll('.kd-anno').forEach(n=>n.remove()); (item.annotations||[]).forEach(a=>addAnnoAt(parseFloat(a.x||0), parseFloat(a.y||0), a.text||'')); KLINE.drawChart(); };
          const del=document.createElement('button'); del.className='btn'; del.textContent='删除'; del.onclick=async ()=>{ const r=await fetch('/kline-draw/api/delete',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:item.id})}); const j=await r.json(); if(j.success){ KLINE.loadSavedList(); } }; row.appendChild(txt); row.appendChild(load); row.appendChild(del); box.appendChild(row); }); status(`已加载保存项：${list.length} 条`); }catch(e){ status('加载保存列表失败:'+e.message,'error'); } },
        exportJSON(){ const obj={ symbol: el('kd_symbol').value.trim().toUpperCase(), timeframe: el('kd_timeframe').value, source: el('kd_source').value, supports, resistances, supports_labels: sLabels, resistances_labels: rLabels, remarks: el('kd_remarks').value.trim() }; const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.download=`kline_config_${obj.symbol}_${obj.timeframe}_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('已导出配置 JSON'); },
        exportCSV(){ const lines=['kind,label,price']; supports.forEach((p,i)=>lines.push(`support,${(sLabels[i]||'')},${p}`)); resistances.forEach((p,i)=>lines.push(`resistance,${(rLabels[i]||'')},${p}`)); const blob=new Blob(['\uFEFF'+lines.join('\n')],{type:'text/csv;charset=utf-8;'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='levels.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); status('已导出水平线 CSV'); },
        importJSON(input){ const file=input.files&&input.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ try{ const obj=JSON.parse(reader.result); el('kd_symbol').value=obj.symbol||'BTCUSDT'; el('kd_timeframe').value=obj.timeframe||'4h'; el('kd_source').value=obj.source||'gate'; el('kd_remarks').value=obj.remarks||''; supports=(obj.supports||[]).slice(); resistances=(obj.resistances||[]).slice(); sLabels=(obj.supports_labels||new Array(supports.length).fill('')).slice(); rLabels=(obj.resistances_labels||new Array(resistances.length).fill('')).slice(); sortDedup('support'); sortDedup('resistance'); renderLists(); KLINE.drawChart(); status('已导入配置'); }catch(e){ status('导入失败:'+e.message,'error'); } }; reader.readAsText(file); input.value=''; }
      };
    })();
    </script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            position: relative;
            overflow-x: hidden;
        }
        
        /* 动态背景样式 */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            overflow: hidden;
            display: none; /* 默认隐藏动画背景 */
        }
        
        /* 添加星星效果 */
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.4);
        }
        
        .star:nth-child(1) {
            top: 15%;
            left: 20%;
            animation-delay: 0s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(2) {
            top: 25%;
            right: 15%;
            animation-delay: 0.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(3) {
            top: 45%;
            left: 10%;
            animation-delay: 1s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(4) {
            top: 35%;
            right: 25%;
            animation-delay: 1.5s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(5) {
            top: 65%;
            left: 30%;
            animation-delay: 2s;
            width: 4px;
            height: 4px;
        }
        
        .star:nth-child(6) {
            top: 55%;
            right: 40%;
            animation-delay: 2.5s;
            width: 3px;
            height: 3px;
        }
        
        .star:nth-child(7) {
            top: 75%;
            left: 60%;
            animation-delay: 3s;
            width: 2px;
            height: 2px;
        }
        
        .star:nth-child(8) {
            top: 85%;
            right: 20%;
            animation-delay: 3.5s;
            width: 3px;
            height: 3px;
        }
        
        @keyframes twinkle {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.3);
            }
        }
        

        
        /* 视频背景样式 */
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            object-fit: cover;
            opacity: 0.8;
            display: block; /* 默认显示视频背景 */
            filter: blur(2px);
        }
        
        .video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
            z-index: -2;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: transparent; 
            padding: 20px;
            border-radius: 15px;
            position: relative;
            z-index: 1;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .help-text {
            background: rgba(0, 0, 0, 0.1);
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 5px 5px 0;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .tab {
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: transparent;
            border-radius: 0 0 5px 5px;
            color: white;
        }
        .tab-content.active {
            display: block;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        
        /* 超短交易详情样式 */
        .signal-details {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 5px;
            border-left: 3px solid #007bff;
        }
        
        .detail-item label {
            font-weight: bold;
            color: #ccc;
        }
        
        .detail-item span {
            color: #fff;
            font-weight: bold;
        }
        
        .trading-signals {
            margin-bottom: 20px;
        }
        
        .signal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .signal-item:last-child {
            border-bottom: none;
        }
        
        .signal-label {
            color: #ccc;
            font-weight: bold;
        }
        
        .signal-value {
            color: #fff;
            font-weight: bold;
        }
        
        .strategy-explanation {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #28a745;
        }
        
        .strategy-explanation h6 {
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .strategy-explanation p {
            margin: 8px 0;
            color: #ccc;
            line-height: 1.5;
        }
        
        /* 日志诊断样式 */
        .logs-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            max-height: 600px;
            overflow: hidden;
        }
        
        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .log-count {
            color: #007bff;
            font-size: 14px;
            font-weight: normal;
        }
        
        .log-controls {
            display: flex;
            gap: 15px;
        }
        
        .log-controls label {
            color: #ccc;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .logs-content {
            background: #0a0a0a;
            border-radius: 5px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px 8px;
            border-radius: 3px;
            border-left: 3px solid #333;
            word-wrap: break-word;
        }
        
        .log-entry.info {
            border-left-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }
        
        .log-entry.warning {
            border-left-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .log-entry.error {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .log-time {
            color: #888;
            font-size: 11px;
            margin-right: 10px;
        }
        
        .log-level {
            color: #fff;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            display: inline-block;
        }
        
        .log-message {
            color: #ccc;
        }
        
        .log-entry.info .log-level {
            color: #007bff;
        }
        
        .log-entry.warning .log-level {
            color: #ffc107;
        }
        
        .log-entry.error .log-level {
            color: #dc3545;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-warning:hover {
            background: #e0a800;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .form-control {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.1);
            color: white;
        }
        .results-container {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 15px;
            background: transparent;
            color: white;
        }
        .result-item {
            background: transparent;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
            color: white;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background: rgba(40, 167, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .status.error {
            background: rgba(220, 53, 69, 0.8);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: transparent;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
                .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .stat-label {
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* 表格样式 */
         .table-container {
             overflow-x: auto;
             margin-top: 15px;
         }
         
                                                                                                                                                                                                                               .analysis-table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            color: white;
            border-radius: 8px;
            overflow: hidden;
        }
         
         .analysis-table th,
         .analysis-table td {
             padding: 12px 8px;
             text-align: left;
             border-bottom: 1px solid #e9ecef;
         }
         
                                                                                                                                                                                                                               .analysis-table th {
            background: transparent;
            font-weight: bold;
            color: #fff;
            position: sticky;
            top: 0;
            z-index: 10;
            padding: 15px 12px;
        }
         
                           .analysis-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
                                   .analysis-table tr:nth-child(even) {
              background: transparent;
          }
         
         /* 筛选控制样式 */
                                                                                                                                                                                                                               .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            flex-wrap: wrap;
            color: white;
        }
         
         .filter-group {
             display: flex;
             align-items: center;
             gap: 8px;
         }
         
         .filter-group label {
             font-weight: bold;
             margin: 0;
             white-space: nowrap;
         }
         
                                                                               .filter-group select,
            .filter-group input {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
         .filter-group button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .filter-group button:hover {
             background: #0056b3;
         }
         
         /* 分页控制样式 */
                                                                                                                                                                                                                               .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: transparent;
            border-radius: 8px;
            color: white;
        }
         
         .pagination-controls button {
             padding: 8px 15px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 14px;
         }
         
         .pagination-controls button:hover {
             background: #0056b3;
         }
         
         .pagination-controls button:disabled {
             background: #6c757d;
             cursor: not-allowed;
         }
         
                                                                               .pagination-controls select {
                padding: 6px 10px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 14px;
                background: rgba(0, 0, 0, 0.1);
                color: white;
            }
         
                 #pageInfo {
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         
         /* 状态标签样式 */
         .status-badge {
             padding: 4px 8px;
             border-radius: 12px;
             font-size: 12px;
             font-weight: bold;
             text-align: center;
         }
         
         .status-buy {
             background: #d4edda;
             color: #155724;
         }
         
         .status-sell {
             background: #f8d7da;
             color: #721c24;
         }
         
         .status-hold {
             background: #fff3cd;
             color: #856404;
         }
         
         /* 操作按钮样式 */
         .action-btn {
             padding: 4px 8px;
             margin: 2px;
             border: none;
             border-radius: 3px;
             cursor: pointer;
             font-size: 12px;
         }
         
         
         /* 模态对话框样式 */
         .modal {
             display: none;
             position: fixed;
             z-index: 1000;
             left: 0;
             top: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.7);
             backdrop-filter: blur(5px);
         }
         
         .modal-content {
             background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
             margin: 5% auto;
             padding: 30px;
             border: 2px solid rgba(255, 255, 255, 0.3);
             border-radius: 15px;
             width: 80%;
             max-width: 500px;
             color: white;
             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
         }
         
         .modal-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px solid rgba(255, 255, 255, 0.3);
         }
         
         .modal-title {
             font-size: 20px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .close {
             color: rgba(255, 255, 255, 0.7);
             font-size: 28px;
             font-weight: bold;
             cursor: pointer;
             transition: color 0.3s;
         }
         
         .close:hover {
             color: white;
         }
         
         .modal-body {
             margin-bottom: 20px;
         }
         
         .modal-footer {
             display: flex;
             justify-content: flex-end;
             gap: 10px;
         }
         
         /* 图表容器样式 */
         .chart-container {
             margin-top: 20px;
             padding: 20px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 10px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .chart-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 15px;
             color: white;
         }
         
         .chart-title {
             font-size: 18px;
             font-weight: bold;
             color: white;
             text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
         }
         
         .chart-controls {
             display: flex;
             gap: 10px;
             align-items: center;
         }
         
         .chart-controls button {
             padding: 6px 12px;
             background: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .chart-controls button:hover {
             background: #0056b3;
         }
         
         .chart-controls button.active {
             background: #28a745;
         }
         
         .chart-controls select {
             padding: 6px 10px;
             border: 1px solid rgba(255, 255, 255, 0.5);
             border-radius: 4px;
             background: rgba(0, 0, 0, 0.1);
             color: white;
             font-size: 12px;
         }
         
         .chart-wrapper {
             position: relative;
             height: 400px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             padding: 10px;
         }
         
         .chart-legend {
             display: flex;
             flex-wrap: wrap;
             gap: 15px;
             margin-top: 10px;
             padding: 10px;
             background: rgba(0, 0, 0, 0.2);
             border-radius: 5px;
         }
         
         .legend-item {
             display: flex;
             align-items: center;
             gap: 5px;
             font-size: 12px;
             color: white;
         }
         
         .legend-color {
             width: 12px;
             height: 2px;
             border-radius: 1px;
         }
         
         /* 交叉点位信息面板样式 */
         .cross-points-panel {
             margin-top: 15px;
             padding: 15px;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 8px;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .cross-points-panel h4 {
             color: white;
             margin: 0 0 15px 0;
             font-size: 16px;
         }
         
         .cross-points-tabs {
             display: flex;
             gap: 10px;
             margin-bottom: 15px;
         }
         
         .cross-tab {
             padding: 8px 16px;
             background: rgba(255, 255, 255, 0.1);
             color: white;
             border: 1px solid rgba(255, 255, 255, 0.2);
             border-radius: 4px;
             cursor: pointer;
             font-size: 12px;
         }
         
         .cross-tab:hover {
             background: rgba(255, 255, 255, 0.2);
         }
         
         .cross-tab.active {
             background: #007bff;
             border-color: #007bff;
         }
         
         .cross-tab-content {
             display: none;
         }
         
         .cross-tab-content.active {
             display: block;
         }
         
         .cross-points-list {
             max-height: 200px;
             overflow-y: auto;
         }
         
         .cross-point-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 8px 12px;
             margin-bottom: 8px;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 4px;
             border-left: 3px solid;
             font-size: 12px;
         }
         
         .cross-point-item.golden-cross {
             border-left-color: #00ff00;
         }
         
         .cross-point-item.death-cross {
             border-left-color: #ff0000;
         }
         
         .cross-point-info {
             color: white;
         }
         
         .cross-point-price {
             font-weight: bold;
             color: #ffd700;
         }
         
         .cross-point-time {
             color: #ccc;
             font-size: 11px;
         }
         
         /* 多空势能场模型样式 */
         .momentum-field-container {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 20px;
             margin: 10px 0;
             border: 1px solid rgba(255, 255, 255, 0.1);
         }
         
         .stats-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin: 15px 0;
         }
         
         .stat-item {
             background: rgba(255, 255, 255, 0.10);
             padding: 12px;
             border-radius: 6px;
             border-left: 4px solid #3498db;
             color: #ffffff;
         }
         .stat-item strong { color: #ffd54f; }
         
         .signals-container {
             margin-top: 20px;
         }
         
         .signals-list {
             max-height: 300px;
             overflow-y: auto;
             background: rgba(0, 0, 0, 0.3);
             border-radius: 5px;
             padding: 10px;
         }
         
         .signal-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 8px;
             margin: 5px 0;
             border-radius: 5px;
             background: rgba(255, 255, 255, 0.05);
         }
         
         .signal-item.buy {
             border-left: 3px solid #4CAF50;
             background: rgba(76, 175, 80, 0.1);
         }
         
         .signal-item.sell {
             border-left: 3px solid #f44336;
             background: rgba(244, 67, 54, 0.1);
         }
         
         .signal-time {
             color: #ccc;
             font-size: 12px;
         }
         
         .signal-type {
             font-weight: bold;
             color: #fff;
         }
         
         .signal-strength {
             color: #ffd700;
             font-size: 12px;
         }
         
         #momentumFieldChart {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             margin-top: 20px;
         }
         
         /* 斐波概率预测样式 */
         .fibonacci-levels-container {
             margin-top: 20px;
         }
         
         .fib-levels-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .fib-level-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             border: 2px solid transparent;
             transition: all 0.3s ease;
         }
         
         .fib-level-item.high {
             border-color: #4CAF50;
             background: rgba(76, 175, 80, 0.1);
         }
         
         .fib-level-item.medium {
             border-color: #FFC107;
             background: rgba(255, 193, 7, 0.1);
         }
         
         .fib-level-item.low {
             border-color: #f44336;
             background: rgba(244, 67, 54, 0.1);
         }
         
         .fib-level-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 10px;
         }
         
         .probability-badge {
             background: rgba(255, 255, 255, 0.2);
             padding: 4px 8px;
             border-radius: 15px;
             font-weight: bold;
         }
         
         .fib-level-details {
             margin-bottom: 15px;
         }
         
         .fib-price, .fib-probability {
             margin: 5px 0;
             font-size: 14px;
         }
         
         .fib-factors {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 8px;
         }
         
         .factor-item {
             display: flex;
             justify-content: space-between;
             font-size: 12px;
             padding: 4px 8px;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 5px;
         }
         
         .batch-results-container {
             margin-top: 20px;
         }
         
         .batch-results-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .batch-result-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
         }
         
         .batch-symbol {
             font-weight: bold;
             font-size: 16px;
             margin-bottom: 10px;
             color: #ffd700;
         }
         
         .batch-probabilities {
             display: flex;
             flex-direction: column;
             gap: 5px;
         }
         
         .batch-prob-item {
             display: flex;
             justify-content: space-between;
             padding: 5px 10px;
             border-radius: 5px;
             font-size: 12px;
         }
         
         .batch-prob-item.high {
             background: rgba(76, 175, 80, 0.2);
             color: #4CAF50;
         }
         
         .batch-prob-item.medium {
             background: rgba(255, 193, 7, 0.2);
             color: #FFC107;
         }
         
         .batch-prob-item.low {
             background: rgba(244, 67, 54, 0.2);
             color: #f44336;
         }
         
         #fibonacciProbChart {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             margin-top: 20px;
         }
         
         /* 斐波详情样式 */
         .fibonacci-levels-info {
             margin-top: 20px;
         }
         
         .fib-levels-detail-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .fib-level-detail-item {
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 15px;
             border: 2px solid transparent;
             transition: all 0.3s ease;
         }
         
         .fib-level-detail-item.high {
             border-color: #4CAF50;
             background: rgba(76, 175, 80, 0.1);
         }
         
         .fib-level-detail-item.medium {
             border-color: #FFC107;
             background: rgba(255, 193, 7, 0.1);
         }
         
         .fib-level-detail-item.low {
             border-color: #f44336;
             background: rgba(244, 67, 54, 0.1);
         }
         
         .fib-distance {
             color: #ffd700;
             font-size: 14px;
             margin: 5px 0;
         }
         
         /* 实时斐波分析样式 */
         .fib-position-container {
             margin-top: 20px;
         }
         
         .fib-position-info {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .position-item {
             background: rgba(255, 255, 255, 0.10);
             padding: 12px;
             border-radius: 6px;
             border-left: 4px solid #3498db;
             color: #ffffff;
         }
         
         .recent-analysis-container {
             margin-top: 20px;
         }
         
         .recent-stats-grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
             gap: 15px;
             margin-top: 15px;
         }
         
         .status-active {
             color: #4CAF50;
             font-weight: bold;
         }
         
         .status-inactive {
             color: #f44336;
             font-weight: bold;
         }
         
         .chart-container {
             max-width: 1100px;
             height: 420px;
             margin: 0 auto;
             background: rgba(255, 255, 255, 0.05);
             border-radius: 10px;
             padding: 10px;
         }
         .chart-container canvas {
             width: 100% !important;
             height: 100% !important;
         }
         
        
        .info-box {
            background: rgba(255, 255, 255, 0.10);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            color: #ffffff;
        }
        
        .info-box h4 {
            margin-top: 0;
            color: #ffffff;
        }
        
        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info-box li {
            margin: 5px 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- 动态背景 -->
    <div class="animated-background">
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
        <div class="star"></div>
    </div>
    
    <!-- 视频背景 -->
    <video class="video-background" autoplay muted loop playsinline>
        <source src="/static/videos/background.mp4" type="video/mp4">
        您的浏览器不支持视频标签。
    </video>
    <div class="video-overlay"></div>
    
    <div class="container">
        <div class="header">
            <h1>布林带策略挂单系统</h1>
            <p>基于布林带技术指标的智能加密货币分析系统</p>
        </div>
        
        <div class="help-text">
                            <strong>系统说明：</strong>本系统基于布林带技术指标分析加密货币价格走势，提供智能挂单建议。支持<span id="totalSymbolsDisplay">195</span>个币种、多时间周期、多交易所数据源、持仓管理等功能。
        </div>

        <!-- 系统统计 -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="totalSymbols">195</div>
                <div class="stat-label">支持币种</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="analyzedCount">0</div>
                <div class="stat-label">已分析</div>
            </div>
        </div>

        <!-- Tab导航 -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('analysis', event)">📊 币种分析</button>
            <button class="tab" onclick="showTab('intraday', event)">⚡ 日内交易</button>
            <button class="tab" onclick="showTab('ultraShort', event)">🚀 日内超短</button>
            <button class="tab" onclick="showTab('multiTimeframe', event)">📈 多时间框架</button>
            <button class="tab" onclick="showTab('hotCoins', event)">🔥 热点币种分析</button>
            <button class="tab" onclick="showTab('fibonacci', event)">📐 斐波规律研究</button>
            <button class="tab" onclick="showTab('momentumField', event)">⚡ 多空势能场模型</button>
            <button class="tab" onclick="showTab('fibonacciProb', event)">🎯 斐波概率预测</button>
            <button class="tab" onclick="showTab('klineDraw', event)">📉 K线绘制</button>
            <button class="tab" onclick="showTab('logs', event)">🔍 日志诊断</button>
            <button class="tab" onclick="showTab('management', event)">⚙️ 系统管理</button>
        </div>

        <!-- 币种分析Tab -->
        <div id="analysis" class="tab-content active">
            <h3>币种分析</h3>
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeDefault()">分析全部<span id="analyzeButtonCount">130</span>个币种</button>
                <button class="btn btn-info" onclick="showAddSymbolModal()">➕ 新增币种</button>
                <button class="btn btn-warning" onclick="analyzeCustom()">分析自定义币种</button>
                <button class="btn btn-success" onclick="exportSymbols()">📤 导出币种列表</button>
                <button class="btn btn-outline-primary" onclick="saveAllSymbols()">💾 保存全部</button>
                <button class="btn btn-primary" onclick="showImportModal()">📥 导入币种列表</button>
            </div>
            <div class="form-group">
                <label>自定义币种（用逗号分隔）：</label>
                <textarea class="form-control" id="symbolsInput" rows="3" placeholder="例如: BTC, ETH, ADA, DOT"></textarea>
            </div>
            <div class="form-group">
                <label><input type="checkbox" id="forceRefresh"> 强制刷新数据</label>
            </div>
            <div id="analysisResults" class="results-container" style="display: none;">
                <h4>分析结果</h4>
                
                <!-- 筛选和排序控制 -->
                <div class="filter-controls">
                    <div class="filter-group">
                        <label>时间级别:</label>
                        <select id="timeframeFilter" onchange="filterResults()">
                            <option value="all">全部</option>
                            <option value="12h">12小时</option>
                            <option value="1d">1天</option>
                            <option value="3d">3天</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>排序:</label>
                        <select id="sortBy" onchange="sortResults()">
                            <option value="symbol">币种</option>
                            <option value="price">当前价格</option>
                            <option value="orderPrice">挂单价格</option>
                            <option value="timeframe">时间级别</option>
                        </select>
                        <button id="sortOrder" onclick="toggleSortOrder()">↑</button>
                    </div>
                    <div class="filter-group">
                        <label>搜索:</label>
                        <input type="text" id="searchSymbol" placeholder="搜索币种..." onkeyup="filterResults()">
                    </div>
                </div>
                
                <!-- 分页控制 -->
                <div class="pagination-controls">
                    <button onclick="changePage(-1)" id="prevPage">上一页</button>
                    <span id="pageInfo">第 1 页，共 1 页</span>
                    <button onclick="changePage(1)" id="nextPage">下一页</button>
                    <select id="pageSize" onchange="changePageSize()">
                        <option value="20">20条/页</option>
                        <option value="50">50条/页</option>
                        <option value="100">100条/页</option>
                    </select>
                    <button class="btn btn-success" onclick="exportAnalysisResultsToCSV()" style="margin-left: 20px;">
                        📥 导出分析结果 (CSV)
                    </button>
                </div>
                
                <!-- 结果表格 -->
                <div class="table-container">
                    <table id="analysisTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>币种</th>
                                <th>当前价格</th>
                                <th>挂单价格</th>
                                <th>时间级别</th>
                                <th>状态</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="analysisTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 日内交易Tab -->
        <div id="intraday" class="tab-content">
            <h3>⚡ 日内交易信号</h3>
            <div class="help-text">
                <strong>日内交易说明：</strong>基于365周期EMA/MA锚点策略，价格在锚点上方为多头信号，下方为空头信号。优先显示15分钟和1小时信号。
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeIntradaySymbols()">分析主要币种</button>
                <button class="btn btn-info" onclick="analyzeIntradayCustom()">分析自定义币种</button>
                <button class="btn btn-warning" onclick="getIntradaySignals()">获取信号汇总</button>
                <button class="btn btn-secondary" onclick="clearIntradayCache()">清除缓存</button>
            </div>
            
            <div class="form-group">
                <label>自定义币种（用逗号分隔）：</label>
                <textarea class="form-control" id="intradaySymbolsInput" rows="2" placeholder="例如: BTC, ETH, SOL, ADA"></textarea>
            </div>
            
            <div class="form-group">
                <label><input type="checkbox" id="intradayForceRefresh"> 强制刷新数据</label>
            </div>
            
            <!-- 信号汇总区域 -->
            <div id="intradaySignals" class="results-container" style="display: none;">
                <h4>信号汇总（15m + 1h）</h4>
                <div class="table-container">
                    <table id="intradaySignalsTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>币种</th>
                                <th>综合信号</th>
                                <th>15分钟</th>
                                <th>1小时</th>
                                <th>一致性</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="intradaySignalsTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- 详细分析区域 -->
            <div id="intradayDetails" class="results-container" style="display: none;">
                <h4>详细分析结果</h4>
                
                <!-- 筛选控制 -->
                <div class="filter-controls">
                    <div class="filter-group">
                        <label>时间周期:</label>
                        <select id="intradayTimeframeFilter" onchange="filterIntradayResults()">
                            <option value="all">全部</option>
                            <option value="1m">1分钟</option>
                            <option value="3m">3分钟</option>
                            <option value="15m">15分钟</option>
                            <option value="1h">1小时</option>
                            <option value="2h">2小时</option>
                            <option value="4h">4小时</option>
                            <option value="6h">6小时</option>
                            <option value="8h">8小时</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>信号类型:</label>
                        <select id="intradaySignalFilter" onchange="filterIntradayResults()">
                            <option value="all">全部</option>
                            <option value="long">多头</option>
                            <option value="short">空头</option>
                            <option value="mixed">混合</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>搜索:</label>
                        <input type="text" id="intradaySearchSymbol" placeholder="搜索币种..." onkeyup="filterIntradayResults()">
                    </div>
                </div>
                
                <!-- 详细结果表格 -->
                <div class="table-container">
                    <table id="intradayDetailsTable" class="analysis-table">
                        <thead>
                            <tr>
                                <th>币种</th>
                                <th>时间周期</th>
                                <th>当前价格</th>
                                <th>EMA365</th>
                                <th>MA365</th>
                                <th>锚点</th>
                                <th>信号</th>
                                <th>强度</th>
                                <th>偏离度</th>
                            </tr>
                        </thead>
                        <tbody id="intradayDetailsTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- 图表区域 -->
            <div id="chartSection" class="chart-container" style="display: none;">
                <div class="chart-header">
                    <div class="chart-title">📈 EMA多时间周期图表</div>
                    <div class="chart-controls">
                        <select id="chartSymbolSelect" onchange="updateChartSymbol()">
                            <option value="">选择币种</option>
                        </select>
                        <select id="chartTimeframeSelect" onchange="updateChartTimeframe()">
                            <option value="5m">5分钟</option>
                            <option value="15m">15分钟</option>
                            <option value="1h">1小时</option>
                        </select>
                        <button onclick="refreshChart()">🔄 刷新</button>
                        <button onclick="toggleChartVisibility()">👁️ 显示/隐藏</button>
                    </div>
                </div>
                
                <div class="chart-wrapper">
                    <canvas id="emaChart"></canvas>
                </div>
                
                <div class="chart-legend" id="chartLegend">
                    <!-- 图例将通过JavaScript动态生成 -->
                </div>
                
                <!-- 交叉点位信息面板 -->
                <div class="cross-points-panel" id="crossPointsPanel" style="display: none;">
                    <h4>🎯 交叉点位信息</h4>
                    <div class="cross-points-tabs">
                        <button class="cross-tab active" onclick="showCrossTab('price', event)">价格交叉</button>
                        <button class="cross-tab" onclick="showCrossTab('indicator', event)">均线交叉</button>
                    </div>
                    <div class="cross-points-content">
                        <div id="priceCrossPoints" class="cross-tab-content active">
                            <div class="cross-points-list" id="priceCrossList">
                                <!-- 价格交叉点列表 -->
                            </div>
                        </div>
                        <div id="indicatorCrossPoints" class="cross-tab-content">
                            <div class="cross-points-list" id="indicatorCrossList">
                                <!-- 均线交叉点列表 -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 日内超短交易Tab -->
        <div id="ultraShort" class="tab-content">
            <h3>🚀 日内超短交易策略</h3>
            <div class="help-text">
                <strong>超短策略说明：</strong>基于1小时EMA365/MA365区间突破，在区间上沿做空，止盈目标为1分钟EMA233。适用于快速进出场交易。
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="analyzeUltraShortSymbols()">分析超短机会 (期货前400)</button>
                <button class="btn btn-info" onclick="analyzeUltraShortCustom()">分析自定义币种</button>
                <button class="btn btn-secondary" onclick="getTopSymbols()">获取币种列表</button>
                <button class="btn btn-primary" onclick="validateSymbol()">验证币种</button>
                <button class="btn btn-warning" onclick="clearUltraShortCache()">清除缓存</button>
            </div>
            
            <div class="form-group">
                <label for="riskRewardFilter">收益率过滤:</label>
                <select id="riskRewardFilter" class="form-control" style="width: 200px; display: inline-block;">
                    <option value="1.5">≥ 1.5% (优质机会)</option>
                    <option value="1.0">≥ 1.0% (一般机会)</option>
                    <option value="0.5">≥ 0.5% (收益较低)</option>
                    <option value="0">显示全部</option>
                </select>
                <button class="btn btn-sm btn-outline-primary" onclick="applyRiskRewardFilter()">应用过滤</button>
            </div>
            
            <div class="form-group">
                <label for="ultraShortSymbolsInput">自定义币种 (用逗号分隔):</label>
                <input type="text" id="ultraShortSymbolsInput" placeholder="例如: ETH, BTC, SOL" class="form-control">
            </div>
            
            <!-- 超短交易信号表格 -->
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>币种</th>
                            <th>1h区间</th>
                            <th>当前价格</th>
                            <th>交易机会</th>
                            <th>入场价格</th>
                            <th>止盈价格</th>
                            <th>收益率</th>
                            <th>信号时间</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody id="ultraShortSignalsTableBody">
                        <tr>
                            <td colspan="9" style="text-align: center; color: #666;">暂无超短交易信号</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- 超短交易详情 -->
            <div id="ultraShortDetails" class="details-container" style="display: none;">
                <h4>超短交易详情</h4>
                <div id="ultraShortDetailsContent"></div>
            </div>
        </div>

        <!-- 多时间框架策略Tab -->
        <div id="multiTimeframe" class="tab-content">
            <h3>📈 多时间框架策略</h3>
            <div class="help-text">
                <strong>策略说明：</strong>基于EMA144/233/377/610的多时间框架趋势跟踪策略。从4H开始，依次分析8H/12H/1D/3D/1W，价格回踩均线时开仓，止盈使用对应时间框架的布林中轨。
            </div>
            
            <div class="form-group">
                <label for="strategyTypeSelect">策略类型:</label>
                <select id="strategyTypeSelect" class="form-control" style="width: 300px; display: inline-block;">
                    <option value="original">原策略 (4H/8H/12H/1D/3D/1W，不同止盈)</option>
                    <option value="modified">修改策略 (8H/12H/1D/3D/1W，统一3分钟止盈)</option>
                </select>
            </div>
            
            <div class="form-group">
                <button class="btn btn-primary" onclick="analyzeMultiTimeframeSymbols()">分析前500币种</button>
                <button class="btn btn-info" onclick="getMultiTimeframeTopSymbols()">获取币种列表</button>
                <button class="btn btn-warning" onclick="clearMultiTimeframeCache()">清除EMA记录</button>
                <button class="btn btn-secondary" onclick="validateMultiTimeframeSymbol()">验证币种</button>
            </div>
            
            <div class="form-group">
                <label for="multiTimeframeSymbolInput">自定义币种分析:</label>
                <input type="text" id="multiTimeframeSymbolInput" class="form-control" placeholder="输入币种，如: BTC, ETH, DOT" style="width: 300px; display: inline-block;">
                <button class="btn btn-success" onclick="analyzeCustomMultiTimeframeSymbols()">分析</button>
            </div>
            
            <div class="form-group">
                <label for="multiTimeframeProfitFilter">收益率过滤:</label>
                <select id="multiTimeframeProfitFilter" class="form-control" style="width: 200px; display: inline-block;">
                    <option value="0" selected>显示全部</option>
                    <option value="0.2">≥ 0.2% (收益较低)</option>
                    <option value="0.5">≥ 0.5% (一般机会)</option>
                    <option value="1.0">≥ 1.0% (优质机会)</option>
                </select>
                <button class="btn btn-sm btn-outline-primary" onclick="applyMultiTimeframeFilter()">应用过滤</button>
            </div>
            
            <div class="form-group">
                <label for="pageSizeSelect">每页显示:</label>
                <select id="pageSizeSelect" class="form-control" style="width: 150px; display: inline-block;">
                    <option value="10">10个信号</option>
                    <option value="20" selected>20个信号</option>
                    <option value="50">50个信号</option>
                </select>
                <button class="btn btn-sm btn-outline-secondary" onclick="changePageSize()">更改页面大小</button>
            </div>
            
            <div class="form-group" id="paginationControls" style="display: none;">
                <button class="btn btn-sm btn-outline-primary" onclick="previousSignalPage()" id="prevBtn" disabled>上一页</button>
                    <span id="pageInfo" style="margin: 0 10px;">第1页，共1页 (信号分页)</span>
                <button class="btn btn-sm btn-outline-primary" onclick="nextSignalPage()" id="nextBtn" disabled>下一页</button>
                <button class="btn btn-sm btn-success" onclick="exportAllSignalsToCSV()" style="margin-left: 20px;">
                    📥 导出全部数据 (CSV)
                </button>
            </div>
            
            <!-- 多时间框架信号表格 -->
            <div class="table-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>币种</th>
                            <th>时间框架</th>
                            <th>趋势</th>
                            <th>EMA级别</th>
                            <th>入场价格</th>
                            <th>止盈价格</th>
                            <th>收益率</th>
                            <th>信号类型</th>
                            <th>信号时间</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody id="multiTimeframeSignalsTableBody">
                        <tr>
                            <td colspan="10" style="text-align: center; color: #666;">暂无多时间框架交易信号</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- 状态显示 -->
            <div id="multiTimeframeStatus" class="status-message"></div>
        </div>

        <!-- 日志诊断Tab -->
        <div id="logs" class="tab-content">
            <h3>🔍 日志诊断</h3>
            <div class="help-text">
                <strong>日志诊断说明：</strong>实时显示系统运行日志，便于调试和问题诊断。包括超短交易分析、数据获取、错误信息等。
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="startLogMonitoring()">开始监控日志</button>
                <button class="btn btn-warning" onclick="clearLogs()">清空日志</button>
                <button class="btn btn-info" onclick="testUltraShortWithLogs()">测试超短交易(带日志)</button>
                <button class="btn btn-secondary" onclick="exportLogs()">导出日志</button>
            </div>
            
            <div class="form-group">
                <label for="logLevelFilter">日志级别过滤:</label>
                <select id="logLevelFilter" class="form-control" onchange="filterLogs()">
                    <option value="all">全部</option>
                    <option value="INFO">INFO</option>
                    <option value="WARNING">WARNING</option>
                    <option value="ERROR">ERROR</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="logSearch">搜索日志:</label>
                <input type="text" id="logSearch" class="form-control" placeholder="输入关键词搜索日志..." onkeyup="searchLogs()">
            </div>
            
            <!-- 日志显示区域 -->
            <div class="logs-container">
                <div class="logs-header">
                    <h4>实时日志 <span id="logCount" class="log-count">(0条)</span></h4>
                    <div class="log-controls">
                        <label>
                            <input type="checkbox" id="autoScroll" checked> 自动滚动
                        </label>
                        <label>
                            <input type="checkbox" id="showTimestamp" checked> 显示时间戳
                        </label>
                    </div>
                </div>
                <div id="logsContent" class="logs-content">
                    <div class="log-entry info">
                        <span class="log-time">[系统启动]</span>
                        <span class="log-level">INFO</span>
                        <span class="log-message">日志系统已就绪，等待日志输出...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 热点币种分析Tab -->
        <div id="hotCoins" class="tab-content">
            <h3>🔥 热点币种分析</h3>
            
            <!-- 功能模式切换 -->
            <div style="margin-bottom: 20px;">
                <button class="cross-tab active" onclick="switchHotCoinsMode('realtime', event)">⚡ 实时分析</button>
                <button class="cross-tab" onclick="switchHotCoinsMode('historical', event)">📈 历史时段分析</button>
            </div>
            
            <!-- 实时分析模式 -->
            <div id="realtimeMode" style="display: block;">
                <div class="help-text">
                    <strong>功能说明：</strong>实时分析350个主流币种的24小时价格表现，找出市场热点和投资机会。数据源：Gate.io
                </div>
                
                <div class="form-group">
                    <button class="btn btn-success" onclick="analyzeHotCoins()">🔍 开始分析</button>
                    <button class="btn btn-info" onclick="showHotCoinsSymbols()">📋 查看币种列表</button>
                </div>
            </div>
            
            <!-- 历史时段分析模式 -->
            <div id="historicalMode" style="display: none;">
                <div class="help-text">
                    <strong>功能说明：</strong>分析指定时间段内的币种涨幅，筛选超级牛币，并提供项目详情、研发进展、资金流向等深度分析。
                </div>
                
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #444;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">📅 开始日期</label>
                            <input type="date" id="advStartDate" class="form-control" value="2025-08-20" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">📅 结束日期</label>
                            <input type="date" id="advEndDate" class="form-control" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #e0e0e0;">🎯 最高点涨幅倍数</label>
                            <input type="number" id="minGainRatio" value="3" min="0.5" step="0.1" style="padding: 8px; border: 1px solid #555; border-radius: 4px; width: 100%; background: #1a1a1a; color: #e0e0e0;">
                            <small style="color: #999;">如输入3表示筛选期间最高点达到3倍（即200%涨幅）的币种</small>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; color: #e0e0e0;">
                        <label style="margin-right: 20px;">
                            <input type="checkbox" id="includeProjectInfo" checked>
                            <strong>📋 包含项目详情</strong>（名称、描述、赛道、链接、社区数据等）
                        </label>
                        <label>
                            <input type="checkbox" id="includeMoneyFlow" checked>
                            <strong>💰 包含资金流向</strong>（每日资金流入流出分析）
                        </label>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn btn-success" onclick="analyzeHistoricalPeriod()">🚀 开始历史分析</button>
                        <button class="btn btn-info" onclick="showAdvancedExample()">💡 查看示例</button>
                    </div>
                </div>
            </div>
            
            <!-- 分析进度 -->
            <div id="hotCoinsProgress" style="display: none; margin: 20px 0;">
                <div style="background: #f0f0f0; border-radius: 5px; padding: 15px;">
                    <div style="margin-bottom: 10px;">
                        <strong>分析进度：</strong>
                        <span id="hotCoinsProgressText">0/0</span>
                    </div>
                    <div style="background: #fff; height: 20px; border-radius: 10px; overflow: hidden;">
                        <div id="hotCoinsProgressBar" style="background: linear-gradient(90deg, #28a745, #20c997); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 分析结果概览 -->
            <div id="hotCoinsSummary" style="display: none; margin: 20px 0;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="totalCoins">0</div>
                        <div style="font-size: 12px; color: #999;">总币种数</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="successCoins">0</div>
                        <div style="font-size: 12px; color: #999;">成功获取</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;" id="positiveCoins">0</div>
                        <div style="font-size: 12px; color: #999;">上涨币种</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;" id="avgChange">0%</div>
                        <div style="font-size: 12px; color: #999;">平均涨跌</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;" id="maxGain">0%</div>
                        <div style="font-size: 12px; color: #999;">最大涨幅</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #dc3545; margin-bottom: 5px;" id="maxLoss">0%</div>
                        <div style="font-size: 12px; color: #999;">最大跌幅</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab切换 -->
            <div id="hotCoinsTabsContainer" style="display: none; margin: 20px 0;">
                <div style="border-bottom: 2px solid #444; margin-bottom: 20px;">
                    <button class="cross-tab active" onclick="showHotCoinsSubTab('gainers', event)">🚀 涨幅榜</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('losers', event)">📉 跌幅榜</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('volume', event)">💰 交易量榜</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('distribution', event)">📊 涨跌分布</button>
                    <button class="cross-tab" onclick="showHotCoinsSubTab('all', event)">📋 完整列表</button>
                </div>
                
                <!-- 涨幅榜 -->
                <div id="gainersTab" class="cross-tab-content active">
                    <h4 style="color: #e0e0e0;">🚀 TOP 20 涨幅榜</h4>
                    <div id="gainersContent"></div>
                </div>
                
                <!-- 跌幅榜 -->
                <div id="losersTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">📉 TOP 20 跌幅榜</h4>
                    <div id="losersContent"></div>
                </div>
                
                <!-- 交易量榜 -->
                <div id="volumeTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">💰 TOP 20 交易量榜</h4>
                    <div id="volumeContent"></div>
                </div>
                
                <!-- 涨跌分布 -->
                <div id="distributionTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">📊 涨跌分布统计</h4>
                    <div id="distributionContent"></div>
                </div>
                
                <!-- 完整列表 -->
                <div id="allTab" class="cross-tab-content">
                    <h4 style="color: #e0e0e0;">📋 所有币种列表</h4>
                    <div style="margin-bottom: 10px;">
                        <input type="text" id="coinSearchInput" placeholder="搜索币种..." style="padding: 8px; width: 300px; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e0e0;">
                    </div>
                    <div id="allCoinsContent"></div>
                </div>
            </div>
            
            <!-- 结果显示区域 -->
            <div id="hotCoinsResults"></div>
        </div>

        <!-- 斐波规律研究Tab -->
        <div id="fibonacci" class="tab-content">
            <h3>📐 斐波规律研究</h3>
            <div class="form-group">
                <p>专业的斐波那契回撤分析工具，基于LIGHT币种的历史数据</p>
                <div class="info-box">
                    <h4>LIGHT 币种信息</h4>
                    <ul>
                        <li><strong>交易日期:</strong> 2024年10月21日</li>
                        <li><strong>做空点位:</strong> 1.857 / 1.969 / 2.09</li>
                        <li><strong>止盈点位:</strong> 1.6625 / 1.5843 / 1.317</li>
                        <li><strong>数据源:</strong> Bitget / Bybit API</li>
                    </ul>
                </div>
                <div class="form-group">
                    <button class="btn btn-primary" onclick="openFibonacciPage()">🔍 打开斐波规律研究页面</button>
                </div>
            </div>
        </div>

        <!-- 多空势能场模型Tab -->
        <div id="momentumField" class="tab-content">
            <h3>⚡ 多空势能场模型</h3>
            <div class="form-group">
                <p>基于物理学势能场理论的多空力量分析模型，通过势能函数和梯度计算预测价格走势</p>
                
                <div class="info-box">
                    <h4>模型核心算法：</h4>
                    <ul>
                        <li><strong>势能函数 Φ(P,t)</strong>：衡量多空双方力量综合作用</li>
                        <li><strong>趋势动能系数 α</strong>：当前价格变动趋势的权重</li>
                        <li><strong>关键位引力系数 β</strong>：关键价格位的引力强度</li>
                        <li><strong>势能梯度 ∇Φ</strong>：生成交易信号的关键指标</li>
                    </ul>
                </div>

                <div class="form-group">
                    <label for="momentumSymbol">选择标的：</label>
                    <select id="momentumSymbol" class="form-control">
                        <option value="HUSDT.P">$HUSDT.P (永续合约)</option>
                        <option value="H">$H</option>
                        <option value="KGEN">$KGEN</option>
                        <option value="LA">$LA</option>
                        <option value="F">$F</option>
                        <option value="BANK">$BANK</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="momentumTimeframe">时间周期：</label>
                    <select id="momentumTimeframe" class="form-control">
                        <option value="5m">5分钟</option>
                        <option value="15m">15分钟</option>
                        <option value="1h">1小时</option>
                        <option value="4h">4小时</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="alphaParam">趋势动能系数 α：</label>
                    <input type="number" id="alphaParam" class="form-control" value="0.3" step="0.1" min="0" max="1">
                </div>

                <div class="form-group">
                    <label for="betaParam">关键位引力系数 β：</label>
                    <input type="number" id="betaParam" class="form-control" value="0.7" step="0.1" min="0" max="1">
                </div>

                <div class="form-group">
                    <button class="btn btn-primary" onclick="runMomentumFieldAnalysis()">🚀 开始势能场分析</button>
                    <button class="btn btn-secondary" onclick="runMomentumFieldBacktest()">📊 运行回测</button>
                </div>

                <div id="momentumFieldResults" class="results-container"></div>
                <div id="momentumFieldChart" style="width: 100%; height: 500px; margin-top: 20px;"></div>
            </div>
        </div>

        <!-- 斐波概率预测Tab -->
        <div id="fibonacciProb" class="tab-content">
            <h3>🎯 斐波概率预测模型</h3>
            <div class="form-group">
                <p>基于价格行为模式和强度因子的斐波那契扩展位概率预测系统</p>
                
                <div class="info-box">
                    <h4>模型核心因子：</h4>
                    <ul>
                        <li><strong>价格运动速度</strong>：分析价格变化率</li>
                        <li><strong>量能累积强度</strong>：成交量与价格变化的综合</li>
                        <li><strong>盘整时间强度</strong>：突破前整理时间和强度</li>
                        <li><strong>假突破识别</strong>：识别和评估假突破强度</li>
                        <li><strong>关键区间盘整</strong>：1.0和0.618区间的盘整分析</li>
                    </ul>
                </div>

                <div class="form-group">
                    <label for="fibProbSymbol">选择标的：</label>
                    <select id="fibProbSymbol" class="form-control">
                        <option value="H">$H</option>
                        <option value="KGEN">$KGEN</option>
                        <option value="BANK">$BANK</option>
                        <option value="LA">$LA</option>
                        <option value="F">$F</option>
                        <option value="LIGHT">$LIGHT</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="fibProbTimeframe">时间周期：</label>
                    <select id="fibProbTimeframe" class="form-control">
                        <option value="4h">4小时</option>
                        <option value="1d">1天</option>
                        <option value="1h">1小时</option>
                        <option value="15m">15分钟</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="fibProbDays">分析天数：</label>
                    <select id="fibProbDays" class="form-control">
                        <option value="30">30天</option>
                        <option value="60">60天</option>
                        <option value="120" selected>120天（4个月）</option>
                        <option value="180">180天</option>
                    </select>
                </div>

                <div class="form-group">
                    <button class="btn btn-primary" onclick="runFibonacciProbabilityAnalysis()">🎯 开始概率分析</button>
                    <button class="btn btn-secondary" onclick="runBatchFibonacciAnalysis()">📊 批量分析前500币种</button>
                </div>

                <div id="fibonacciProbResults" class="results-container"></div>
                <canvas id="fibonacciProbChart" style="width: 100%; height: 600px; margin-top: 20px;"></canvas>
                <canvas id="fibonacciProbChartDown" style="width: 100%; height: 600px; margin-top: 20px;"></canvas>
            </div>
        </div>

        <!-- K线绘制（内嵌版） -->
        <div id="klineDraw" class="tab-content">
            <h3>📉 专业K线绘制</h3>
            <p class="muted">基于 TradingView Lightweight Charts；支持自然语言解析支撑/阻力/备注、点击加线、拖拽、保存/导入/导出、导出图表PNG。</p>

            <div class="form-group">
                <label>自然语言描述</label>
                <textarea id="kd_nlp" class="form-control" rows="3" placeholder="例：币种 $BTC，时间周期 4小时；支撑位：61200, 60000；阻力位：63500；备注：突破阻力加仓"></textarea>
                <div style="margin-top:8px;">
                    <button class="btn btn-primary" onclick="KLINE.parse()">解析</button>
                    <button class="btn" onclick="KLINE.clearAll()">清空</button>
                </div>
            </div>

            <div class="form-group">
                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                    <div style="flex:1; min-width:220px;">
                        <label>币种（现货，如 BTCUSDT）</label>
                        <input id="kd_symbol" class="form-control" value="BTCUSDT">
                    </div>
                    <div>
                        <label>时间周期</label>
                        <select id="kd_timeframe" class="form-control">
                            <option value="1d">1天</option>
                            <option value="4h" selected>4小时</option>
                            <option value="1h">1小时</option>
                        </select>
                    </div>
                    <div>
                        <label>数据源</label>
                        <select id="kd_source" class="form-control">
                            <option value="gate" selected>Gate.io</option>
                            <option value="bybit">Bybit</option>
                        </select>
                    </div>
                    <div>
                        <label>点击添加</label>
                        <select id="kd_clickMode" class="form-control">
                            <option value="none" selected>关闭</option>
                            <option value="support">支撑</option>
                            <option value="resistance">阻力</option>
                            <option value="text">文本</option>
                        </select>
                    </div>
                </div>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 2fr; gap: 12px; align-items:start;">
                <div>
                    <div class="form-group">
                        <label>支撑位</label>
                        <div id="kd_supportLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_supportAdd" class="form-control" placeholder="输入价格">
                            <button class="btn" onclick="KLINE.addLevel('support')">添加支撑</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>阻力位</label>
                        <div id="kd_resistanceLevels" class="results-container" style="max-height:180px; overflow:auto;"></div>
                        <div style="display:flex; gap:8px; margin-top:6px;">
                            <input id="kd_resistanceAdd" class="form-control" placeholder="输入价格">
                            <button class="btn" onclick="KLINE.addLevel('resistance')">添加阻力</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>备注</label>
                        <input id="kd_remarks" class="form-control" placeholder="示例：突破阻力加仓，回踩支撑减仓">
                    </div>
                    <div class="form-group" style="display:flex; gap:8px; flex-wrap:wrap;">
                        <button class="btn btn-primary" onclick="KLINE.drawChart()">绘制图表</button>
                        <button class="btn" onclick="KLINE.applyLevels()">应用水平线</button>
                        <button class="btn" id="kd_autoBtn" onclick="KLINE.toggleAutoRefresh()">开启自动刷新</button>
                        <button class="btn" onclick="KLINE.exportPNG()">导出图表PNG</button>
                        <button class="btn" onclick="KLINE.addText()">添加文本注释</button>
                    </div>
                    <div class="form-group" style="display:flex; gap:8px; flex-wrap:wrap;">
                        <input id="kd_saveName" class="form-control" placeholder="保存名称（可选）">
                        <button class="btn" onclick="KLINE.saveConfig()">保存到服务器</button>
                        <button class="btn" onclick="KLINE.loadSavedList()">加载保存列表</button>
                        <button class="btn" onclick="KLINE.exportJSON()">导出配置JSON</button>
                        <button class="btn" onclick="KLINE.exportCSV()">导出水平线CSV</button>
                        <input type="file" id="kd_importFile" accept="application/json" onchange="KLINE.importJSON(this)">
                    </div>
                    <div id="kd_savedList" class="results-container" style="max-height:200px; overflow:auto;"></div>
                    <div id="kd_status" class="muted" style="margin-top:6px;"></div>
                </div>
                <div>
                    <div id="kd_chart" style="height:620px; position:relative; background:#0f111a; z-index:10; pointer-events:auto; touch-action:none;"></div>
                </div>
            </div>
        </div>

        <!-- 系统管理Tab -->
        <div id="management" class="tab-content">
            <h3>系统管理</h3>
            <div class="form-group">
                <button class="btn btn-warning" onclick="clearCache()">清除缓存</button>
                <button class="btn" onclick="downloadCSV()">下载CSV报告</button>
                <button class="btn" onclick="exportData()">导出数据</button>
                <button class="btn" onclick="importData()">导入数据</button>
                <a class="btn" href="/kline-draw" target="_blank">打开K线绘制（新页）</a>
            </div>
            
            <div class="form-group">
                <h4>背景控制</h4>
                <button class="btn btn-info" onclick="toggleVideoBackground()">切换背景模式</button>
                <button class="btn btn-secondary" onclick="toggleBackground()">开关背景</button>
                <label>背景透明度: <input type="range" min="10" max="100" value="30" onchange="adjustVideoOpacity(this.value)"></label>
                <span id="opacityValue">30%</span>
            </div>
            <div class="form-group">
                <label>系统设置：</label>
                <input type="number" class="form-control" id="refreshInterval" placeholder="刷新间隔(秒)" value="30">
                <input type="number" class="form-control" id="maxPositions" placeholder="最大持仓数" value="10">
                <input type="number" class="form-control" id="stopLoss" placeholder="止损百分比" value="5">
            </div>
            <div id="systemStatus" class="results-container">
                <h4>系统状态</h4>
                <div id="statusContent">
                    <p>正在加载系统状态...</p>
                </div>
            </div>
        </div>


        <!-- 状态显示区域 -->
        <div id="statusArea"></div>
    </div>
    
    <!-- 新增币种模态对话框 -->
    <div id="addSymbolModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">新增币种</span>
                <span class="close" onclick="closeAddSymbolModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>请输入要新增的币种（用逗号分隔）：</label>
                    <textarea class="form-control" id="newSymbolsInput" rows="4" placeholder="例如: BTC, ETH, ADA, DOT, LINK, UNI"></textarea>
                </div>
                <div class="form-group">
                    <p style="color: #ffc107; font-size: 14px;">
                        💡 提示：新增的币种将被保存到系统中，下次分析时会包含这些币种。
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeAddSymbolModal()">取消</button>
                <button class="btn btn-success" onclick="addNewSymbols()">确认添加</button>
            </div>
        </div>
    </div>

    <!-- 导入币种模态对话框 -->
    <div id="importSymbolModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">导入币种列表</span>
                <span class="close" onclick="closeImportModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>选择CSV文件：</label>
                    <input type="file" id="importFileInput" accept=".csv" class="form-control">
                </div>
                <div class="form-group">
                    <p style="color: #ffc107; font-size: 14px;">
                        💡 提示：请选择包含币种列表的CSV文件。系统会自动去重，保留原有币种。
                    </p>
                    <p style="color: #17a2b8; font-size: 12px;">
                        📋 CSV格式：第一列为币种名称，支持BTC、BTCUSDT等格式
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">取消</button>
                <button class="btn btn-success" onclick="importSymbols()">确认导入</button>
            </div>
        </div>
    </div>

    <script>
        let currentResults = [];
        
        // 分页和筛选相关变量
        let pageSize = 20;
        let filteredResults = [];
        let sortOrder = 'asc';
        
        // 币种管理相关变量
        let totalSymbols = 130; // 默认币种数量
        
        // 日内交易相关变量
        let intradayResults = [];
        let intradaySignals = [];
        let filteredIntradayResults = [];
        
        // 图表相关变量
        let emaChart = null;
        let currentChartSymbol = '';
        let currentChartTimeframe = '5m';
        let chartData = null;

        // showTab函数已移到HTML前面定义

                 // 分析默认币种 - 分批处理版本
         async function analyzeDefault() {
             const batchSize = 50; // 每批处理50个币种
             let allResults = [];
             let currentBatch = 0;
             
             showStatus(`正在分析全部${totalSymbols}个币种（分批处理）...`, 'success');
             
             try {
                 while (true) {
                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时
                     
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: [],
                             force_refresh: document.getElementById('forceRefresh').checked,
                             batch_size: batchSize,
                             batch_index: currentBatch
                         }),
                         signal: controller.signal
                     });
                     
                     clearTimeout(timeoutId);

                const data = await response.json();
                if (data.success) {
                         // 合并结果
                         allResults = allResults.concat(data.results);
                         
                         // 更新进度显示
                         const progress = data.batch_info;
                         showStatus(`正在分析... 第${progress.current_batch}/${progress.total_batches}批 (${progress.processed}/${progress.total_symbols})`, 'success');
                         
                         // 实时更新显示
                         if (data.results.length > 0) {
                             showAnalysisResults(allResults);
                         }
                         
                         // 如果是最后一批，结束循环
                         if (progress.is_last_batch) {
                             break;
                         }
                         
                         currentBatch++;
                         
                         // 添加延迟，避免请求过快
                         await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    showStatus('分析失败: ' + data.error, 'error');
                         return;
                     }
                 }
                 
                 showStatus(`分析完成，共处理 ${allResults.length} 个币种`, 'success');
                 currentResults = allResults;
                 updateStats();
                 
             } catch (error) {
                 if (error.name === 'AbortError') {
                     showStatus('请求超时，请重试', 'error');
                 } else {
                     showStatus('请求失败: ' + error.message, 'error');
                 }
                 console.error('分析错误:', error);
             }
        }

        // 分析自定义币种 - 分批处理版本
        async function analyzeCustom() {
            const symbols = document.getElementById('symbolsInput').value.trim();
            if (!symbols) {
                showStatus('请输入要分析的币种', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            const batchSize = 50;
            let allResults = [];
            let currentBatch = 0;
            
            showStatus(`正在分析 ${symbolList.length} 个自定义币种（分批处理）...`, 'success');
            
            try {
                while (true) {
                     const controller = new AbortController();
                     const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时
                     
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: symbolList,
                             force_refresh: document.getElementById('forceRefresh').checked,
                             batch_size: batchSize,
                             batch_index: currentBatch
                         }),
                         signal: controller.signal
                     });
                     
                     clearTimeout(timeoutId);

                const data = await response.json();
                if (data.success) {
                        // 合并结果
                        allResults = allResults.concat(data.results);
                        
                        // 更新进度显示
                        const progress = data.batch_info;
                        showStatus(`正在分析... 第${progress.current_batch}/${progress.total_batches}批 (${progress.processed}/${progress.total_symbols})`, 'success');
                        
                        // 实时更新显示
                        if (data.results.length > 0) {
                            showAnalysisResults(allResults);
                        }
                        
                        // 如果是最后一批，结束循环
                        if (progress.is_last_batch) {
                            break;
                        }
                        
                        currentBatch++;
                        
                        // 添加延迟，避免请求过快
                        await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    showStatus('分析失败: ' + data.error, 'error');
                        return;
                    }
                }
                
                showStatus(`分析完成，共处理 ${allResults.length} 个币种`, 'success');
                currentResults = allResults;
                updateStats();
                
             } catch (error) {
                 if (error.name === 'AbortError') {
                     showStatus('请求超时，请重试', 'error');
                 } else {
                     showStatus('请求失败: ' + error.message, 'error');
                 }
                 console.error('分析错误:', error);
             }
        }

                 // 显示分析结果
         function showAnalysisResults(results) {
             console.log(`showAnalysisResults 被调用: results.length=${results.length}`);
             
             const resultsContainer = document.getElementById('analysisResults');
             
             if (results.length === 0) {
                 document.getElementById('analysisTableBody').innerHTML = '<tr><td colspan="6" style="text-align: center;">没有找到结果</td></tr>';
                 filteredResults = [];
                 currentResults = [];
                 console.warn('分析结果为空');
             } else {
                 // 为每个结果添加时间级别
                 const resultsWithTimeframe = results.map(result => ({
                     ...result,
                     timeframe: getRandomTimeframe() // 模拟时间级别，实际应该从后端获取
                 }));
                 
                 currentResults = resultsWithTimeframe;
                 filteredResults = [...resultsWithTimeframe];
                 
                 console.log(`设置 filteredResults: length=${filteredResults.length}`);
                 console.log(`设置 currentResults: length=${currentResults.length}`);
                 
                 // 重置分页
                 currentPage = 1;
                 
                 // 渲染表格
                 renderTable();
                 updatePagination();
             }
             
             resultsContainer.style.display = 'block';
         }
         
         // 模拟获取时间级别（实际应该从后端获取）
         function getRandomTimeframe() {
             const timeframes = ['12h', '1d', '3d'];
             return timeframes[Math.floor(Math.random() * timeframes.length)];
         }
         
         // 渲染表格
         function renderTable() {
             console.log(`renderTable 被调用: currentPage=${currentPage}, pageSize=${pageSize}, filteredResults.length=${filteredResults.length}`);
             
             const tbody = document.getElementById('analysisTableBody');
             if (!tbody) {
                 console.error('找不到 analysisTableBody 元素');
                 return;
             }
             
             if (!filteredResults || filteredResults.length === 0) {
                 tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">没有数据，请先运行分析</td></tr>';
                 console.warn('没有 filteredResults 数据');
                 return;
             }
             
             const startIndex = (currentPage - 1) * pageSize;
             const endIndex = startIndex + pageSize;
             const pageData = filteredResults.slice(startIndex, endIndex);
             
             console.log(`显示数据范围: ${startIndex}-${endIndex}, 当前页数据: ${pageData.length}条`);
             
             if (pageData.length === 0) {
                 tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">当前页没有数据</td></tr>';
                 return;
             }
             
             let html = '';
             pageData.forEach(result => {
                 const symbol = (result.symbol || '').replace('USDT', '');
                 const price = result.current_price ? result.current_price.toFixed(6) : 'N/A';
                 const orderPrice = result.order_price || 'N/A';
                 const timeframe = result.timeframe || '1d';
                 
                 html += `
                     <tr>
                         <td><strong>${symbol}</strong></td>
                         <td>${price}</td>
                         <td>${orderPrice}</td>
                         <td>${timeframe}</td>
                         <td></td>
                         <td>
                             <button class="action-btn action-btn-buy" onclick="viewDetails('${symbol}')">查看详情</button>
                         </td>
                     </tr>
                 `;
             });
             
             tbody.innerHTML = html;
         }

        // 保存全部币种到后端文件
        async function saveAllSymbols() {
            try {
                const res = await fetch('/save_all_symbols', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await res.json();
                if (data.success) {
                    showStatus(`保存成功：共 ${data.saved} 个币种`, 'success');
                } else {
                    showStatus('保存失败: ' + (data.error || '未知错误'), 'error');
                }
            } catch (e) {
                showStatus('请求失败: ' + e.message, 'error');
                console.error(e);
            }
        }

        // 币种分析 - 查看详情
        function viewDetails(rawSymbol) {
            try {
                const norm = (s) => (s || '').toString().trim().toUpperCase();
                const symbolNoUsdt = norm(rawSymbol).replace(/USDT$/, '');
                const matchResult = (arr) => {
                    if (!Array.isArray(arr)) return null;
                    for (const r of arr) {
                        const rs = norm(r && r.symbol);
                        if (!rs) continue;
                        if (rs === symbolNoUsdt || rs === symbolNoUsdt + 'USDT' || rs.replace(/USDT$/, '') === symbolNoUsdt) {
                            return r;
                        }
                    }
                    return null;
                };

                // 优先在当前结果集中查找
                const result = matchResult(typeof currentResults !== 'undefined' ? currentResults : [])
                              || matchResult(typeof filteredResults !== 'undefined' ? filteredResults : [])
                              || null;

                // 构建详情内容
                const sDisp = symbolNoUsdt || 'N/A';
                const price = result && typeof result.current_price === 'number' ? result.current_price.toFixed(6) : 'N/A';
                const orderPrice = result && (typeof result.order_price === 'number' || typeof result.order_price === 'string') ? result.order_price : 'N/A';
                const timeframe = result && result.timeframe ? result.timeframe : (result && result.timeframes ? Object.keys(result.timeframes).join(', ') : 'N/A');
                const dataSource = result && result.data_source ? result.data_source : 'N/A';
                const status = result && result.status ? result.status : 'N/A';
                const upperBand = result && typeof result.upper_band === 'number' ? result.upper_band.toFixed(6) : (result && result.upper_band ? result.upper_band : 'N/A');
                const middleBand = result && typeof result.middle_band === 'number' ? result.middle_band.toFixed(6) : (result && result.middle_band ? result.middle_band : 'N/A');
                const lowerBand = result && typeof result.lower_band === 'number' ? result.lower_band.toFixed(6) : (result && result.lower_band ? result.lower_band : 'N/A');

                // 创建并显示弹窗
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 720px;">
                        <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                        <h3>币种详情 - ${sDisp}</h3>
                        <div class="signal-details">
                            <div class="details-grid">
                                <div class="detail-item"><label>币种</label><span>${sDisp}</span></div>
                                <div class="detail-item"><label>时间框架</label><span>${timeframe}</span></div>
                                <div class="detail-item"><label>当前价格</label><span>${price}</span></div>
                                <div class="detail-item"><label>挂单价格</label><span>${orderPrice}</span></div>
                                <div class="detail-item"><label>上轨(Upper)</label><span>${upperBand}</span></div>
                                <div class="detail-item"><label>中轨(Middle)</label><span>${middleBand}</span></div>
                                <div class="detail-item"><label>下轨(Lower)</label><span>${lowerBand}</span></div>
                                <div class="detail-item"><label>数据源</label><span>${dataSource}</span></div>
                                <div class="detail-item"><label>状态</label><span>${status}</span></div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">关闭</button>
                        </div>
                    </div>`;
                document.body.appendChild(modal);
            } catch (e) {
                console.error('查看详情失败:', e);
                showStatus('查看详情失败: ' + e.message, 'error');
            }
        }

                 // 分页功能
         function updatePagination() {
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const pageInfo = document.getElementById('pageInfo');
             const prevBtn = document.getElementById('prevPage');
             const nextBtn = document.getElementById('nextPage');
             
             pageInfo.textContent = `第 ${currentPage} 页，共 ${totalPages} 页 (共 ${filteredResults.length} 条记录)`;
             
             prevBtn.disabled = currentPage <= 1;
             nextBtn.disabled = currentPage >= totalPages;
         }
         
         function changePage(delta) {
             console.log(`changePage 被调用: delta=${delta}, currentPage=${currentPage}, filteredResults.length=${filteredResults.length}, pageSize=${pageSize}`);
             
             if (!filteredResults || filteredResults.length === 0) {
                 showStatus('没有分析数据，请先运行币种分析', 'warning');
                 return;
             }
             
             const totalPages = Math.ceil(filteredResults.length / pageSize);
             const newPage = currentPage + delta;
             
             console.log(`计算结果: totalPages=${totalPages}, newPage=${newPage}`);
             
             if (newPage >= 1 && newPage <= totalPages) {
                 currentPage = newPage;
                 renderTable();
                 updatePagination();
                 showStatus(`切换到第${currentPage}页`, 'success');
             } else if (newPage < 1) {
                 showStatus('已经是第一页了', 'info');
             } else if (newPage > totalPages) {
                 showStatus('已经是最后一页了', 'info');
             }
         }
         
         function changePageSize() {
             pageSize = parseInt(document.getElementById('pageSize').value);
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // 排序功能
         function sortResults() {
             const sortBy = document.getElementById('sortBy').value;
             
             filteredResults.sort((a, b) => {
                 let aVal, bVal;
                 
                 switch (sortBy) {
                     case 'symbol':
                         aVal = a.symbol.toLowerCase();
                         bVal = b.symbol.toLowerCase();
                         break;
                     case 'price':
                         aVal = a.current_price || 0;
                         bVal = b.current_price || 0;
                         break;
                     case 'orderPrice':
                         aVal = a.order_price || 0;
                         bVal = b.order_price || 0;
                         break;
                     case 'timeframe':
                         aVal = a.timeframe || '';
                         bVal = b.timeframe || '';
                         break;
                     default:
                         return 0;
                 }
                 
                 if (sortOrder === 'asc') {
                     return aVal > bVal ? 1 : -1;
                 } else {
                     return aVal < bVal ? 1 : -1;
                 }
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         function toggleSortOrder() {
             const sortOrderBtn = document.getElementById('sortOrder');
             sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
             sortOrderBtn.textContent = sortOrder === 'asc' ? '↑' : '↓';
             sortResults();
         }
         
         // 筛选功能
         function filterResults() {
             const timeframeFilter = document.getElementById('timeframeFilter').value;
             const searchTerm = document.getElementById('searchSymbol').value.toLowerCase();
             
             filteredResults = currentResults.filter(result => {
                 // 时间级别筛选
                 if (timeframeFilter !== 'all' && result.timeframe !== timeframeFilter) {
                     return false;
                 }
                 
                 // 搜索筛选
                 if (searchTerm && !result.symbol.toLowerCase().includes(searchTerm)) {
                     return false;
                 }
                 
                 return true;
             });
             
             currentPage = 1;
             renderTable();
             updatePagination();
         }
         
         // 从分析结果创建挂单
         
         // 获取币种列表
         async function getSymbols() {
            try {
                const response = await fetch('/get_default_symbols');
                const data = await response.json();
                showStatus(`当前币种列表：${data.count} 个币种`, 'success');
            } catch (error) {
                showStatus('获取失败: ' + error.message, 'error');
            }
        }





        // 清除缓存
        async function clearCache() {
            try {
                const response = await fetch('/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('缓存已清除', 'success');
                } else {
                    showStatus('清除失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }

        // 下载CSV
        async function downloadCSV() {
            if (currentResults.length === 0) {
                showStatus('没有可下载的数据，请先进行分析', 'error');
                return;
            }

            try {
                const response = await fetch('/download_csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: currentResults
                    })
                });

                const data = await response.json();
                if (data.success) {
                    const blob = new Blob([data.csv_data], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = data.filename;
                    link.click();
                    showStatus('CSV文件下载成功', 'success');
                } else {
                    showStatus('下载失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }

        // 导出数据
        function exportData() {
            const data = {
                results: currentResults
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'bollinger_data.json';
            link.click();
            showStatus('数据导出成功', 'success');
        }

        // 导入数据
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        // orders and positions modules removed
                        if (data.results) currentResults = data.results;
                        
                        // updateOrdersList and updatePositionsList functions removed
                        updateStats();
                        showStatus('数据导入成功', 'success');
                    } catch (error) {
                        showStatus('数据导入失败: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // 更新统计
        function updateStats() {
            document.getElementById('analyzedCount').textContent = currentResults.length;
            // orders and positions modules removed
        }

                 // 显示状态
         function showStatus(message, type) {
             const statusArea = document.getElementById('statusArea');
             if (statusArea) {
                 statusArea.innerHTML = `<div class="status ${type}">${message}</div>`;
             } else {
                 console.error('statusArea element not found');
             }
         }
         
         // 新增币种相关函数
         function showAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'block';
             document.getElementById('newSymbolsInput').value = '';
             document.getElementById('newSymbolsInput').focus();
         }
         
         function closeAddSymbolModal() {
             document.getElementById('addSymbolModal').style.display = 'none';
         }
         
         async function addNewSymbols() {
             const symbolsInput = document.getElementById('newSymbolsInput').value.trim();
             if (!symbolsInput) {
                 showStatus('请输入要新增的币种', 'error');
                 return;
             }
             
             const symbolList = symbolsInput.split(',').map(s => s.trim()).filter(s => s);
             if (symbolList.length === 0) {
                 showStatus('请输入有效的币种', 'error');
                 return;
             }
             
             try {
                 const response = await fetch('/add_symbols', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         symbols: symbolList
                     })
                 });
                 
                 const data = await response.json();
                if (data.success) {
                    // 更新币种数量
                    totalSymbols = data.total_symbols;
                    
                    // 更新页面显示的所有币种数量元素
                    const totalSymbolsEl = document.getElementById('totalSymbols');
                    const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                    const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                    
                    if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                    if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                    if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                    
                    // 更新分析按钮文本
                    const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                    if (analyzeBtn) {
                        analyzeBtn.textContent = `分析全部${totalSymbols}个币种`;
                    }
                    
                    closeAddSymbolModal();
                    showStatus(`成功新增 ${symbolList.length} 个币种，当前总计 ${totalSymbols} 个币种`, 'success');
                    
                    // 刷新页面
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                     showStatus('新增币种失败: ' + data.error, 'error');
                 }
             } catch (error) {
                 showStatus('请求失败: ' + error.message, 'error');
             }
         }
         
         // 点击模态框外部关闭
         window.onclick = function(event) {
             const addModal = document.getElementById('addSymbolModal');
             const importModal = document.getElementById('importSymbolModal');
             if (event.target === addModal) {
                 closeAddSymbolModal();
             }
             if (event.target === importModal) {
                 closeImportModal();
             }
         }
         
         // 导出币种列表
         async function exportSymbols() {
             try {
                 showStatus('正在导出币种列表...', 'info');
                 
                 const response = await fetch('/export_symbols');
                 
                 if (response.ok) {
                     // 获取文件名
                     const contentDisposition = response.headers.get('Content-Disposition');
                     let filename = 'symbols_export.csv';
                     if (contentDisposition) {
                         const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                         if (filenameMatch) {
                             filename = filenameMatch[1];
                         }
                     }
                     
                     // 下载文件
                     const blob = await response.blob();
                     const url = window.URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = filename;
                     document.body.appendChild(a);
                     a.click();
                     window.URL.revokeObjectURL(url);
                     document.body.removeChild(a);
                     
                     showStatus('币种列表导出成功！', 'success');
                 } else {
                     const errorData = await response.json();
                     showStatus('导出失败: ' + errorData.error, 'error');
                 }
             } catch (error) {
                 showStatus('导出失败: ' + error.message, 'error');
             }
         }
         
         // 显示导入模态框
         function showImportModal() {
             document.getElementById('importSymbolModal').style.display = 'block';
             document.getElementById('importFileInput').value = '';
         }
         
         // 关闭导入模态框
         function closeImportModal() {
             document.getElementById('importSymbolModal').style.display = 'none';
         }
         
         // 导入币种列表
         async function importSymbols() {
             const fileInput = document.getElementById('importFileInput');
             const file = fileInput.files[0];
             
             if (!file) {
                 showStatus('请选择要导入的CSV文件', 'error');
                 return;
             }
             
             if (!file.name.toLowerCase().endsWith('.csv')) {
                 showStatus('请选择CSV格式的文件', 'error');
                 return;
             }
             
             try {
                 showStatus('正在导入币种列表...', 'info');
                 
                 const formData = new FormData();
                 formData.append('file', file);
                 
                 const response = await fetch('/import_symbols', {
                     method: 'POST',
                     body: formData
                 });
                 
                 const data = await response.json();
                 
                 if (data.success) {
                     // 更新币种数量
                     totalSymbols = data.total_symbols;
                     
                     // 更新页面显示的所有币种数量元素
                     const totalSymbolsEl = document.getElementById('totalSymbols');
                     const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                     const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                     
                     if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                     if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                     if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                     
                     // 更新分析按钮文本
                     const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                     if (analyzeBtn) {
                         analyzeBtn.textContent = `分析全部${totalSymbols}个币种`;
                     }
                     
                     closeImportModal();
                     showStatus(`成功导入 ${data.imported_symbols.length} 个币种，当前总计 ${totalSymbols} 个币种`, 'success');
                     
                     // 刷新页面
                     setTimeout(() => {
                         location.reload();
                     }, 2000);
                 } else {
                     showStatus('导入失败: ' + data.error, 'error');
                 }
             } catch (error) {
                 showStatus('导入失败: ' + error.message, 'error');
             }
         }
         
         // 更新币种数量
         async function updateSymbolCount() {
             try {
                 const response = await fetch('/get_symbol_count');
                 const data = await response.json();
                 
                 totalSymbols = data.count;
                 
                 // 更新所有显示币种数量的地方
                 const totalSymbolsEl = document.getElementById('totalSymbols');
                 const totalSymbolsDisplayEl = document.getElementById('totalSymbolsDisplay');
                 const analyzeButtonCountEl = document.getElementById('analyzeButtonCount');
                 
                 if (totalSymbolsEl) totalSymbolsEl.textContent = totalSymbols;
                 if (totalSymbolsDisplayEl) totalSymbolsDisplayEl.textContent = totalSymbols;
                 if (analyzeButtonCountEl) analyzeButtonCountEl.textContent = totalSymbols;
                 
                 // 更新分析按钮文本
                 const analyzeBtn = document.querySelector('button[onclick="analyzeDefault()"]');
                 if (analyzeBtn) {
                     analyzeBtn.textContent = `分析全部${totalSymbols}个币种`;
                 }
                 
                 console.log(`当前币种数量: ${totalSymbols}`);
             } catch (error) {
                 console.error('获取币种数量失败:', error);
             }
         }

        // 视频背景控制
        let videoElement = null;
        
        function initVideoBackground() {
            videoElement = document.querySelector('.video-background');
            
            if (videoElement) {
                console.log('找到视频元素，开始初始化...');
                
                // 检查视频源
                console.log('视频源:', videoElement.src);
                console.log('视频当前状态:', videoElement.readyState);
                
                videoElement.addEventListener('loadeddata', function() {
                    console.log('视频背景加载完成');
                    showStatus('视频背景加载完成', 'success');
                });
                
                videoElement.addEventListener('canplay', function() {
                    console.log('视频可以播放');
                    showStatus('视频背景可以播放', 'success');
                });
                
                videoElement.addEventListener('error', function(e) {
                    console.log('视频背景加载失败:', e);
                    showStatus('视频背景加载失败，使用动画背景', 'warning');
                    const animatedBg = document.querySelector('.animated-background');
                    if (animatedBg) {
                        animatedBg.style.display = 'block';
                    }
                });
                
                // 强制加载视频
                videoElement.load();
            } else {
                console.log('未找到视频元素');
                showStatus('未找到视频元素', 'error');
            }
        }
        
        function toggleVideoBackground() {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const overlay = document.querySelector('.video-overlay');
            
            if (video.style.display === 'none' || video.style.display === '') {
                // 切换到视频背景
                video.style.display = 'block';
                animatedBg.style.display = 'none';
                overlay.style.display = 'block';
                showStatus('已切换到视频背景', 'success');
            } else {
                // 切换到动画背景
                video.style.display = 'none';
                animatedBg.style.display = 'block';
                overlay.style.display = 'block';
                showStatus('已切换到动画背景', 'info');
            }
        }
        
        function adjustVideoOpacity(value) {
            const video = document.querySelector('.video-background');
            const animatedBg = document.querySelector('.animated-background');
            const opacity = value / 100;
            
            if (video) video.style.opacity = opacity;
            if (animatedBg) animatedBg.style.opacity = opacity;
            
            document.getElementById('opacityValue').textContent = value + '%';
            showStatus(`背景透明度已调整为 ${value}%`, 'info');
        }
        
        function toggleBackground() {
            const overlay = document.querySelector('.video-overlay');
            if (overlay.style.display === 'none') {
                overlay.style.display = 'block';
                showStatus('背景已启用', 'success');
            } else {
                overlay.style.display = 'none';
                showStatus('背景已禁用', 'info');
            }
        }
        
                 // RSI日线突破功能已移除

                 // 页面加载完成后的初始化
         document.addEventListener('DOMContentLoaded', function() {
             console.log('布林带策略系统已加载完成');
             showStatus('系统已就绪，可以开始分析', 'success');
             updateStats();
             updateSystemStatus();
             
             // 获取当前币种数量
             updateSymbolCount();
            
            // 初始化视频背景
            initVideoBackground();
            
            // 初始化图表
            waitForChartAndInit();
            initChartSymbolSelect();
            
            // 初始化动画背景（默认隐藏）
            const animatedBg = document.querySelector('.animated-background');
            if (animatedBg) {
                animatedBg.style.display = 'none';
            }
            
            // 定期更新系统状态
            setInterval(updateSystemStatus, 30000); // 每30秒更新一次
            setInterval(updateStats, 10000); // 每10秒更新一次统计
        });

        // 更新系统状态
        function updateSystemStatus() {
            const statusContent = document.getElementById('statusContent');
            const now = new Date();
            const startTime = new Date(now.getTime() - 2 * 60 * 60 * 1000); // 2小时前
            const uptime = Math.floor((now - startTime) / (1000 * 60)); // 分钟
            
            statusContent.innerHTML = `
                <p>缓存状态: 正常</p>
                <p>API连接: 正常</p>
                <p>数据更新: ${now.getMinutes()}分钟前</p>
                <p>系统运行时间: ${uptime}分钟</p>
                <p>最后更新: ${now.toLocaleTimeString()}</p>
            `;
        }
        
        // ==================== 日内交易相关函数 ====================
        
        // 分析主要币种的日内交易信号
        async function analyzeIntradaySymbols() {
            const mainSymbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'];
            showStatus(`正在分析主要币种日内交易信号...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: mainSymbols,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`日内交易信号分析完成，共处理 ${data.total} 个币种`, 'success');
                } else {
                    showStatus('日内交易分析失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 分析自定义币种的日内交易信号
        async function analyzeIntradayCustom() {
            const symbols = document.getElementById('intradaySymbolsInput').value.trim();
            if (!symbols) {
                showStatus('请输入要分析的币种', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            showStatus(`正在分析 ${symbolList.length} 个自定义币种日内交易信号...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: symbolList,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`日内交易信号分析完成，共处理 ${data.total} 个币种`, 'success');
                } else {
                    showStatus('日内交易分析失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 获取信号汇总
        async function getIntradaySignals() {
            showStatus('正在获取日内交易信号汇总...', 'success');
            
            try {
                const response = await fetch('/intraday/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbols: ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'],
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradaySignals = data.signals;
                    showIntradaySignals(data.signals);
                    showStatus(`信号汇总获取完成，共 ${data.total} 个币种`, 'success');
                } else {
                    showStatus('获取信号汇总失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 显示日内交易信号
        function showIntradaySignals(signals) {
            const signalsContainer = document.getElementById('intradaySignals');
            const tbody = document.getElementById('intradaySignalsTableBody');
            
            if (signals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">没有找到信号</td></tr>';
            } else {
                let html = '';
                signals.forEach(signal => {
                    const symbol = (signal.symbol || '').replace('USDT', '');
                    const overallSignal = signal.overall_signal;
                    const consistency = signal.signal_consistency;
                    
                    // 获取15分钟和1小时信号
                    const signal15m = signal.priority_signals['15m'] || {};
                    const signal1h = signal.priority_signals['1h'] || {};
                    
                    // 信号样式
                    let signalClass = 'status-hold';
                    let signalText = '未知';
                    if (overallSignal === 'long') {
                        signalClass = 'status-buy';
                        signalText = '多头';
                    } else if (overallSignal === 'short') {
                        signalClass = 'status-sell';
                        signalText = '空头';
                    } else if (overallSignal === 'mixed') {
                        signalClass = 'status-hold';
                        signalText = '混合';
                    }
                    
                    // 15分钟信号
                    let signal15mText = '无';
                    let signal15mClass = 'status-hold';
                    if (signal15m.signal) {
                        signal15mText = signal15m.signal;
                        signal15mClass = signal15m.signal_type === 'long' ? 'status-buy' : 'status-sell';
                    }
                    
                    // 1小时信号
                    let signal1hText = '无';
                    let signal1hClass = 'status-hold';
                    if (signal1h.signal) {
                        signal1hText = signal1h.signal;
                        signal1hClass = signal1h.signal_type === 'long' ? 'status-buy' : 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td><span class="status-badge ${signalClass}">${signalText}</span></td>
                            <td><span class="status-badge ${signal15mClass}">${signal15mText}</span></td>
                            <td><span class="status-badge ${signal1hClass}">${signal1hText}</span></td>
                            <td>${consistency}</td>
                            <td>
                                <button class="action-btn action-btn-buy" onclick="viewIntradayDetails('${symbol}')">详细</button>
                                <button class="action-btn action-btn-sell" onclick="showChart('${symbol}')">图表</button>
                            </td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
            }
            
            signalsContainer.style.display = 'block';
        }
        
        // 查看详细分析
        async function viewIntradayDetails(symbol) {
            showStatus(`正在获取 ${symbol} 的详细分析...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_symbol_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        force_refresh: document.getElementById('intradayForceRefresh').checked
                    })
                });

                const data = await response.json();
                if (data.success) {
                    intradayResults = [data.result];
                    showIntradayDetails(data.result);
                    showStatus(`${symbol} 详细分析完成`, 'success');
                } else {
                    showStatus('获取详细分析失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 显示详细分析结果
        function showIntradayDetails(result) {
            const detailsContainer = document.getElementById('intradayDetails');
            const tbody = document.getElementById('intradayDetailsTableBody');
            
            if (!result.timeframes || Object.keys(result.timeframes).length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">没有找到详细数据</td></tr>';
            } else {
                let html = '';
                Object.entries(result.timeframes).forEach(([timeframe, data]) => {
                    const symbol = (data.symbol || '').replace('USDT', '');
                    const price = data.current_price ? data.current_price.toFixed(6) : 'N/A';
                    const ema365 = data.ema365 ? data.ema365.toFixed(6) : 'N/A';
                    const ma365 = data.ma365 ? data.ma365.toFixed(6) : 'N/A';
                    const anchor = data.anchor_point ? data.anchor_point.toFixed(6) : 'N/A';
                    const signal = data.signal || '未知';
                    const strength = data.strength || '弱';
                    const deviation = data.deviation || 0;
                    
                    // 信号样式
                    let signalClass = 'status-hold';
                    if (data.signal_type === 'long') {
                        signalClass = 'status-buy';
                    } else if (data.signal_type === 'short') {
                        signalClass = 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${timeframe}</td>
                            <td>${price}</td>
                            <td>${ema365}</td>
                            <td>${ma365}</td>
                            <td>${anchor}</td>
                            <td><span class="status-badge ${signalClass}">${signal}</span></td>
                            <td>${strength}</td>
                            <td>${deviation}%</td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
                filteredIntradayResults = Object.values(result.timeframes);
            }
            
            detailsContainer.style.display = 'block';
        }
        
        // 筛选日内交易结果
        function filterIntradayResults() {
            const timeframeFilter = document.getElementById('intradayTimeframeFilter').value;
            const signalFilter = document.getElementById('intradaySignalFilter').value;
            const searchTerm = document.getElementById('intradaySearchSymbol').value.toLowerCase();
            
            if (!intradayResults.length) return;
            
            const result = intradayResults[0];
            if (!result.timeframes) return;
            
            filteredIntradayResults = Object.values(result.timeframes).filter(data => {
                // 时间周期筛选
                if (timeframeFilter !== 'all' && data.timeframe !== timeframeFilter) {
                    return false;
                }
                
                // 信号类型筛选
                if (signalFilter !== 'all' && data.signal_type !== signalFilter) {
                    return false;
                }
                
                // 搜索筛选
                if (searchTerm && !data.symbol.toLowerCase().includes(searchTerm)) {
                    return false;
                }
                
                return true;
            });
            
            // 重新渲染表格
            const tbody = document.getElementById('intradayDetailsTableBody');
            if (filteredIntradayResults.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center;">没有匹配的数据</td></tr>';
            } else {
                let html = '';
                filteredIntradayResults.forEach(data => {
                    const symbol = (data.symbol || '').replace('USDT', '');
                    const price = data.current_price ? data.current_price.toFixed(6) : 'N/A';
                    const ema365 = data.ema365 ? data.ema365.toFixed(6) : 'N/A';
                    const ma365 = data.ma365 ? data.ma365.toFixed(6) : 'N/A';
                    const anchor = data.anchor_point ? data.anchor_point.toFixed(6) : 'N/A';
                    const signal = data.signal || '未知';
                    const strength = data.strength || '弱';
                    const deviation = data.deviation || 0;
                    
                    // 信号样式
                    let signalClass = 'status-hold';
                    if (data.signal_type === 'long') {
                        signalClass = 'status-buy';
                    } else if (data.signal_type === 'short') {
                        signalClass = 'status-sell';
                    }
                    
                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${data.timeframe}</td>
                            <td>${price}</td>
                            <td>${ema365}</td>
                            <td>${ma365}</td>
                            <td>${anchor}</td>
                            <td><span class="status-badge ${signalClass}">${signal}</span></td>
                            <td>${strength}</td>
                            <td>${deviation}%</td>
                        </tr>
                    `;
                });
                
                tbody.innerHTML = html;
            }
        }
        
        // 清除日内交易缓存
        async function clearIntradayCache() {
            try {
                const response = await fetch('/intraday/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('日内交易缓存已清除', 'success');
                } else {
                    showStatus('清除缓存失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // ==================== 日内超短交易相关函数 ====================
        
        // 分析主要币种的超短交易信号
        async function analyzeUltraShortSymbols() {
            showStatus(`正在获取币安前200个币种...`, 'success');
            
            try {
                // 首先获取币安前200个币种
                const symbolsResponse = await fetch('/ultra_short/get_top_symbols', {
                    method: 'GET'
                });
                
                const symbolsData = await symbolsResponse.json();
                if (!symbolsData.success) {
                    showStatus('获取币种列表失败: ' + symbolsData.error, 'error');
                    return;
                }
                
                const symbols = symbolsData.symbols;
                showStatus(`获取到 ${symbols.length} 个币安期货永续合约币种，开始分析超短交易信号...`, 'success');
                
                // 分析超短交易信号
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: symbols })
                });

                const data = await response.json();
                if (data.success) {
                    showUltraShortSignals(data.signals, 1.5); // 默认显示风险收益比≥1.5的信号
                    showStatus(`超短交易信号分析完成，共处理 ${data.total} 个币种`, 'success');
                } else {
                    showStatus('超短交易分析失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 分析自定义币种的超短交易信号
        async function analyzeUltraShortCustom() {
            const symbols = document.getElementById('ultraShortSymbolsInput').value.trim();
            if (!symbols) {
                showStatus('请输入要分析的币种', 'error');
                return;
            }

            const symbolList = symbols.split(',').map(s => s.trim()).filter(s => s);
            showStatus(`正在分析 ${symbolList.length} 个自定义币种超短交易信号...`, 'success');
            
            try {
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: symbolList })
                });

                const data = await response.json();
                if (data.success) {
                    showUltraShortSignals(data.signals, 1.5); // 默认显示风险收益比≥1.5的信号
                    showStatus(`超短交易信号分析完成，共处理 ${data.total} 个币种`, 'success');
                } else {
                    showStatus('超短交易分析失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 全局变量存储所有信号
        let allUltraShortSignals = [];
        
        // 应用风险收益比过滤
        function applyRiskRewardFilter() {
            const filterValue = parseFloat(document.getElementById('riskRewardFilter').value);
            showUltraShortSignals(allUltraShortSignals, filterValue);
        }
        
        // 显示超短交易信号
        function showUltraShortSignals(signals, minRiskReward = 1.5) {
            const tbody = document.getElementById('ultraShortSignalsTableBody');
            
            // 保存所有信号到全局变量
            allUltraShortSignals = signals;
            
            // 过滤风险收益比
            const filteredSignals = signals.filter(signal => {
                return signal.risk_reward_ratio >= minRiskReward;
            });
            
            if (filteredSignals.length === 0) {
                const filterText = minRiskReward === 0 ? '暂无超短交易信号' : `暂无收益率${minRiskReward}%及以上的超短交易信号`;
                tbody.innerHTML = `<tr><td colspan="9" style="text-align: center; color: #666;">${filterText}</td></tr>`;
                return;
            }
            
            let html = '';
            filteredSignals.forEach(signal => {
                let opportunityClass = 'warning';
                let opportunityText = signal.trading_opportunity;
                
                if (signal.trading_opportunity === '做空机会') {
                    opportunityClass = 'danger';
                } else if (signal.trading_opportunity === '做多机会') {
                    opportunityClass = 'success';
                } else if (signal.trading_opportunity.includes('做空机会') && signal.trading_opportunity.includes('一般')) {
                    opportunityClass = 'info';
                } else if (signal.trading_opportunity.includes('做多机会') && signal.trading_opportunity.includes('一般')) {
                    opportunityClass = 'info';
                } else if (signal.trading_opportunity.includes('做空机会')) {
                    opportunityClass = 'secondary';
                } else if (signal.trading_opportunity.includes('做多机会')) {
                    opportunityClass = 'secondary';
                }
                
                // 计算潜在收益
                let potentialProfit = 0;
                if (signal.entry_price > 0) {
                    if (signal.trading_opportunity.includes('做空')) {
                        potentialProfit = signal.entry_price - signal.profit_target;
                    } else if (signal.trading_opportunity.includes('做多')) {
                        potentialProfit = signal.profit_target - signal.entry_price;
                    }
                }
                
                // 根据风险收益比设置颜色
                let ratioClass = '';
                if (signal.risk_reward_ratio > 2) {
                    ratioClass = 'text-success font-weight-bold';
                } else if (signal.risk_reward_ratio > 1) {
                    ratioClass = 'text-warning';
                } else if (signal.risk_reward_ratio > 0) {
                    ratioClass = 'text-danger';
                } else {
                    ratioClass = 'text-muted';
                }
                
                html += `
                    <tr>
                        <td><strong>${signal.symbol}</strong></td>
                        <td>${signal.interval_low} - ${signal.interval_high}</td>
                        <td>${signal.current_price}</td>
                        <td><span class="status-${opportunityClass}">${opportunityText}</span></td>
                        <td><strong>${signal.entry_price || '-'}</strong></td>
                        <td><strong>${signal.take_profit || signal.profit_target}</strong></td>
                        <td class="${ratioClass}"><strong>${signal.risk_reward_ratio}%</strong></td>
                        <td><small>${signal.signal_time || '-'}</small></td>
                        <td>
                            <button class="btn btn-sm btn-info" onclick="showUltraShortDetails('${signal.symbol}')">详情</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // 更新状态显示
            const totalCount = signals.length;
            const filteredCount = filteredSignals.length;
            const filterText = minRiskReward === 0 ? '显示全部' : `收益率≥${minRiskReward}%`;
            showStatus(`超短交易信号: 总计${totalCount}个，${filterText}显示${filteredCount}个`, 'success');
        }
        
        // 显示超短交易详情
        async function showUltraShortDetails(symbol) {
            try {
                const response = await fetch('/ultra_short/get_signal_details', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });

                const data = await response.json();
                if (data.success) {
                    const detailsContainer = document.getElementById('ultraShortDetails');
                    const detailsContent = document.getElementById('ultraShortDetailsContent');
                    
                    const latest1h = data.chart_data['1h'];
                    const latest1m = data.chart_data['1m'];
                    
                    detailsContent.innerHTML = `
                        <div class="signal-details">
                            <h5>${symbol} 超短交易详情</h5>
                            <div class="details-grid">
                                <div class="detail-item">
                                    <label>1小时EMA365:</label>
                                    <span>${latest1h.ema365[latest1h.ema365.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>1小时MA365:</label>
                                    <span>${latest1h.ma365[latest1h.ma365.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>1分钟EMA233:</label>
                                    <span>${latest1m.ema233[latest1m.ema233.length - 1] || 'N/A'}</span>
                                </div>
                                <div class="detail-item">
                                    <label>当前价格:</label>
                                    <span>${latest1h.prices[latest1h.prices.length - 1] || 'N/A'}</span>
                                </div>
                            </div>
                            <div class="trading-signals">
                                <h6>交易信号：</h6>
                                <div class="signal-item">
                                    <span class="signal-label">做空信号:</span>
                                    <span class="signal-value">当价格 > ${Math.max(latest1h.ema365[latest1h.ema365.length - 1] || 0, latest1h.ma365[latest1h.ma365.length - 1] || 0).toFixed(2)}</span>
                                </div>
                                <div class="signal-item">
                                    <span class="signal-label">做多信号:</span>
                                    <span class="signal-value">当价格 < ${Math.min(latest1h.ema365[latest1h.ema365.length - 1] || 0, latest1h.ma365[latest1h.ma365.length - 1] || 0).toFixed(2)}</span>
                                </div>
                                <div class="signal-item">
                                    <span class="signal-label">止盈目标:</span>
                                    <span class="signal-value">${latest1m.ema233[latest1m.ema233.length - 1] || 'N/A'}</span>
                                </div>
                            </div>
                            <div class="strategy-explanation">
                                <h6>策略说明：</h6>
                                <p>1. <strong>做空策略:</strong> 当价格突破1小时EMA365/MA365区间上沿时，在区间上沿做空</p>
                                <p>2. <strong>做多策略:</strong> 当价格跌破1小时EMA365/MA365区间下沿时，在区间下沿做多</p>
                                <p>3. <strong>止盈目标:</strong> 统一设置为1分钟EMA233位置</p>
                                <p>4. <strong>风险控制:</strong> 风险收益比应大于1.5才考虑入场</p>
                            </div>
                        </div>
                    `;
                    
                    detailsContainer.style.display = 'block';
                } else {
                    showStatus('获取详情失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 获取币安前200个币种列表
        async function getTopSymbols() {
            showStatus('正在获取币安前200个币种...', 'success');
            
            try {
                const response = await fetch('/ultra_short/get_top_symbols', {
                    method: 'GET'
                });
                
                const data = await response.json();
                if (data.success) {
                    const symbols = data.symbols;
                    const top10 = data.top_10;
                    
                    showStatus(`成功获取 ${symbols.length} 个币种，前10个: ${top10.join(', ')}`, 'success');
                    
                    // 显示币种列表
                    const symbolsList = symbols.join(', ');
                    document.getElementById('ultraShortSymbolsInput').value = symbolsList;
                    
                    // 显示币种统计信息
                    const detailsContainer = document.getElementById('ultraShortDetails');
                    const detailsContent = document.getElementById('ultraShortDetailsContent');
                    
                    detailsContent.innerHTML = `
                        <div class="signal-details">
                            <h5>币安前200个USDT交易对</h5>
                            <div class="details-grid">
                                <div class="detail-item">
                                    <label>总币种数量:</label>
                                    <span>${symbols.length}</span>
                                </div>
                                <div class="detail-item">
                                    <label>前10个币种:</label>
                                    <span>${top10.join(', ')}</span>
                                </div>
                            </div>
                            <div class="strategy-explanation">
                                <h6>说明：</h6>
                                <p>1. 按24小时交易量排序，取前200个USDT交易对</p>
                                <p>2. 数据实时从币安API获取</p>
                                <p>3. 点击"分析超短机会"按钮开始分析这些币种</p>
                            </div>
                        </div>
                    `;
                    
                    detailsContainer.style.display = 'block';
                } else {
                    showStatus('获取币种列表失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // 验证币种
        async function validateSymbol() {
            const symbol = document.getElementById('ultraShortSymbolsInput').value.trim();
            if (!symbol) {
                showStatus('请输入要验证的币种', 'error');
                return;
            }
            
            showStatus(`正在验证币种 ${symbol}...`, 'success');
            
            try {
                const response = await fetch('/ultra_short/validate_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                if (data.success) {
                    const status = data.is_valid ? '有效' : '无效';
                    const color = data.is_valid ? 'success' : 'error';
                    showStatus(`币种 ${symbol} 验证结果: ${status} (标准化: ${data.normalized_symbol}, 数据量: ${data.data_count})`, color);
                } else {
                    showStatus('验证失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('验证请求失败: ' + error.message, 'error');
            }
        }
        
        // 清除超短交易缓存
        async function clearUltraShortCache() {
            try {
                const response = await fetch('/ultra_short/clear_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (data.success) {
                    showStatus('超短交易缓存已清除', 'success');
                } else {
                    showStatus('清除缓存失败: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
            }
        }
        
        // ==================== 日志诊断相关函数 ====================
        
        let logMonitoringInterval = null;
        let allLogs = [];
        
        // 开始监控日志
        async function startLogMonitoring() {
            if (logMonitoringInterval) {
                clearInterval(logMonitoringInterval);
            }
            
            showStatus('开始监控日志...', 'success');
            addLogEntry('INFO', '开始监控系统日志');
            
            // 立即获取一次日志
            await fetchLogs();
            
            // 每2秒获取一次新日志
            logMonitoringInterval = setInterval(fetchLogs, 2000);
        }
        
        // 获取日志
        async function fetchLogs() {
            try {
                const response = await fetch('/logs/get_logs?limit=50');
                const data = await response.json();
                
                if (data.success) {
                    // 检查是否有新日志
                    const newLogs = data.logs.filter(log => 
                        !allLogs.some(existingLog => 
                            existingLog.timestamp === log.timestamp && 
                            existingLog.message === log.message
                        )
                    );
                    
                    // 添加新日志
                    newLogs.forEach(log => {
                        allLogs.push(log);
                        addLogEntry(log.level, log.message, log.timestamp);
                    });
                    
                    // 限制日志数量
                    if (allLogs.length > 500) {
                        allLogs = allLogs.slice(-500);
                    }
                    
                    updateLogCount();
                }
            } catch (error) {
                console.error('获取日志失败:', error);
            }
        }
        
        // 添加日志条目
        function addLogEntry(level, message, timestamp = null) {
            const logsContent = document.getElementById('logsContent');
            const time = timestamp || new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${level.toLowerCase()}`;
            
            const showTimestamp = document.getElementById('showTimestamp').checked;
            const timeStr = showTimestamp ? `[${time}]` : '';
            
            logEntry.innerHTML = `
                <span class="log-time">${timeStr}</span>
                <span class="log-level">${level}</span>
                <span class="log-message">${message}</span>
            `;
            
            logsContent.appendChild(logEntry);
            
            // 自动滚动
            if (document.getElementById('autoScroll').checked) {
                logsContent.scrollTop = logsContent.scrollHeight;
            }
        }
        
        // 更新日志计数
        function updateLogCount() {
            const logCount = document.getElementById('logCount');
            logCount.textContent = `(${allLogs.length}条)`;
        }
        
        // 清空日志
        async function clearLogs() {
            try {
                const response = await fetch('/logs/clear_logs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    allLogs = [];
                    document.getElementById('logsContent').innerHTML = '';
                    addLogEntry('INFO', '日志已清空');
                    updateLogCount();
                    showStatus('日志已清空', 'success');
                }
            } catch (error) {
                showStatus('清空日志失败: ' + error.message, 'error');
            }
        }
        
        // 测试超短交易(带日志)
        async function testUltraShortWithLogs() {
            addLogEntry('INFO', '开始测试超短交易分析...');
            
            try {
                const response = await fetch('/ultra_short/get_signals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbols: ['BTC', 'ETH', 'DOT'] })
                });
                
                const data = await response.json();
                if (data.success) {
                    addLogEntry('INFO', `超短交易测试完成，共分析 ${data.total} 个币种`);
                    showStatus('超短交易测试完成', 'success');
                } else {
                    addLogEntry('ERROR', `超短交易测试失败: ${data.error}`);
                    showStatus('超短交易测试失败: ' + data.error, 'error');
                }
            } catch (error) {
                addLogEntry('ERROR', `超短交易测试异常: ${error.message}`);
                showStatus('测试失败: ' + error.message, 'error');
            }
        }
        
        // 导出日志
        async function exportLogs() {
            try {
                const levelFilter = document.getElementById('logLevelFilter').value;
                const searchTerm = document.getElementById('logSearch').value;
                
                let url = '/logs/export_logs?';
                if (levelFilter !== 'all') url += `level=${levelFilter}&`;
                if (searchTerm) url += `search=${encodeURIComponent(searchTerm)}&`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success) {
                    // 创建下载链接
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url2 = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url2;
                    a.download = `logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url2);
                    
                    showStatus(`日志已导出，共 ${data.count} 条`, 'success');
                }
            } catch (error) {
                showStatus('导出日志失败: ' + error.message, 'error');
            }
        }
        
        // 过滤日志
        function filterLogs() {
            const levelFilter = document.getElementById('logLevelFilter').value;
            const searchTerm = document.getElementById('logSearch').value.toLowerCase();
            const logEntries = document.querySelectorAll('.log-entry');
            
            logEntries.forEach(entry => {
                const level = entry.querySelector('.log-level').textContent;
                const message = entry.querySelector('.log-message').textContent.toLowerCase();
                
                let show = true;
                
                if (levelFilter !== 'all' && level !== levelFilter) {
                    show = false;
                }
                
                if (searchTerm && !message.includes(searchTerm)) {
                    show = false;
                }
                
                entry.style.display = show ? 'block' : 'none';
            });
        }
        
        // 搜索日志
        function searchLogs() {
            filterLogs();
        }
        
        // ==================== 图表相关函数 ====================
        
        // 价格标签插件
        const priceLabelsPlugin = {
            id: 'priceLabels',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                const datasets = chart.data.datasets;
                
                datasets.forEach((dataset, datasetIndex) => {
                    if (dataset.label && (dataset.label.startsWith('价格:') || dataset.label.includes('信号:'))) {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        const data = dataset.data;
                        
                        data.forEach((point, index) => {
                            if (meta.data[index]) {
                                const element = meta.data[index];
                                const x = element.x;
                                const y = element.y;
                                
                                ctx.save();
                                
                                if (dataset.label.startsWith('价格:')) {
                                    // 绘制价格标签
                                    const price = dataset.label.replace('价格: ', '').split(' (')[0];
                                    const signalDesc = dataset.label.includes('(') ? 
                                        dataset.label.split('(')[1].replace(')', '') : '';
                                    
                                    // 使用自定义颜色或默认颜色
                                    const labelBg = dataset.labelBg || 'rgba(0, 0, 0, 0.7)';
                                    const labelColor = dataset.labelColor || '#ffd700';
                                    
                                    // 计算文本宽度
                                    ctx.font = 'bold 12px Arial';
                                    const priceWidth = ctx.measureText(price).width;
                                    const descWidth = signalDesc ? ctx.measureText(signalDesc).width : 0;
                                    const maxWidth = Math.max(priceWidth, descWidth);
                                    
                                    // 绘制背景
                                    ctx.fillStyle = labelBg;
                                    ctx.fillRect(x - maxWidth/2 - 5, y - 25, maxWidth + 10, 20);
                                    
                                    // 绘制价格文本
                                    ctx.fillStyle = labelColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(price, x, y - 12);
                                    
                                    // 绘制信号描述（如果有）
                                    if (signalDesc) {
                                        ctx.font = '10px Arial';
                                        ctx.fillText(signalDesc, x, y - 2);
                                    }
                                } else if (dataset.label.includes('信号:')) {
                                    // 绘制信号描述
                                    const signalText = dataset.label.split('信号: ')[1];
                                    const isBuy = dataset.label.includes('买入');
                                    const bgColor = isBuy ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                                    const textColor = '#ffffff';
                                    
                                    // 计算文本宽度
                                    ctx.font = 'bold 10px Arial';
                                    const textWidth = ctx.measureText(signalText).width;
                                    
                                    // 绘制背景
                                    ctx.fillStyle = bgColor;
                                    ctx.fillRect(x - textWidth/2 - 5, y - 25, textWidth + 10, 18);
                                    
                                    // 绘制文本
                                    ctx.fillStyle = textColor;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(signalText, x, y - 12);
                                }
                                
                                ctx.restore();
                            }
                        });
                    }
                });
            }
        };
        
        // 等待Chart.js加载完成后初始化
        let chartInitRetries = 0;
        const maxChartInitRetries = 50; // 最多重试50次，总共5秒
        
        function waitForChartAndInit() {
            chartInitRetries++;
            console.log(`尝试初始化Chart.js (第${chartInitRetries}次)`);
            
            if (typeof Chart !== 'undefined') {
                console.log('Chart.js已加载，开始初始化图表');
                try {
        // 注册插件
        Chart.register(priceLabelsPlugin);
                    console.log('价格标签插件注册成功');
                    
                    // 初始化图表
                    initChart();
                    console.log('图表初始化成功');
                } catch (error) {
                    console.error('图表初始化失败:', error);
                }
            } else {
                if (chartInitRetries < maxChartInitRetries) {
                    console.log(`Chart.js未加载，${100}ms后重试...`);
                    setTimeout(waitForChartAndInit, 100);
                } else {
                    console.error('Chart.js加载超时，图表功能将不可用');
                }
            }
        }
        
        // 初始化图表
        function initChart() {
            const ctx = document.getElementById('emaChart').getContext('2d');
            
            emaChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false // 使用自定义图例
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1
                        },
                        // 添加价格标签插件
                        priceLabels: {
                            enabled: true,
                            color: '#ffd700',
                            fontSize: 12,
                            fontWeight: 'bold',
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            padding: 4,
                            borderRadius: 4
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'MM-dd HH:mm'
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white'
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'white',
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // 获取图表数据
        async function getChartData(symbol, timeframe = '5m') {
            if (!symbol) {
                showStatus('请选择币种', 'error');
                return null;
            }
            
            showStatus(`正在获取 ${symbol} 图表数据...`, 'success');
            
            try {
                const response = await fetch('/intraday/get_chart_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        symbol: symbol,
                        base_timeframe: timeframe,
                        limit: 200
                    })
                });

                const data = await response.json();
                if (data.success) {
                    chartData = data;
                    showStatus(`${symbol} 图表数据获取成功`, 'success');
                    return data;
                } else {
                    showStatus('获取图表数据失败: ' + data.error, 'error');
                    return null;
                }
            } catch (error) {
                showStatus('请求失败: ' + error.message, 'error');
                return null;
            }
        }
        
        // 更新图表
        function updateChart(data) {
            if (!data || !emaChart) return;
            
            const baseData = data.base_data;
            const timeframeData = data.timeframe_data;
            const crossPoints = data.cross_points;
            
            // 准备时间标签
            const labels = baseData.timestamps.map(ts => new Date(ts));
            
            // 定义颜色
            const colors = {
                '1m': '#ff6b6b',    // 红色
                '2m': '#4ecdc4',    // 青色
                '3m': '#45b7d1',    // 蓝色
                '5m': '#96ceb4',    // 绿色
                'ema89': '#feca57', // 黄色
                'ema144': '#ff6b9d', // 粉红色
                'ema233': '#ff9ff3', // 粉色
                'ema365': '#54a0ff', // 蓝色
                'ma89': '#feca57',  // 黄色（虚线）
                'ma144': '#ff6b9d', // 粉红色（虚线）
                'ma233': '#ff9ff3', // 粉色（虚线）
                'ma365': '#54a0ff'  // 蓝色（虚线）
            };
            
            // 准备数据集
            const datasets = [];
            
            // 添加价格线（增加粗度）
            datasets.push({
                label: '价格',
                data: baseData.prices.map((price, index) => ({
                    x: labels[index],
                    y: price
                })),
                borderColor: '#ffffff',
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 3, // 从2增加到3
                pointRadius: 0,
                tension: 0.1
            });
            
            // 添加多时间周期EMA365
            Object.entries(timeframeData).forEach(([timeframe, values]) => {
                if (values && values.some(v => v !== null)) {
                    datasets.push({
                        label: `${timeframe} EMA365`,
                        data: values.map((value, index) => ({
                            x: labels[index],
                            y: value
                        })).filter(point => point.y !== null),
                        borderColor: colors[timeframe],
                        backgroundColor: colors[timeframe] + '20',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1
                    });
                }
            });
            
            // 添加EMA89, EMA144, EMA233, EMA365
            if (baseData.ema89 && baseData.ema89.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA89',
                    data: baseData.ema89.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema89,
                    backgroundColor: colors.ema89 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema144 && baseData.ema144.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA144',
                    data: baseData.ema144.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema144,
                    backgroundColor: colors.ema144 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema233 && baseData.ema233.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA233',
                    data: baseData.ema233.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema233,
                    backgroundColor: colors.ema233 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ema365 && baseData.ema365.some(v => v !== null)) {
                datasets.push({
                    label: 'EMA365',
                    data: baseData.ema365.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ema365,
                    backgroundColor: colors.ema365 + '20',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            // 添加MA89, MA144, MA233, MA365（虚线）
            if (baseData.ma89 && baseData.ma89.some(v => v !== null)) {
                datasets.push({
                    label: 'MA89',
                    data: baseData.ma89.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma89,
                    backgroundColor: colors.ma89 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // 虚线样式
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma144 && baseData.ma144.some(v => v !== null)) {
                datasets.push({
                    label: 'MA144',
                    data: baseData.ma144.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma144,
                    backgroundColor: colors.ma144 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // 虚线样式
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma233 && baseData.ma233.some(v => v !== null)) {
                datasets.push({
                    label: 'MA233',
                    data: baseData.ma233.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma233,
                    backgroundColor: colors.ma233 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // 虚线样式
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            if (baseData.ma365 && baseData.ma365.some(v => v !== null)) {
                datasets.push({
                    label: 'MA365',
                    data: baseData.ma365.map((value, index) => ({
                        x: labels[index],
                        y: value
                    })).filter(point => point.y !== null),
                    borderColor: colors.ma365,
                    backgroundColor: colors.ma365 + '20',
                    borderWidth: 2,
                    borderDash: [5, 5], // 虚线样式
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            // 处理交叉点位，添加价格标签和买卖信号
            if (crossPoints) {
                // 合并所有交叉点并按时间排序
                const allCrosses = [];
                
                if (crossPoints.price_crosses) {
                    crossPoints.price_crosses.forEach(cross => {
                        allCrosses.push({
                            ...cross,
                            type: 'price_cross',
                            displayPrice: cross.price
                        });
                    });
                }
                
                if (crossPoints.indicator_crosses) {
                    crossPoints.indicator_crosses.forEach(cross => {
                        allCrosses.push({
                            ...cross,
                            type: 'indicator_cross',
                            displayPrice: cross.price
                        });
                    });
                }
                
                // 按时间排序
                allCrosses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // 处理重叠的价格标签
                const filteredCrosses = filterOverlappingPrices(allCrosses, data.base_data);
                
                // 添加价格标签
                filteredCrosses.forEach(cross => {
                    // 根据信号类型设置标签颜色
                    let labelColor = '#ffd700'; // 默认金色
                    let labelBg = 'rgba(0, 0, 0, 0.7)';
                    
                    if (cross.signalType === 'sell') {
                        labelColor = '#ff6b6b'; // 红色
                        labelBg = 'rgba(255, 0, 0, 0.8)';
                    } else if (cross.signalType === 'buy') {
                        labelColor = '#51cf66'; // 绿色
                        labelBg = 'rgba(0, 255, 0, 0.8)';
                    }
                    
                    datasets.push({
                        label: `价格: ${cross.displayPrice} (${cross.signalDescription})`,
                        data: [{
                            x: new Date(cross.timestamp),
                            y: cross.displayPrice
                        }],
                        borderColor: 'transparent',
                        backgroundColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: false,
                        pointStyle: 'circle',
                        labelColor: labelColor,
                        labelBg: labelBg
                    });
                });
                
                // 添加买卖信号
                const tradingSignals = generateTradingSignals(crossPoints);
                tradingSignals.forEach(signal => {
                    const isStrongSignal = signal.description.includes('多头排列') || signal.description.includes('空头排列');
                    const isVolumeConfirmed = signal.volume_confirmed;
                    
                    // 根据信号强度和成交量确认确定显示样式
                    let signalSize, signalColor, signalStyle;
                    
                    if (isVolumeConfirmed && isStrongSignal) {
                        // 强信号 + 成交量确认
                        signalSize = 14;
                        signalColor = signal.type === 'buy' ? '#00ff00' : '#ff0000';
                        signalStyle = 'solid';
                    } else if (isVolumeConfirmed || isStrongSignal) {
                        // 单一确认
                        signalSize = 10;
                        signalColor = signal.type === 'buy' ? '#90ee90' : '#ffa0a0';
                        signalStyle = 'solid';
                    } else {
                        // 无确认
                        signalSize = 8;
                        signalColor = signal.type === 'buy' ? '#d0f0d0' : '#ffd0d0';
                        signalStyle = 'dashed';
                    }
                    
                    const signalLabel = `${signal.type === 'buy' ? '买入' : '卖出'}信号: ${signal.description}${isVolumeConfirmed ? ' ✓' : ''}`;
                    
                    datasets.push({
                        label: signalLabel,
                        data: [{
                            x: new Date(signal.timestamp),
                            y: signal.price
                        }],
                        borderColor: signalColor,
                        backgroundColor: signalColor,
                        borderWidth: signalSize > 10 ? 4 : 3,
                        pointRadius: signalSize,
                        pointHoverRadius: signalSize + 4,
                        showLine: false,
                        pointStyle: signal.type === 'buy' ? 'triangle' : 'triangleDown',
                        borderDash: signalStyle === 'dashed' ? [5, 5] : []
                    });
                });
            }
            
            // 更新图表数据
            emaChart.data.labels = labels;
            emaChart.data.datasets = datasets;
            emaChart.update();
            
            // 更新图例
            updateChartLegend(datasets);
            
            // 更新交叉点位信息面板
            updateCrossPointsInfo(crossPoints);
        }
        
        // 更新图表图例
        function updateChartLegend(datasets) {
            const legendContainer = document.getElementById('chartLegend');
            let html = '';
            
            datasets.forEach(dataset => {
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${dataset.borderColor}"></div>
                        <span>${dataset.label}</span>
                    </div>
                `;
            });
            
            legendContainer.innerHTML = html;
        }
        
        // 显示图表
        function showChart(symbol) {
            currentChartSymbol = symbol;
            const chartSection = document.getElementById('chartSection');
            chartSection.style.display = 'block';
            
            // 更新币种选择器
            const symbolSelect = document.getElementById('chartSymbolSelect');
            symbolSelect.value = symbol;
            
            // 获取图表数据并更新
            getChartData(symbol, currentChartTimeframe).then(data => {
                if (data) {
                    updateChart(data);
                }
            });
        }
        
        // 更新图表币种
        function updateChartSymbol() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const symbol = symbolSelect.value;
            
            if (symbol) {
                currentChartSymbol = symbol;
                getChartData(symbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // 更新图表时间周期
        function updateChartTimeframe() {
            const timeframeSelect = document.getElementById('chartTimeframeSelect');
            const timeframe = timeframeSelect.value;
            
            if (currentChartSymbol) {
                currentChartTimeframe = timeframe;
                getChartData(currentChartSymbol, timeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            }
        }
        
        // 刷新图表
        function refreshChart() {
            if (currentChartSymbol) {
                getChartData(currentChartSymbol, currentChartTimeframe).then(data => {
                    if (data) {
                        updateChart(data);
                    }
                });
            } else {
                showStatus('请先选择币种', 'error');
            }
        }
        
        // 切换图表显示/隐藏
        function toggleChartVisibility() {
            const chartSection = document.getElementById('chartSection');
            if (chartSection.style.display === 'none') {
                chartSection.style.display = 'block';
                if (currentChartSymbol) {
                    refreshChart();
                }
            } else {
                chartSection.style.display = 'none';
            }
        }
        
        // 初始化币种选择器
        function initChartSymbolSelect() {
            const symbolSelect = document.getElementById('chartSymbolSelect');
            const mainSymbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AVAX', 'MATIC', 'ATOM'];
            
            mainSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                symbolSelect.appendChild(option);
            });
        }
        
        // 更新交叉点位信息面板
        function updateCrossPointsInfo(crossPoints) {
            const panel = document.getElementById('crossPointsPanel');
            const priceList = document.getElementById('priceCrossList');
            const indicatorList = document.getElementById('indicatorCrossList');
            
            if (!crossPoints || (!crossPoints.price_crosses.length && !crossPoints.indicator_crosses.length)) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            // 更新价格交叉点列表
            priceList.innerHTML = '';
            if (crossPoints.price_crosses && crossPoints.price_crosses.length > 0) {
                crossPoints.price_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>价格 × ${cross.indicator}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    priceList.appendChild(item);
                });
            } else {
                priceList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">暂无价格交叉点</div>';
            }
            
            // 更新均线交叉点列表
            indicatorList.innerHTML = '';
            if (crossPoints.indicator_crosses && crossPoints.indicator_crosses.length > 0) {
                crossPoints.indicator_crosses.forEach(cross => {
                    const item = document.createElement('div');
                    item.className = `cross-point-item ${cross.type}`;
                    item.innerHTML = `
                        <div class="cross-point-info">
                            <div>${cross.indicator1} × ${cross.indicator2}</div>
                            <div class="cross-point-time">${cross.timestamp}</div>
                        </div>
                        <div class="cross-point-price">${cross.price}</div>
                    `;
                    indicatorList.appendChild(item);
                });
            } else {
                indicatorList.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">暂无均线交叉点</div>';
            }
        }
        
        // showCrossTab函数已移到HTML前面定义
        
        // 分析局部顶底排列
        function analyzeLocalTopBottom(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000 // 1分钟内
                );
                
                if (crossIndex < 10 || crossIndex >= chartData.prices.length - 10) {
                    return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
                }
                
                // 获取交叉点前后的价格数据
                const beforePrices = chartData.prices.slice(Math.max(0, crossIndex - 10), crossIndex);
                const afterPrices = chartData.prices.slice(crossIndex, Math.min(chartData.prices.length, crossIndex + 10));
                const currentPrice = chartData.prices[crossIndex];
                
                // 分析EMA排列
                const ema89 = chartData.ema89[crossIndex];
                const ema144 = chartData.ema144[crossIndex];
                const ema233 = chartData.ema233[crossIndex];
                const ema365 = chartData.ema365[crossIndex];
                
                // 判断EMA排列
                const isBullishArrangement = ema89 > ema144 && ema144 > ema233 && ema233 > ema365;
                const isBearishArrangement = ema89 < ema144 && ema144 < ema233 && ema233 < ema365;
                
                // 分析价格位置
                const beforeMax = Math.max(...beforePrices.filter(p => p !== null));
                const beforeMin = Math.min(...beforePrices.filter(p => p !== null));
                const afterMax = Math.max(...afterPrices.filter(p => p !== null));
                const afterMin = Math.min(...afterPrices.filter(p => p !== null));
                
                // 判断局部顶底
                let isLocalTop = false;
                let isLocalBottom = false;
                let confidence = 0;
                
                // 局部顶部判断：价格在交叉点附近达到局部高点，且EMA排列偏空
                if (currentPrice >= beforeMax * 0.98 && currentPrice >= afterMax * 0.98) {
                    if (isBearishArrangement || ema89 < ema233) {
                        isLocalTop = true;
                        confidence = 0.8;
                    }
                }
                
                // 局部底部判断：价格在交叉点附近达到局部低点，且EMA排列偏多
                if (currentPrice <= beforeMin * 1.02 && currentPrice <= afterMin * 1.02) {
                    if (isBullishArrangement || ema89 > ema233) {
                        isLocalBottom = true;
                        confidence = 0.8;
                    }
                }
                
                return { isLocalTop, isLocalBottom, confidence, emaArrangement: isBullishArrangement ? 'bullish' : 'bearish' };
                
            } catch (error) {
                console.error('分析局部顶底失败:', error);
                return { isLocalTop: false, isLocalBottom: false, confidence: 0 };
            }
        }
        
        // 处理重叠的价格标签
        function filterOverlappingPrices(crosses, chartData) {
            if (crosses.length === 0) return [];
            
            const filtered = [];
            const minDistance = 0.02; // 最小距离（2%）
            
            for (let i = 0; i < crosses.length; i++) {
                const current = crosses[i];
                let shouldAdd = true;
                
                // 分析局部顶底
                const topBottomAnalysis = analyzeLocalTopBottom(current, chartData);
                
                // 根据分析结果调整显示价格
                if (topBottomAnalysis.isLocalTop && topBottomAnalysis.confidence > 0.6) {
                    // 局部顶部：显示最高价格，适合做空
                    current.displayPrice = getLocalMaxPrice(current, chartData);
                    current.signalType = 'sell';
                    current.signalDescription = '局部顶部，适合做空';
                } else if (topBottomAnalysis.isLocalBottom && topBottomAnalysis.confidence > 0.6) {
                    // 局部底部：显示原价格，适合做多
                    current.displayPrice = current.price;
                    current.signalType = 'buy';
                    current.signalDescription = '局部底部，适合做多';
                } else {
                    // 中性：显示原价格
                    current.displayPrice = current.price;
                    current.signalType = 'neutral';
                    current.signalDescription = '中性信号';
                }
                
                // 检查是否与已添加的点太近
                for (let j = 0; j < filtered.length; j++) {
                    const existing = filtered[j];
                    const priceDiff = Math.abs(current.displayPrice - existing.displayPrice) / existing.displayPrice;
                    const timeDiff = Math.abs(new Date(current.timestamp) - new Date(existing.timestamp)) / (1000 * 60 * 60); // 小时
                    
                    // 如果价格和时间都很接近，则跳过
                    if (priceDiff < minDistance && timeDiff < 24) {
                        shouldAdd = false;
                        break;
                    }
                }
                
                if (shouldAdd) {
                    filtered.push(current);
                }
            }
            
            return filtered;
        }
        
        // 获取局部最高价格
        function getLocalMaxPrice(cross, chartData) {
            try {
                const crossTime = new Date(cross.timestamp);
                const crossIndex = chartData.timestamps.findIndex(ts => 
                    Math.abs(new Date(ts) - crossTime) < 60000
                );
                
                if (crossIndex < 5 || crossIndex >= chartData.prices.length - 5) {
                    return cross.price;
                }
                
                // 获取交叉点前后10个点的价格
                const startIndex = Math.max(0, crossIndex - 10);
                const endIndex = Math.min(chartData.prices.length, crossIndex + 10);
                const localPrices = chartData.prices.slice(startIndex, endIndex).filter(p => p !== null);
                
                return Math.max(...localPrices);
            } catch (error) {
                console.error('获取局部最高价格失败:', error);
                return cross.price;
            }
        }
        
        // 生成买卖信号
        function generateTradingSignals(crossPoints) {
            const signals = [];
            
            if (!crossPoints || !crossPoints.indicator_crosses) {
                return signals;
            }
            
            // 分析EMA排列和交叉点
            const emaCrosses = crossPoints.indicator_crosses.filter(cross => 
                cross.indicator1.includes('EMA') && cross.indicator2.includes('EMA')
            );
            
            // 按时间排序
            emaCrosses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // 分析每个交叉点
            emaCrosses.forEach(cross => {
                const { indicator1, indicator2, type, timestamp, price } = cross;
                
                // 买入信号条件
                if (isBuySignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'buy');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'buy',
                        description: getBuySignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
                
                // 卖出信号条件
                if (isSellSignal(indicator1, indicator2, type, crossPoints)) {
                    const volumeConfirmed = checkVolumeConfirmation(cross, 'sell');
                    signals.push({
                        timestamp: timestamp,
                        price: price,
                        type: 'sell',
                        description: getSellSignalDescription(indicator1, indicator2, type),
                        volume_confirmed: volumeConfirmed,
                        volume_info: cross.volume_confirmation || {}
                    });
                }
            });
            
            return signals;
        }
        
        // 判断是否为买入信号
        function isBuySignal(indicator1, indicator2, type, crossPoints) {
            // 条件1：EMA89突破EMA144/233/365，形成多头排列
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'golden_cross') {
                    return true; // EMA89上穿其他EMA
                }
            }
            
            // 条件2：市场回调至EMA233或EMA144，支撑反弹
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === '价格') {
                if (type === 'golden_cross') {
                    return true; // 价格从下方突破EMA支撑位
                }
            }
            
            return false;
        }
        
        // 检查成交量确认
        function checkVolumeConfirmation(cross, signalType) {
            if (cross.volume_confirmation) {
                const volConf = cross.volume_confirmation;
                if (signalType === 'buy') {
                    // 买入信号需要成交量增加确认
                    return volConf.confirmed && volConf.volume_ratio > 1.2;
                } else {
                    // 卖出信号成交量变化确认
                    return volConf.confirmed && (volConf.volume_ratio > 1.1 || volConf.volume_ratio < 0.8);
                }
            }
            return false; // 没有成交量数据时默认不确认
        }
        
        // 判断是否为卖出信号
        function isSellSignal(indicator1, indicator2, type, crossPoints) {
            // 条件1：EMA89跌破EMA144/233/365，形成空头排列
            if (indicator1 === 'EMA89' && (indicator2 === 'EMA144' || indicator2 === 'EMA233' || indicator2 === 'EMA365')) {
                if (type === 'death_cross') {
                    return true; // EMA89下穿其他EMA
                }
            }
            
            // 条件2：市场回调至EMA233或EMA144，未突破，形成下行压力
            if ((indicator1 === 'EMA144' || indicator1 === 'EMA233') && indicator2 === '价格') {
                if (type === 'death_cross') {
                    return true; // 价格从上方跌破EMA阻力位
                }
            }
            
            return false;
        }
        
        // 获取买入信号描述
        function getBuySignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89突破${indicator2}，多头排列形成`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `价格突破${indicator1}支撑位，反弹信号`;
            }
            return '买入信号';
        }
        
        // 获取卖出信号描述
        function getSellSignalDescription(indicator1, indicator2, type) {
            if (indicator1 === 'EMA89') {
                return `EMA89跌破${indicator2}，空头排列形成`;
            } else if (indicator1 === 'EMA144' || indicator1 === 'EMA233') {
                return `价格跌破${indicator1}阻力位，下行压力`;
            }
            return '卖出信号';
        }

        // 多时间框架策略相关变量
        let allMultiTimeframeSignals = [];
        
        // 全局错误处理
        window.addEventListener('unhandledrejection', function(event) {
            console.error('未处理的Promise错误:', event.reason);
            showStatus(`系统错误: ${event.reason.message || event.reason}`, 'error');
            event.preventDefault(); // 阻止默认的错误处理
        });
        
        window.addEventListener('error', function(event) {
            console.error('JavaScript错误:', event.error);
            if (event.error && event.error.message) {
                showStatus(`JavaScript错误: ${event.error.message}`, 'error');
            }
        });

        // analyzeMultiTimeframeSymbols函数已移到HTML前面定义

        // 分析多个币种的多时间框架策略
        async function analyzeMultipleMultiTimeframeSymbols(symbols, strategyType = 'original') {
            try {
                showStatus(`开始分析 ${symbols.length} 个币种的多时间框架策略 (策略: ${strategyType === 'original' ? '原策略' : '修改策略'})...`, 'info');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2分钟超时
                
                const response = await fetch('/multi_timeframe/analyze_multiple_symbols', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        symbols: symbols,
                        strategy_type: strategyType
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP错误: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // 使用新的信号格式
                    const allSignals = data.signals || [];
                    
                    console.log('多时间框架分析结果:', data);
                    console.log('信号数据:', allSignals);
                    console.log('信号数量:', allSignals.length);
                    
                    allMultiTimeframeSignals = allSignals;
                    showMultiTimeframeSignals(allSignals, 0); // 默认显示所有信号
                    showStatus(`分析完成: 总计${data.total_signals}个信号，成功${data.successful_signals}个`, 'success');
                } else {
                    showStatus(`分析失败: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`分析失败: ${error.message}`, 'error');
            }
        }

        // 分析自定义币种的多时间框架策略
        async function analyzeCustomMultiTimeframeSymbols() {
            const symbolInput = document.getElementById('multiTimeframeSymbolInput').value.trim();
            if (!symbolInput) {
                showStatus('请输入要分析的币种', 'warning');
                return;
            }
            
            const symbols = symbolInput.split(',').map(s => s.trim().toUpperCase());
            
            try {
                const strategyType = document.getElementById('strategyTypeSelect').value;
                showStatus(`开始分析自定义币种: ${symbols.join(', ')} (策略: ${strategyType === 'original' ? '原策略' : '修改策略'})`, 'info');
                await analyzeMultipleMultiTimeframeSymbols(symbols, strategyType);
            } catch (error) {
                showStatus(`分析失败: ${error.message}`, 'error');
            }
        }

        // getMultiTimeframeTopSymbols函数已移到HTML前面定义

        // 清除EMA使用记录
        async function clearMultiTimeframeCache() {
            try {
                const response = await fetch('/multi_timeframe/clear_ema_usage', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    showStatus('EMA使用记录已清除', 'success');
                } else {
                    showStatus(`清除失败: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`清除失败: ${error.message}`, 'error');
            }
        }

        // 验证币种
        async function validateMultiTimeframeSymbol() {
            const symbolInput = document.getElementById('multiTimeframeSymbolInput').value.trim();
            if (!symbolInput) {
                showStatus('请输入要验证的币种', 'warning');
                return;
            }
            
            const symbol = symbolInput.split(',')[0].trim().toUpperCase(); // 只验证第一个币种
            
            try {
                showStatus(`正在验证币种: ${symbol}...`, 'info');
                
                const response = await fetch('/multi_timeframe/validate_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (data.is_valid) {
                        showStatus(`✅ ${data.symbol} 验证通过，可以正常交易`, 'success');
                    } else {
                        showStatus(`❌ ${data.symbol} 验证失败，该币种不存在或无法获取数据`, 'error');
                    }
                } else {
                    showStatus(`验证失败: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`验证失败: ${error.message}`, 'error');
            }
        }

        // 【已重构】统一的多时间框架信号显示
        function showMultiTimeframeSignals(signals, minProfit = 0) {
            console.log('showMultiTimeframeSignals 被调用 - 使用统一分页系统');
            console.log('传入的信号数据:', signals);
            console.log('信号数量:', signals ? signals.length : 0);
            
            // 如果有信号数据，更新缓存（这通常在首次加载时发生）
            if (signals && signals.length > 0) {
                // 过滤信号
                let filteredSignals = signals;
                if (minProfit > 0) {
                    filteredSignals = signals.filter(signal => signal.profit_pct >= minProfit);
                }
                
                console.log('过滤后的信号数量:', filteredSignals.length);
                
                // 更新缓存
                allCachedSignals = filteredSignals;
                
                // 重新计算总页数  
                const signalsPerPage = 50;
                totalPages = Math.ceil(allCachedSignals.length / signalsPerPage);
                currentPage = 1; // 重置到第一页
                
                // 更新分页控件并显示第一页
                updatePaginationControls();
                displayCurrentPageSignals(signalsPerPage);
            } else {
                // 没有信号，显示空状态
                updateSignalDisplay([]);
            }
        }
        
        // 【已废弃】旧的信号页面显示函数，保留以避免调用错误
        function displaySignalPage(filteredSignals, page, totalPages) {
            const tbody = document.getElementById('multiTimeframeSignalsTableBody');
            if (!tbody) return;
            
            if (filteredSignals.length === 0) {
                const filterText = document.getElementById('multiTimeframeProfitFilter')?.value === '0' ? '暂无多时间框架交易信号' : `暂无收益率${document.getElementById('multiTimeframeProfitFilter')?.value}%及以上的多时间框架交易信号`;
                tbody.innerHTML = `<tr><td colspan="10" style="text-align: center; color: #666;">${filterText}</td></tr>`;
                return;
            }
            
            // 计算当前页的信号范围
            const startIndex = (page - 1) * signalsPerPage;
            const endIndex = startIndex + signalsPerPage;
            const pageSignals = filteredSignals.slice(startIndex, endIndex);
            
            console.log(`显示第${page}页信号: ${startIndex}-${endIndex}, 共${pageSignals.length}个信号`);
            
            let html = '';
            pageSignals.forEach(signal => {
                let signalTypeClass = 'warning';
                let signalTypeText = signal.signal_type;
                
                if (signal.signal_type === 'long') {
                    signalTypeClass = 'success';
                    signalTypeText = '做多';
                } else if (signal.signal_type === 'short') {
                    signalTypeClass = 'danger';
                    signalTypeText = '做空';
                }
                
                let profitClass = 'text-success';
                if (signal.profit_pct < 0.5) {
                    profitClass = 'text-warning';
                } else if (signal.profit_pct < 0.2) {
                    profitClass = 'text-danger';
                }
                
                html += `
                    <tr>
                        <td><strong>${signal.symbol}</strong></td>
                        <td><span class="badge badge-info">${signal.timeframe}</span></td>
                        <td>${signal.trend}</td>
                        <td><span class="badge badge-secondary">${signal.ema_period ? 'EMA' + signal.ema_period : signal.signal_data?.type || 'N/A'}</span></td>
                        <td><strong>${signal.entry_price}</strong></td>
                        <td><strong>${signal.take_profit || 'N/A'}</strong></td>
                        <td class="${profitClass}"><strong>${signal.profit_pct}%</strong></td>
                        <td><span class="status-${signalTypeClass}">${signalTypeText}</span></td>
                        <td><small>${signal.signal_time || 'N/A'}</small></td>
                        <td>
                            <button class="btn btn-sm btn-info" onclick="showSignalDetails('${signal.symbol}', '${signal.timeframe}', '${signal.condition || 'N/A'}', '${signal.description || 'N/A'}')">详情</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // 更新状态显示
            const totalCount = filteredSignals.length;
            const filterText = document.getElementById('multiTimeframeProfitFilter')?.value === '0' ? '显示全部' : `收益率≥${document.getElementById('multiTimeframeProfitFilter')?.value}%`;
            showStatus(`多时间框架信号: 第${page}页，共${totalPages}页 (${pageSignals.length}个信号) - ${filterText}`, 'success');
        }

        // 分页相关变量
        let currentPage = 1;
        let currentPageSize = 20;  // 改为20个信号每页
        let totalPages = 1;
        let allSymbols = [];
        let currentSymbols = [];
        let allSignals = [];  // 存储所有信号
        let currentSignalPage = 1;  // 当前信号页
        let signalsPerPage = 20;  // 每页信号数量
        
        // 更新信号分页控制
        function updateSignalPagination(totalPages) {
            const paginationControls = document.getElementById('paginationControls');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (paginationControls) {
                paginationControls.style.display = 'block';
            }
            
            if (pageInfo) {
                pageInfo.textContent = `第${currentSignalPage}页，共${totalPages}页 (信号分页)`;
            }
            
            if (prevBtn) {
                prevBtn.disabled = currentSignalPage <= 1;
            }
            
            if (nextBtn) {
                nextBtn.disabled = currentSignalPage >= totalPages;
            }
        }
        
        // 信号翻页函数
        function previousSignalPage() {
            if (currentSignalPage > 1) {
                currentSignalPage--;
                // 重新显示当前页的信号
                const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter')?.value || 0);
                let filteredSignals = allSignals;
                if (minProfit > 0) {
                    filteredSignals = allSignals.filter(signal => signal.profit_pct >= minProfit);
                }
                const totalSignalPages = Math.ceil(filteredSignals.length / signalsPerPage);
                displaySignalPage(filteredSignals, currentSignalPage, totalSignalPages);
                updateSignalPagination(totalSignalPages);
            }
        }
        
        function nextSignalPage() {
            const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter')?.value || 0);
            let filteredSignals = allSignals;
            if (minProfit > 0) {
                filteredSignals = allSignals.filter(signal => signal.profit_pct >= minProfit);
            }
            const totalSignalPages = Math.ceil(filteredSignals.length / signalsPerPage);
            
            if (currentSignalPage < totalSignalPages) {
                currentSignalPage++;
                displaySignalPage(filteredSignals, currentSignalPage, totalSignalPages);
                updateSignalPagination(totalSignalPages);
            }
        }

        // 应用多时间框架过滤
        function applyMultiTimeframeFilter() {
            const minProfit = parseFloat(document.getElementById('multiTimeframeProfitFilter').value);
            showMultiTimeframeSignals(allMultiTimeframeSignals, minProfit);
        }

        // 更改页面大小
        function changePageSize() {
            // 【已修复】现在不需要改变页面大小，因为我们按信号分页
            // 如果需要重新分析，可以清除缓存
            showStatus('每页信号数量现在固定为50个', 'info');
        }

        // 上一页信号
        function previousSignalPage() {
            console.log(`previousSignalPage 被调用: currentPage=${currentPage}, totalPages=${totalPages}`);
            
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('没有可显示的信号数据', 'warning');
                return;
            }
            
            if (currentPage > 1) {
                currentPage--;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`切换到第${currentPage}页`, 'success');
            } else {
                showStatus('已经是第一页了', 'info');
            }
        }

        // 下一页信号
        function nextSignalPage() {
            console.log(`nextSignalPage 被调用: currentPage=${currentPage}, totalPages=${totalPages}, allCachedSignals.length=${allCachedSignals.length}`);
            
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('没有可显示的信号数据', 'warning');
                return;
            }
            
            if (currentPage < totalPages) {
                currentPage++;
                displayCurrentPageSignals(50);
                updatePaginationControls();
                showStatus(`切换到第${currentPage}页`, 'success');
            } else {
                showStatus('已经是最后一页了', 'info');
            }
        }

        // 导出全部信号到CSV
        function exportAllSignalsToCSV() {
            if (!allCachedSignals || allCachedSignals.length === 0) {
                showStatus('没有可导出的数据', 'warning');
                return;
            }
            
            try {
                showStatus('正在生成CSV文件...', 'info');
                
                // CSV表头
                const headers = ['币种', '时间框架', '信号描述', '入场价格', '止盈价格', '潜在收益率', '信号数量', '分析时间'];
                
                // 构建CSV内容
                let csvContent = headers.join(',') + '\n';
                
                allCachedSignals.forEach(signal => {
                    const row = [
                        signal.symbol || '',
                        signal.timeframe || '',
                        `"${(signal.description || '').replace(/"/g, '""')}"`, // 转义引号
                        signal.entry_price || '',
                        signal.take_profit_price || '',
                        signal.potential_profit ? `${(signal.potential_profit * 100).toFixed(2)}%` : '',
                        signal.signal_count || 0,
                        signal.timestamp || new Date().toLocaleString('zh-CN')
                    ];
                    csvContent += row.join(',') + '\n';
                });
                
                // 创建Blob并下载
                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `multi_timeframe_signals_${timestamp}.csv`;
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`成功导出 ${allCachedSignals.length} 条信号数据到 ${filename}`, 'success');
                
            } catch (error) {
                console.error('导出CSV失败:', error);
                showStatus(`导出失败: ${error.message}`, 'error');
            }
        }

        // 导出币种分析结果到CSV
        function exportAnalysisResultsToCSV() {
            const dataToExport = filteredResults.length > 0 ? filteredResults : currentResults;
            
            if (!dataToExport || dataToExport.length === 0) {
                showStatus('没有可导出的分析数据，请先运行分析', 'warning');
                return;
            }
            
            try {
                showStatus('正在生成CSV文件...', 'info');
                
                // CSV表头
                const headers = ['币种', '当前价格', '挂单价格', '时间级别', 'EMA89', 'EMA144', 'EMA233', 'EMA365', '布林上轨', '布林中轨', '布林下轨', '最后更新时间'];
                
                // 构建CSV内容
                let csvContent = headers.join(',') + '\n';
                
                dataToExport.forEach(result => {
                    const row = [
                        result.symbol || '',
                        result.current_price || '',
                        result.order_price || '',
                        result.timeframe || '',
                        result.ema89 || '',
                        result.ema144 || '',
                        result.ema233 || '',
                        result.ema365 || '',
                        result.bb_upper || '',
                        result.bb_middle || '',
                        result.bb_lower || '',
                        result.last_updated || new Date().toLocaleString('zh-CN')
                    ];
                    csvContent += row.join(',') + '\n';
                });
                
                // 创建Blob并下载
                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `analysis_results_${timestamp}.csv`;
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`成功导出 ${dataToExport.length} 条分析结果到 ${filename}`, 'success');
                
            } catch (error) {
                console.error('导出CSV失败:', error);
                showStatus(`导出失败: ${error.message}`, 'error');
            }
        }

        // analyzeCurrentPage函数已移到HTML前面定义

        // updatePaginationControls函数已移到HTML前面定义

        // 显示多时间框架详情
        async function showMultiTimeframeDetails(symbol, timeframe) {
            try {
                const response = await fetch('/multi_timeframe/analyze_symbol', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const result = data.results.find(r => r.timeframe === timeframe);
                    if (result) {
                        showMultiTimeframeDetailsModal(result);
                    } else {
                        showStatus(`未找到${symbol} ${timeframe}的详情`, 'warning');
                    }
                } else {
                    showStatus(`获取详情失败: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`获取详情失败: ${error.message}`, 'error');
            }
        }

        // 显示多时间框架详情模态框
        function showMultiTimeframeDetailsModal(signal) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h3>多时间框架策略详情 - ${signal.symbol}</h3>
                    <div class="signal-details">
                        <div class="details-grid">
                            <div class="detail-item">
                                <label>时间框架:</label>
                                <span>${signal.timeframe}</span>
                            </div>
                            <div class="detail-item">
                                <label>趋势方向:</label>
                                <span>${signal.trend}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMA级别:</label>
                                <span>EMA${signal.ema_period}</span>
                            </div>
                            <div class="detail-item">
                                <label>信号类型:</label>
                                <span>${signal.signal_type === 'long' ? '做多' : '做空'}</span>
                            </div>
                            <div class="detail-item">
                                <label>入场价格:</label>
                                <span>${signal.entry_price}</span>
                            </div>
                            <div class="detail-item">
                                <label>止盈价格:</label>
                                <span>${signal.take_profit}</span>
                            </div>
                            <div class="detail-item">
                                <label>预期收益率:</label>
                                <span>${signal.profit_pct}%</span>
                            </div>
                            <div class="detail-item">
                                <label>当前价格:</label>
                                <span>${signal.current_price}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMA144:</label>
                                <span>${signal.ema144}</span>
                            </div>
                            <div class="detail-item">
                                <label>EMA233:</label>
                                <span>${signal.ema233}</span>
                            </div>
                            <div class="detail-item">
                                <label>信号时间:</label>
                                <span>${signal.signal_time}</span>
                            </div>
                        </div>
                        
                        <div class="strategy-explanation">
                            <h6>策略说明</h6>
                            <p><strong>趋势判断:</strong> ${signal.trend}</p>
                            <p><strong>入场条件:</strong> 价格回踩EMA${signal.ema_period}</p>
                            <p><strong>止盈设置:</strong> 使用${signal.timeframe}对应时间框架的布林中轨</p>
                            <p><strong>风险控制:</strong> 每个EMA级别只用一次，避免重复信号</p>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // ==================== 热点币种分析功能 ====================
        
        // 初始化默认日期
        (function initDefaultDates() {
            // 设置结束日期为今天
            const today = new Date().toISOString().split('T')[0];
            const endDateInput = document.getElementById('advEndDate');
            if (endDateInput) {
                endDateInput.value = today;
            }
        })();
        
        let hotCoinsData = null;
        
        // 分析热点币种
        async function analyzeHotCoins() {
            try {
                showStatus('正在分析350个币种，请耐心等待...', 'info');
                
                // 显示进度条
                document.getElementById('hotCoinsProgress').style.display = 'block';
                document.getElementById('hotCoinsProgressText').textContent = '分析中...';
                document.getElementById('hotCoinsProgressBar').style.width = '50%';
                
                // 隐藏之前的结果
                document.getElementById('hotCoinsSummary').style.display = 'none';
                document.getElementById('hotCoinsTabsContainer').style.display = 'none';
                
                const response = await safeFetch('/crypto_analysis/analyze');
                const result = await response.json();
                
                if (result.success) {
                    hotCoinsData = result.data;
                    
                    // 更新进度条
                    document.getElementById('hotCoinsProgressBar').style.width = '100%';
                    document.getElementById('hotCoinsProgressText').textContent = '分析完成！';
                    
                    // 显示结果
                    displayHotCoinsResults(hotCoinsData);
                    
                    showStatus(`✅ 分析完成！成功分析 ${hotCoinsData.summary.successful_coins}/${hotCoinsData.summary.total_coins} 个币种`, 'success');
                    
                    // 隐藏进度条
                    setTimeout(() => {
                        document.getElementById('hotCoinsProgress').style.display = 'none';
                    }, 2000);
                } else {
                    showStatus(`分析失败: ${result.error}`, 'error');
                    document.getElementById('hotCoinsProgress').style.display = 'none';
                }
            } catch (error) {
                console.error('分析失败:', error);
                showStatus(`分析失败: ${error.message}`, 'error');
                document.getElementById('hotCoinsProgress').style.display = 'none';
            }
        }
        
        // 显示币种列表
        async function showHotCoinsSymbols() {
            try {
                const response = await safeFetch('/crypto_analysis/get_symbols');
                const result = await response.json();
                
                if (result.success) {
                    let html = '<div style="background: #2b2b2b; padding: 20px; border-radius: 8px; border: 1px solid #444;">';
                    html += `<h4 style="color: #e0e0e0;">📋 分析币种列表（共 ${result.count} 个）</h4>`;
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px;">';
                    
                    result.symbols.forEach(symbol => {
                        html += `<div style="background: #1a1a1a; padding: 8px; border-radius: 4px; text-align: center; border: 1px solid #555; color: #e0e0e0;">${symbol}</div>`;
                    });
                    
                    html += '</div></div>';
                    
                    document.getElementById('hotCoinsResults').innerHTML = html;
                    showStatus(`✅ 已加载 ${result.count} 个币种`, 'success');
                } else {
                    showStatus(`获取币种列表失败: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('获取币种列表失败:', error);
                showStatus(`获取币种列表失败: ${error.message}`, 'error');
            }
        }
        
        // 显示分析结果
        function displayHotCoinsResults(data) {
            // 显示概览
            document.getElementById('hotCoinsSummary').style.display = 'block';
            document.getElementById('totalCoins').textContent = data.summary.total_coins;
            document.getElementById('successCoins').textContent = data.summary.successful_coins;
            document.getElementById('positiveCoins').textContent = data.summary.positive_coins;
            
            if (data.statistics) {
                document.getElementById('avgChange').textContent = data.statistics.avg_change.toFixed(2) + '%';
                document.getElementById('maxGain').textContent = '+' + data.statistics.max_gain.toFixed(2) + '%';
                document.getElementById('maxLoss').textContent = data.statistics.max_loss.toFixed(2) + '%';
            }
            
            // 显示Tab容器
            document.getElementById('hotCoinsTabsContainer').style.display = 'block';
            
            // 渲染各个Tab内容
            renderGainersTab(data.top_gainers);
            renderLosersTab(data.top_losers);
            renderVolumeTab(data.top_volume);
            renderDistributionTab(data.distribution);
            renderAllCoinsTab(data.all_coins);
        }
        
        // 渲染涨幅榜
        function renderGainersTab(gainers) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">排名</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">币种</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h涨跌</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">当前价格</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最高</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最低</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">交易量</th>';
            html += '</tr></thead><tbody>';
            
            gainers.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('gainersContent').innerHTML = html;
        }
        
        // 渲染跌幅榜
        function renderLosersTab(losers) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">排名</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">币种</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h涨跌</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">当前价格</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最高</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最低</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">交易量</th>';
            html += '</tr></thead><tbody>';
            
            losers.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('losersContent').innerHTML = html;
        }
        
        // 渲染交易量榜
        function renderVolumeTab(volumes) {
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">排名</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">币种</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">交易量</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h涨跌</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">当前价格</th>';
            html += '</tr></thead><tbody>';
            
            volumes.forEach((coin, index) => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                html += `<tr style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: #999;">${index + 1}</td>
                    <td style="padding: 10px; color: #e0e0e0;"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: #e0e0e0;">${coin.volume.toFixed(2)}</td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: #e0e0e0;">$${coin.price.toFixed(6)}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('volumeContent').innerHTML = html;
        }
        
        // 渲染涨跌分布
        function renderDistributionTab(distribution) {
            let html = '<div style="background: #2b2b2b; padding: 20px; border-radius: 8px; border: 1px solid #444;">';
            
            const categories = [
                { label: '涨幅 ≥10%', value: distribution.up_10_plus, color: '#28a745' },
                { label: '涨幅 5%-10%', value: distribution.up_5_10, color: '#20c997' },
                { label: '涨幅 0%-5%', value: distribution.up_0_5, color: '#17a2b8' },
                { label: '跌幅 0%-5%', value: distribution.down_0_5, color: '#ffc107' },
                { label: '跌幅 5%-10%', value: distribution.down_5_10, color: '#fd7e14' },
                { label: '跌幅 ≥10%', value: distribution.down_10_plus, color: '#dc3545' }
            ];
            
            const total = categories.reduce((sum, cat) => sum + cat.value, 0);
            
            categories.forEach(cat => {
                const percentage = total > 0 ? (cat.value / total * 100).toFixed(1) : 0;
                html += `
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #e0e0e0;"><strong>${cat.label}</strong></span>
                            <span style="color: #bbb;">${cat.value} 个 (${percentage}%)</span>
                        </div>
                        <div style="background: #1a1a1a; height: 30px; border-radius: 5px; overflow: hidden; border: 1px solid #444;">
                            <div style="background: ${cat.color}; height: 100%; width: ${percentage}%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                ${percentage}%
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('distributionContent').innerHTML = html;
        }
        
        // 渲染所有币种列表
        function renderAllCoinsTab(coins) {
            // 添加搜索功能
            const searchInput = document.getElementById('coinSearchInput');
            searchInput.onkeyup = function() {
                filterCoins(this.value.toUpperCase());
            };
            
            let html = '<div style="background: #2b2b2b; padding: 15px; border-radius: 8px; border: 1px solid #444;"><table style="width: 100%; border-collapse: collapse;"><thead><tr style="background: #1a1a1a;">';
            html += '<th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">币种</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h涨跌</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">当前价格</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最高</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">24h最低</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">交易量</th><th style="padding: 12px; text-align: left; color: #e0e0e0; border-bottom: 2px solid #555;">数据源</th>';
            html += '</tr></thead><tbody>';
            
            coins.forEach(coin => {
                const changeColor = coin.change_24h >= 0 ? '#28a745' : '#dc3545';
                const textColor = coin.source === 'Failed' ? '#666' : '#e0e0e0';
                html += `<tr class="coin-row" data-symbol="${coin.symbol}" style="border-bottom: 1px solid #444;">
                    <td style="padding: 10px; color: ${textColor};"><strong>${coin.symbol}</strong></td>
                    <td style="padding: 10px; color: ${changeColor}; font-weight: bold;">${coin.change_24h >= 0 ? '+' : ''}${coin.change_24h.toFixed(2)}%</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.price.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.high_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">$${coin.low_24h.toFixed(6)}</td>
                    <td style="padding: 10px; color: ${textColor};">${coin.volume.toFixed(2)}</td>
                    <td style="padding: 10px; color: ${textColor};">${coin.source}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('allCoinsContent').innerHTML = html;
        }
        
        // 过滤币种
        function filterCoins(searchTerm) {
            const rows = document.querySelectorAll('.coin-row');
            rows.forEach(row => {
                const symbol = row.getAttribute('data-symbol');
                if (symbol.indexOf(searchTerm) > -1) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // 切换子Tab
        function showHotCoinsSubTab(tabName, event) {
            // 更新按钮状态
            document.querySelectorAll('#hotCoinsTabsContainer .cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // 更新内容显示
            document.querySelectorAll('#hotCoinsTabsContainer .cross-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const tabMap = {
                'gainers': 'gainersTab',
                'losers': 'losersTab',
                'volume': 'volumeTab',
                'distribution': 'distributionTab',
                'all': 'allTab'
            };
            
            const targetTab = document.getElementById(tabMap[tabName]);
            if (targetTab) {
                targetTab.classList.add('active');
            }
        }
        
        // ==================== 热点币种分析功能结束 ====================
        
        // ==================== 高级历史分析功能 ====================
        
        let historicalAnalysisData = null;
        
        // 切换分析模式
        function switchHotCoinsMode(mode, event) {
            // 更新按钮状态
            event.target.parentElement.querySelectorAll('.cross-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 切换显示
            if (mode === 'realtime') {
                document.getElementById('realtimeMode').style.display = 'block';
                document.getElementById('historicalMode').style.display = 'none';
            } else {
                document.getElementById('realtimeMode').style.display = 'none';
                document.getElementById('historicalMode').style.display = 'block';
            }
            
            // 清空结果
            document.getElementById('hotCoinsResults').innerHTML = '';
            document.getElementById('hotCoinsSummary').style.display = 'none';
            document.getElementById('hotCoinsTabsContainer').style.display = 'none';
        }
        
        // 历史时段分析
        async function analyzeHistoricalPeriod() {
            try {
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                const minGainRatio = parseFloat(document.getElementById('minGainRatio').value);
                const includeProjectInfo = document.getElementById('includeProjectInfo').checked;
                const includeMoneyFlow = document.getElementById('includeMoneyFlow').checked;
                
                if (!startDate) {
                    showStatus('请选择开始日期', 'error');
                    return;
                }
                
                showStatus(`正在分析 ${startDate} ${endDate ? '到 ' + endDate : '至今'} 的数据，筛选涨幅≥${minGainRatio}倍的币种...`, 'info');
                
                // 显示进度条
                document.getElementById('hotCoinsProgress').style.display = 'block';
                document.getElementById('hotCoinsProgressText').textContent = '分析中...这可能需要几分钟';
                document.getElementById('hotCoinsProgressBar').style.width = '30%';
                
                const requestData = {
                    start_date: startDate,
                    end_date: endDate || null,
                    min_gain_ratio: minGainRatio,
                    include_project_info: includeProjectInfo,
                    include_money_flow: includeMoneyFlow
                };
                
                const response = await safeFetch('/crypto_advanced/analyze_period', {
                    method: 'POST',
                    body: JSON.stringify(requestData)
                });
                
                document.getElementById('hotCoinsProgressBar').style.width = '100%';
                
                const result = await response.json();
                
                if (result.success) {
                    historicalAnalysisData = result.data;
                    displayHistoricalResults(historicalAnalysisData);
                    showStatus(`✅ 分析完成！找到 ${historicalAnalysisData.qualified_count} 个符合条件的币种`, 'success');
                } else {
                    showStatus(`分析失败: ${result.error}`, 'error');
                }
                
                setTimeout(() => {
                    document.getElementById('hotCoinsProgress').style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('历史分析失败:', error);
                showStatus(`分析失败: ${error.message}`, 'error');
                document.getElementById('hotCoinsProgress').style.display = 'none';
            }
        }
        
        // 显示历史分析结果
        function displayHistoricalResults(data) {
            if (!data.results || data.results.length === 0) {
                document.getElementById('hotCoinsResults').innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                        <h3 style="color: #e0e0e0;">😢 未找到符合条件的币种</h3>
                        <p style="color: #bbb;">在指定时间段内，没有币种的最高点达到 ${data.min_gain_ratio}倍涨幅</p>
                        <p style="color: #999;">建议：降低涨幅倍数或扩大时间范围</p>
                    </div>
                `;
                return;
            }
            
            let html = '<div style="margin-top: 20px;">';
            
            // 概览卡片
            html += `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.total_analyzed}</div>
                        <div style="font-size: 12px; color: #999;">分析币种数</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #28a745; margin-bottom: 5px;">${data.qualified_count}</div>
                        <div style="font-size: 12px; color: #999;">符合条件</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.start_date}</div>
                        <div style="font-size: 12px; color: #999;">开始日期</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.end_date}</div>
                        <div style="font-size: 12px; color: #999;">结束日期</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #fff; margin-bottom: 5px;">${data.min_gain_ratio}x</div>
                        <div style="font-size: 12px; color: #999;">最小涨幅</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #dc3545; margin-bottom: 5px;">${data.results[0].gain_ratio.toFixed(2)}x</div>
                        <div style="font-size: 12px; color: #999;">最高涨幅</div>
                    </div>
                    <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #444;">
                        <div style="font-size: 28px; font-weight: bold; color: #ffc107; margin-bottom: 5px;">${data.failed_count || 0}</div>
                        <div style="font-size: 12px; color: #999;">分析失败</div>
                    </div>
                </div>
            `;
            
            // 添加查看失败记录按钮
            if (data.failed_count > 0) {
                html += `
                    <div style="text-align: center; margin: 20px 0;">
                        <button class="btn btn-warning" onclick="showFailedRecords()">
                            ⚠️ 查看失败记录 (${data.failed_count}个币种)
                        </button>
                    </div>
                `;
            }
            
            // 币种列表
            html += '<h3 style="margin-top: 30px; color: #e0e0e0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">🏆 超级牛币榜单</h3>';
            
            data.results.forEach((coin, index) => {
                html += `
                    <div style="background: #1a1a1a; border: 2px solid #28a745; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div>
                                <span style="font-size: 24px; font-weight: bold; color: #e0e0e0;">
                                    ${index + 1}. ${coin.symbol}
                                </span>
                                <span style="font-size: 32px; font-weight: bold; color: #28a745; margin-left: 20px;">
                                    ${coin.gain_ratio.toFixed(2)}x 🚀
                                </span>
                                <span style="color: #999; margin-left: 10px;">(最高点+${coin.gain_percent.toFixed(2)}%)</span>
                            </div>
                            <div>
                                <button class="btn btn-info" onclick="showCoinDetail('${coin.symbol}', ${index})">📊 查看详情</button>
                                <button class="btn btn-success" onclick="showCoinChart('${coin.symbol}')">📈 查看图表</button>
                            </div>
                        </div>
                        
                        <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #444;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div>
                                    <strong style="color: #bbb;">📅 时间跨度:</strong><br>
                                    <span style="color: #e0e0e0;">${coin.start_date} 至 ${coin.end_date}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">💰 起始价格:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.start_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">📈 最高价:</strong><br>
                                    <span style="color: #28a745; font-size: 18px; font-weight: bold;">$${coin.max_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">📉 最低价:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.min_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">💵 当前价格:</strong><br>
                                    <span style="color: #e0e0e0;">$${coin.end_price.toFixed(6)}</span>
                                </div>
                                <div>
                                    <strong style="color: #bbb;">📊 当前涨幅:</strong><br>
                                    <span style="color: ${coin.current_gain_percent >= 0 ? '#28a745' : '#dc3545'}; font-weight: bold;">
                                        ${coin.current_gain_ratio ? coin.current_gain_ratio.toFixed(2) : 'N/A'}x (${coin.current_gain_percent >= 0 ? '+' : ''}${coin.current_gain_percent ? coin.current_gain_percent.toFixed(2) : 'N/A'}%)
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        ${coin.project_info ? `
                            <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #444;">
                                <h4 style="margin: 0 0 10px 0; color: #17a2b8;">📋 项目信息</h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                    <div><strong style="color: #bbb;">项目名称:</strong> <span style="color: #e0e0e0;">${coin.project_info.name}</span></div>
                                    <div><strong style="color: #bbb;">市值排名:</strong> <span style="color: #e0e0e0;">#${coin.project_info.market_cap_rank}</span></div>
                                    <div><strong style="color: #bbb;">技术赛道:</strong> <span style="color: #28a745;">${coin.project_info.categories.join(', ') || '未知'}</span></div>
                                    <div><strong style="color: #bbb;">市值:</strong> <span style="color: #e0e0e0;">$${(coin.project_info.market_cap / 1e6).toFixed(2)}M</span></div>
                                </div>
                                <div style="margin-top: 10px;">
                                    <strong style="color: #bbb;">项目简介:</strong> <span style="color: #ccc;">${coin.project_info.description || '暂无描述'}</span>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                                    <div><strong style="color: #bbb;">Twitter粉丝:</strong> <span style="color: #e0e0e0;">${coin.project_info.twitter_followers.toLocaleString()}</span></div>
                                    <div><strong style="color: #bbb;">GitHub星标:</strong> <span style="color: #e0e0e0;">${coin.project_info.github_stars}</span></div>
                                    <div><strong style="color: #bbb;">4周代码提交:</strong> <span style="color: #e0e0e0;">${coin.project_info.github_commits_4w}</span></div>
                                </div>
                                <div style="margin-top: 10px;">
                                    ${coin.project_info.homepage ? `<a href="${coin.project_info.homepage}" target="_blank" style="margin-right: 15px; color: #17a2b8; text-decoration: none;">🌐 官网</a>` : ''}
                                    ${coin.project_info.github ? `<a href="${coin.project_info.github}" target="_blank" style="margin-right: 15px; color: #17a2b8; text-decoration: none;">💻 GitHub</a>` : ''}
                                    ${coin.project_info.twitter ? `<a href="https://twitter.com/${coin.project_info.twitter}" target="_blank" style="color: #17a2b8; text-decoration: none;">🐦 Twitter</a>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${coin.money_flow ? `
                            <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #444;">
                                <h4 style="margin: 0 0 10px 0; color: #ffc107;">💰 资金流向分析</h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                    <div><strong style="color: #bbb;">最新资金流:</strong> <span style="color: ${coin.money_flow.latest_flow > 0 ? '#28a745' : '#dc3545'};">${coin.money_flow.latest_flow > 0 ? '✅ 流入' : '⚠️ 流出'} ${Math.abs(coin.money_flow.latest_flow).toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">累计资金流:</strong> <span style="color: #e0e0e0;">${coin.money_flow.cumulative_flow.toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">日均成交量:</strong> <span style="color: #e0e0e0;">${coin.money_flow.avg_daily_volume.toFixed(2)}</span></div>
                                    <div><strong style="color: #bbb;">OBV指标:</strong> <span style="color: #e0e0e0;">${coin.money_flow.obv.toFixed(2)}</span></div>
                                </div>
                                <button class="btn btn-info" onclick="showMoneyFlowChart('${coin.symbol}')" style="margin-top: 10px;">
                                    📊 查看资金流向图表
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('hotCoinsResults').innerHTML = html;
        }
        
        // 显示币种详情（弹窗）
        function showCoinDetail(symbol, index) {
            const coin = historicalAnalysisData.results[index];
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: #1a1a1a; padding: 30px; border-radius: 15px; max-width: 800px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;" onclick="event.stopPropagation()">
                        <h2 style="color: #e0e0e0;">${coin.symbol} - 详细报告</h2>
                        <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; right: 20px; top: 20px; background: #dc3545; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">关闭</button>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                            <h3 style="color: #28a745;">💹 涨幅数据</h3>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">最高点涨幅:</strong> ${coin.gain_ratio.toFixed(2)}x (+${coin.gain_percent.toFixed(2)}%)</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">当前涨幅:</strong> ${coin.current_gain_ratio ? coin.current_gain_ratio.toFixed(2) : 'N/A'}x (+${coin.current_gain_percent ? coin.current_gain_percent.toFixed(2) : 'N/A'}%)</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">价格变化:</strong> $${coin.start_price.toFixed(6)} → $${coin.end_price.toFixed(6)}</p>
                            <p style="color: #e0e0e0;"><strong style="color: #bbb;">价格区间:</strong> 最低 <span style="color: #dc3545;">$${coin.min_price.toFixed(6)}</span>, 最高 <span style="color: #28a745;">$${coin.max_price.toFixed(6)}</span></p>
                        </div>
                        
                        ${coin.project_info ? `
                            <div style="margin-top: 20px; padding: 15px; background: #2b2b2b; border-radius: 8px; border: 1px solid #444;">
                                <h3 style="color: #17a2b8;">📋 项目详情</h3>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">完整名称:</strong> ${coin.project_info.name}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">市值排名:</strong> #${coin.project_info.market_cap_rank}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">技术赛道:</strong> <span style="color: #28a745;">${coin.project_info.categories.join(', ')}</span></p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">流通量:</strong> ${coin.project_info.circulating_supply.toLocaleString()}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">总供应量:</strong> ${coin.project_info.total_supply.toLocaleString()}</p>
                                
                                <h4 style="margin-top: 15px; color: #20c997;">社区活跃度</h4>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Twitter:</strong> ${coin.project_info.twitter_followers.toLocaleString()} 粉丝</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Reddit:</strong> ${coin.project_info.reddit_subscribers.toLocaleString()} 订阅者</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Telegram:</strong> ${coin.project_info.telegram_users.toLocaleString()} 用户</p>
                                
                                <h4 style="margin-top: 15px; color: #ffc107;">开发活跃度</h4>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">GitHub星标:</strong> ${coin.project_info.github_stars}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Forks:</strong> ${coin.project_info.github_forks}</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">最近4周提交:</strong> ${coin.project_info.github_commits_4w} 次</p>
                                <p style="color: #e0e0e0;"><strong style="color: #bbb;">Issues:</strong> ${coin.project_info.github_total_issues} (已关闭: ${coin.project_info.github_closed_issues})</p>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // 显示币种价格图表
        async function showCoinChart(symbol) {
            try {
                showStatus(`正在加载 ${symbol} 的历史图表...`, 'info');
                
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                
                const response = await safeFetch('/crypto_advanced/get_historical_chart', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbol: symbol,
                        start_date: startDate,
                        end_date: endDate || null,
                        interval: '1d'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayPriceChart(result.symbol, result.data);
                } else {
                    showStatus(`加载图表失败: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('加载图表失败:', error);
                showStatus(`加载图表失败: ${error.message}`, 'error');
            }
        }
        
        // 显示价格图表（使用Chart.js）
        function displayPriceChart(symbol, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = () => modal.remove();
            
            const chartContainer = document.createElement('div');
            chartContainer.style.cssText = 'background: #1a1a1a; padding: 30px; border-radius: 15px; width: 90%; max-width: 1200px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;';
            chartContainer.onclick = (e) => e.stopPropagation();
            
            chartContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; background: #1a1a1a; padding: 15px; border-radius: 8px;">
                    <h2 style="color: #e0e0e0; margin: 0;">${symbol} - 历史价格走势</h2>
                    <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">关闭</button>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px;">
                    <canvas id="priceChart" style="max-height: 500px;"></canvas>
                </div>
            `;
            
            modal.appendChild(chartContainer);
            document.body.appendChild(modal);
            
            // 绘制图表
            const ctx = document.getElementById('priceChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: '价格 (USD)',
                        data: data.prices,
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0',
                            borderColor: '#444',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: {
                                display: true,
                                text: '价格 (USD)',
                                color: '#e0e0e0'
                            }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: {
                                display: true,
                                text: '日期',
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }
        
        // 显示资金流向图表
        async function showMoneyFlowChart(symbol) {
            try {
                showStatus(`正在加载 ${symbol} 的资金流向图表...`, 'info');
                
                const startDate = document.getElementById('advStartDate').value;
                const endDate = document.getElementById('advEndDate').value;
                
                const response = await safeFetch('/crypto_advanced/get_money_flow_chart', {
                    method: 'POST',
                    body: JSON.stringify({
                        symbol: symbol,
                        start_date: startDate,
                        end_date: endDate || null
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayMoneyFlowChart(result.symbol, result.data);
                } else {
                    showStatus(`加载资金流向失败: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('加载资金流向失败:', error);
                showStatus(`加载资金流向失败: ${error.message}`, 'error');
            }
        }
        
        // 显示资金流向图表
        function displayMoneyFlowChart(symbol, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = () => modal.remove();
            
            const chartContainer = document.createElement('div');
            chartContainer.style.cssText = 'background: #1a1a1a; padding: 30px; border-radius: 15px; width: 90%; max-width: 1200px; max-height: 90vh; overflow-y: auto; border: 2px solid #444;';
            chartContainer.onclick = (e) => e.stopPropagation();
            
            chartContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; background: #2b2b2b; padding: 15px; border-radius: 8px;">
                    <h2 style="color: #e0e0e0; margin: 0;">${symbol} - 资金流向分析</h2>
                    <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">关闭</button>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <canvas id="moneyFlowChart" style="max-height: 400px;"></canvas>
                </div>
                <div style="background: #2b2b2b; padding: 20px; border-radius: 8px;">
                    <canvas id="obvChart" style="max-height: 300px;"></canvas>
                </div>
            `;
            
            modal.appendChild(chartContainer);
            document.body.appendChild(modal);
            
            // 资金流向图表
            const ctx1 = document.getElementById('moneyFlowChart').getContext('2d');
            new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: '每日资金流向',
                        data: data.money_flow,
                        backgroundColor: data.money_flow.map(v => v >= 0 ? 'rgba(40, 167, 69, 0.7)' : 'rgba(220, 53, 69, 0.7)'),
                        borderColor: data.money_flow.map(v => v >= 0 ? '#28a745' : '#dc3545'),
                        borderWidth: 1
                    }, {
                        label: '累计资金流',
                        data: data.cumulative_flow,
                        type: 'line',
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        tension: 0.4,
                        fill: false,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0'
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: { 
                                display: true, 
                                text: '每日资金流',
                                color: '#e0e0e0'
                            }
                        },
                        y1: {
                            position: 'right',
                            ticks: { color: '#e0e0e0' },
                            grid: { drawOnChartArea: false },
                            title: { 
                                display: true, 
                                text: '累计资金流',
                                color: '#e0e0e0'
                            }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
            
            // OBV图表
            const ctx2 = document.getElementById('obvChart').getContext('2d');
            new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                        label: 'OBV (能量潮)',
                        data: data.obv,
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(255, 193, 7, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0'
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#e0e0e0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        
        // 显示示例
        function showAdvancedExample() {
            alert(`示例说明：

📅 开始日期：2025-08-20
📅 结束日期：今天（默认自动填充）
🎯 最高点涨幅倍数：3（表示筛选期间最高点达到3倍的币种）

⚠️ 注意：涨幅计算使用期间最高价，不是当前价格！
例如：某币从$1涨到$5后回落至$2，算5倍涨幅✅

勾选选项：
✅ 包含项目详情 - 显示项目名称、描述、技术赛道、社交媒体、开发进度等
✅ 包含资金流向 - 显示每日资金流入流出、累计资金流向、OBV指标等

分析结果将包括：
• 涨幅排行榜
• 项目基本信息和分类
• GitHub代码提交记录
• Twitter/Reddit/Telegram社区数据
• 资金流向可视化图表
• 历史价格走势图

⚠️ 注意：完整分析需要较长时间（约3-5分钟），请耐心等待`);
        }
        
        // 显示失败记录
        function showFailedRecords() {
            if (!historicalAnalysisData || !historicalAnalysisData.failed_records) {
                showStatus('没有失败记录', 'info');
                return;
            }
            
            const failedRecords = historicalAnalysisData.failed_records;
            
            // 按失败原因分类
            const byReason = {};
            failedRecords.forEach(record => {
                if (!byReason[record.reason]) {
                    byReason[record.reason] = [];
                }
                byReason[record.reason].push(record);
            });
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center; overflow-y: auto;" onclick="this.remove()">
                    <div style="background: #1a1a1a; padding: 30px; border-radius: 15px; max-width: 900px; width: 90%; max-height: 90vh; overflow-y: auto; margin: 20px; border: 2px solid #444;" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ffc107; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #e0e0e0;">⚠️ 失败记录</h2>
                            <button onclick="this.closest('[style*=fixed]').remove()" class="btn btn-danger">关闭</button>
                        </div>
                        
                        <div style="background: #2b2b2b; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                            <strong style="color: #ffc107;">📊 统计概览</strong>
                            <div style="margin-top: 10px; color: #e0e0e0;">
                                <p>• 总分析数: ${historicalAnalysisData.total_analyzed} 个币种</p>
                                <p>• 成功数: ${historicalAnalysisData.qualified_count} 个</p>
                                <p>• 失败数: ${historicalAnalysisData.failed_count} 个</p>
                                <p>• 成功率: ${((historicalAnalysisData.total_analyzed - historicalAnalysisData.failed_count) / historicalAnalysisData.total_analyzed * 100).toFixed(1)}%</p>
                            </div>
                        </div>
            `;
            
            // 按失败原因分组显示
            Object.keys(byReason).forEach(reason => {
                const records = byReason[reason];
                const reasonColor = {
                    '无法获取历史数据': '#dc3545',
                    '部分数据获取失败': '#ffc107',
                    '分析异常': '#fd7e14'
                }[reason] || '#6c757d';
                
                html += `
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: ${reasonColor}; border-bottom: 2px solid ${reasonColor}; padding-bottom: 10px;">
                            ${reason} (${records.length}个)
                        </h3>
                        <div style="max-height: 200px; overflow-y: auto; background: #2b2b2b; padding: 15px; border-radius: 8px; margin-top: 10px; border: 1px solid #444;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #1a1a1a;">
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">序号</th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">币种</th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #555; color: #e0e0e0;">详细原因</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                records.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid #444;">
                            <td style="padding: 8px; color: #999;">${index + 1}</td>
                            <td style="padding: 8px;"><strong style="color: #e0e0e0;">${record.symbol}</strong></td>
                            <td style="padding: 8px; color: #bbb;">${record.detail}</td>
                        </tr>
                    `;
                });
                
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });
            
            // 添加导出功能
            html += `
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 2px solid #444;">
                    <button class="btn btn-info" onclick="exportFailedRecords()">
                        📥 导出失败记录（CSV）
                    </button>
                    <button class="btn btn-secondary" onclick="this.closest('[style*=fixed]').remove()" style="margin-left: 10px;">
                        关闭
                    </button>
                </div>
            `;
            
            html += '</div></div>';
            
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // 导出失败记录为CSV
        function exportFailedRecords() {
            if (!historicalAnalysisData || !historicalAnalysisData.failed_records) {
                showStatus('没有失败记录', 'error');
                return;
            }
            
            try {
                const failedRecords = historicalAnalysisData.failed_records;
                
                // 创建CSV内容
                let csv = '\uFEFF';  // UTF-8 BOM
                csv += '币种,失败原因,详细信息\n';
                
                failedRecords.forEach(record => {
                    csv += `${record.symbol},"${record.reason}","${record.detail}"\n`;
                });
                
                // 下载CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                link.setAttribute('href', url);
                link.setAttribute('download', `失败记录_${timestamp}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus(`成功导出 ${failedRecords.length} 条失败记录`, 'success');
                
            } catch (error) {
                console.error('导出失败记录失败:', error);
                showStatus(`导出失败: ${error.message}`, 'error');
            }
        }
        
        // ==================== 高级历史分析功能结束 ====================
        
    </script>
</body>
</html>
