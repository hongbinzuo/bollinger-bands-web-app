<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K线绘制（Lightweight Charts）</title>
  <link rel="stylesheet" href="/static/style.css" onerror="this.remove()">
  <style>
    body { font-family: Arial, sans-serif; background: #0f111a; color: #e5e5e5; margin: 0; }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px; }
    .grid { display: grid; grid-template-columns: 1.1fr 2fr; gap: 16px; }
    .card { background: #151826; border-radius: 8px; padding: 12px 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .card h3 { margin: 4px 0 12px; font-size: 16px; }
    textarea, input, select { width: 100%; background: #0f1320; color: #e5e5e5; border: 1px solid #2a2f45; border-radius: 6px; padding: 8px; }
    label { display: block; margin: 8px 0 4px; font-size: 13px; color: #aab; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .btn { background: #3b82f6; border: none; border-radius: 6px; color: white; padding: 8px 12px; cursor: pointer; }
    .btn.secondary { background: #64748b; }
    .btn.warn { background: #f59e0b; }
    .btn.danger { background: #ef4444; }
    .split { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .levels { max-height: 160px; overflow: auto; border: 1px dashed #2a2f45; padding: 6px; border-radius: 6px; }
    .level-item { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .level-item input { flex: 1; }
    #klineChart { height: 540px; position: relative; }
    .drag-tip { position: absolute; right: 8px; padding: 2px 6px; background: rgba(0,0,0,0.7); color: #fff; border-radius: 4px; font-size: 12px; pointer-events: none; display: none; }
    .muted { color: #9aa1b2; font-size: 12px; }
  </style>
  <script src="/static/vendor/lightweight-charts/lightweight-charts.standalone.production.min.js"></script>
</head>
<body>
  <div class="container">
    <h2>专业K线绘制（TradingView Lightweight Charts）</h2>
    <div class="grid">
      <div class="card">
        <h3>自然语言描述</h3>
        <textarea id="nlpInput" rows="6" placeholder="例：币种 $BTC，时间周期 4小时；支撑位：61200, 60000；阻力位：63500；备注：突破阻力加仓，回踩支撑减仓"></textarea>
        <div class="row" style="margin-top:8px;">
          <button class="btn" onclick="parseInput()">解析</button>
          <button class="btn secondary" onclick="clearAll()">清空</button>
        </div>

        <h3 style="margin-top:18px;">解析结果与调整</h3>
        <label>币种（现货，例如 BTCUSDT）：</label>
        <input id="symbolInput" value="BTCUSDT">
        <div class="split">
          <div>
            <label>时间周期</label>
            <select id="timeframeSelect">
              <option value="1d">1天</option>
              <option value="4h" selected>4小时</option>
              <option value="1h">1小时</option>
            </select>
          </div>
          <div>
            <label>数据源</label>
            <select id="sourceSelect">
              <option value="gate" selected>Gate.io</option>
              <option value="bybit">Bybit</option>
            </select>
          </div>
        </div>

        <div class="split" style="margin-top:8px;">
          <div>
            <label>支撑位（可编辑）</label>
            <div id="supportLevels" class="levels"></div>
            <div class="row">
              <input id="supportAdd" placeholder="输入价格后添加，如 61200">
              <button class="btn" onclick="addLevel('support')">添加支撑</button>
            </div>
          </div>
          <div>
            <label>阻力位（可编辑）</label>
            <div id="resistanceLevels" class="levels"></div>
            <div class="row">
              <input id="resistanceAdd" placeholder="输入价格后添加，如 63500">
              <button class="btn" onclick="addLevel('resistance')">添加阻力</button>
            </div>
          </div>
        </div>

        <label style="margin-top:8px;">备注</label>
        <input id="remarksInput" placeholder="示例：突破阻力加仓，回踩支撑减仓">

        <div class="row" style="margin-top:10px;">
          <button class="btn" onclick="drawChart()">绘制图表</button>
          <button class="btn warn" onclick="applyLevels()">应用水平线</button>
          <button class="btn secondary" onclick="toggleAutoRefresh()" id="autoBtn">开启自动刷新</button>
        </div>

        <h3 style="margin-top:16px;">保存 / 导入 / 导出</h3>
        <div class="row">
          <input id="saveName" placeholder="保存名称（可选）">
          <button class="btn" onclick="saveConfig()">保存到服务器</button>
          <button class="btn secondary" onclick="loadSavedList()">加载保存列表</button>
        </div>
        <div class="row">
          <button class="btn" onclick="exportConfigJSON()">导出配置(JSON)</button>
          <button class="btn secondary" onclick="exportLevelsCSV()">导出水平线(CSV)</button>
          <input type="file" id="importFile" accept="application/json" onchange="importConfigJSON(this)">
        </div>
        <div class="row">
          <button class="btn" onclick="exportChartPNG()">导出图表PNG</button>
        </div>
        <div id="savedList" class="levels" style="margin-top:6px;"></div>
        <div class="row">
          <label>刷新秒数</label>
          <input id="refreshSec" type="number" min="5" max="300" value="30">
          <div class="muted">自动刷新仅更新K线数据，不修改已绘制的水平线</div>
        </div>
        <div class="row" style="margin-top:8px;">
          <label>点击添加：</label>
          <select id="clickMode">
            <option value="none" selected>关闭</option>
            <option value="support">支撑</option>
            <option value="resistance">阻力</option>
          </select>
          <div class="muted">在图表上点击可添加对应价位</div>
        </div>
      </div>

      <div class="card">
        <h3>实时图表</h3>
        <div id="klineChart"></div>
        <div class="muted" id="status"></div>
      </div>
    </div>
  </div>

  <script>
    let lwcChart, candleSeries;
    let supportLines = [];
    let resistanceLines = [];
    let autoTimer = null;
    let dragState = { active: false, kind: null, idx: -1, suppressClick: false, lastTs: 0 };
    let dragHandlersBound = false;
    let dragTipEl = null;

    function setStatus(msg, type='info') {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.color = type === 'error' ? '#ef4444' : (type === 'warn' ? '#f59e0b' : '#9aa1b2');
    }

    function initChart() {
      if (lwcChart) return;
      if (!window.LightweightCharts || typeof LightweightCharts.createChart !== 'function') {
        setStatus('K线库未加载，请刷新页面或检查 /static/vendor/lightweight-charts 路径', 'error');
        return;
      }
      lwcChart = LightweightCharts.createChart(document.getElementById('klineChart'), {
        layout: { background: { color: '#0f111a' }, textColor: '#e5e5e5' },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderVisible: false },
        timeScale: { borderVisible: false },
        grid: { vertLines: { color: '#1f2335' }, horzLines: { color: '#1f2335' } },
      });
      candleSeries = lwcChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', wickUpColor: '#26a69a', wickDownColor: '#ef5350', borderVisible: false });

      lwcChart.subscribeClick(param => {
        if (dragState.suppressClick) { dragState.suppressClick = false; return; }
        const mode = document.getElementById('clickMode').value;
        if (!param || !param.point || mode === 'none') return;
        const price = candleSeries.coordinateToPrice(param.point.y);
        if (!price || isNaN(price)) return;
        if (mode === 'support') {
          pushLevel('support', price);
        } else if (mode === 'resistance') {
          pushLevel('resistance', price);
        }
      });

      bindDragHandlers();
      dragTipEl = document.createElement('div');
      dragTipEl.className = 'drag-tip';
      document.getElementById('klineChart').appendChild(dragTipEl);
    }

    function bindDragHandlers() {
      if (dragHandlersBound) return;
      const el = document.getElementById('klineChart');
      const onDown = (e) => {
        const rect = el.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const hit = hitTestLine(y);
        if (hit) {
          dragState.active = true;
          dragState.kind = hit.kind;
          dragState.idx = hit.idx;
          dragState.suppressClick = true;
          e.preventDefault();
          if (dragTipEl) { dragTipEl.style.display = 'block'; dragTipEl.style.top = `${y - 10}px`; }
        }
      };
      const onMove = (e) => {
        if (!dragState.active) return;
        const now = performance.now();
        if (now - dragState.lastTs < 25) return; // throttle
        dragState.lastTs = now;
        const rect = el.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const price = candleSeries.coordinateToPrice(y);
        if (!price || isNaN(price) || price <= 0) return;
        const snapped = snapPrice(price);
        updateLineAt(dragState.kind, dragState.idx, snapped);
        if (dragTipEl) { dragTipEl.style.display = 'block'; dragTipEl.style.top = `${y - 10}px`; dragTipEl.textContent = fmtPrice(snapped); }
      };
      const onUp = () => {
        if (dragState.active) {
          dragState.active = false;
          // 结束后刷新侧边列表，反映新价格
          sortAndDedup('support');
          sortAndDedup('resistance');
          renderLevels('supportLevels','support',supports);
          renderLevels('resistanceLevels','resistance',resistances);
          applyLevels();
        }
        if (dragTipEl) dragTipEl.style.display = 'none';
      };
      el.addEventListener('mousedown', onDown);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
      dragHandlersBound = true;
    }

    function hitTestLine(y) {
      const tol = 6; // px tolerance
      let best = null;
      // supports first
      supports.forEach((p, i) => {
        const py = candleSeries.priceToCoordinate(p);
        if (py == null) return;
        const d = Math.abs(py - y);
        if (d <= tol && (!best || d < best.d)) best = { kind: 'support', idx: i, d };
      });
      resistances.forEach((p, i) => {
        const py = candleSeries.priceToCoordinate(p);
        if (py == null) return;
        const d = Math.abs(py - y);
        if (d <= tol && (!best || d < best.d)) best = { kind: 'resistance', idx: i, d };
      });
      return best;
    }

    function updateLineAt(kind, idx, newPrice) {
      if (kind === 'support') {
        supports[idx] = newPrice;
        if (supportLines[idx]) { try { candleSeries.removePriceLine(supportLines[idx]); } catch(_){} }
        supportLines[idx] = candleSeries.createPriceLine({ price: newPrice, color: '#10b981', lineWidth: 2, lineStyle: 2, title: `S ${fmtPrice(newPrice)}` });
      } else {
        resistances[idx] = newPrice;
        if (resistanceLines[idx]) { try { candleSeries.removePriceLine(resistanceLines[idx]); } catch(_){} }
        resistanceLines[idx] = candleSeries.createPriceLine({ price: newPrice, color: '#ef4444', lineWidth: 2, lineStyle: 2, title: `R ${fmtPrice(newPrice)}` });
      }
    }

    function fmtPrice(x) {
      const v = Number(x);
      if (!isFinite(v)) return '';
      if (v >= 100) return v.toFixed(2);
      if (v >= 1) return v.toFixed(4);
      if (v >= 0.01) return v.toFixed(6);
      return v.toFixed(8);
    }
    
    function sortAndDedup(kind) {
      const eps = 1e-8;
      if (kind === 'support') {
        let pairs = supports.map((p,i)=>({p, label: supportsLabels[i]||''}));
        pairs.sort((a,b)=>a.p-b.p);
        const out = []; const labs=[];
        pairs.forEach(it => {
          if (out.length===0 || Math.abs(it.p - out[out.length-1]) > eps) { out.push(it.p); labs.push(it.label); }
        });
        supports = out; supportsLabels = labs;
      } else {
        let pairs = resistances.map((p,i)=>({p, label: resistancesLabels[i]||''}));
        pairs.sort((a,b)=>a.p-b.p);
        const out = []; const labs=[];
        pairs.forEach(it => {
          if (out.length===0 || Math.abs(it.p - out[out.length-1]) > eps) { out.push(it.p); labs.push(it.label); }
        });
        resistances = out; resistancesLabels = labs;
      }
    }

    function msToLwc(rows) {
      return rows.map(r => ({ time: Math.floor((r.t || r.timestamp) / 1000), open: r.open, high: r.high, low: r.low, close: r.close }));
    }

    async function loadSeries(symbol, timeframe, source) {
      try {
        setStatus(`加载 ${symbol} ${timeframe} (${source})...`);
        const resp = await fetch('/realtime-fib/api/analyze', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol, timeframe, source, include_series: true })
        });
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || '加载失败');
        const series = data.result.series || [];
        if (!candleSeries) { setStatus('图表未初始化', 'error'); return; }
        candleSeries.setData(msToLwc(series));
        setStatus(`已加载：${data.result.symbol} / ${data.result.timeframe} / 源 ${data.result.source}`);
      } catch (e) {
        console.error(e);
        setStatus(`加载失败：${e.message}`, 'error');
      }
    }

    function renderLevels(containerId, kind, arr) {
      const el = document.getElementById(containerId);
      el.innerHTML = '';
      arr.forEach((v, idx) => {
        const item = document.createElement('div');
        item.className = 'level-item';
        const label = document.createElement('input');
        label.placeholder = (kind === 'support' ? `S${idx+1}` : `R${idx+1}`);
        label.value = (kind === 'support' ? (supportsLabels[idx] || '') : (resistancesLabels[idx] || ''));
        label.onchange = () => {
          if (kind === 'support') supportsLabels[idx] = label.value.trim();
          else resistancesLabels[idx] = label.value.trim();
          applyLevels();
        };
        const inp = document.createElement('input');
        inp.type = 'number';
        inp.step = '0.00000001';
        inp.value = Number(v).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
        inp.onchange = () => { arr[idx] = parseFloat(inp.value); applyLevels(); };
        const del = document.createElement('button');
        del.className = 'btn danger';
        del.textContent = '删除';
        del.onclick = () => { arr.splice(idx,1); if (kind==='support') supportsLabels.splice(idx,1); else resistancesLabels.splice(idx,1); renderLevels(containerId, kind, arr); applyLevels(); };
        item.appendChild(label);
        item.appendChild(inp);
        item.appendChild(del);
        el.appendChild(item);
      });
    }

    function pushLevel(kind, price) {
      const p = parseFloat(price);
      if (!p || isNaN(p)) return;
      if (kind === 'support') {
        supports.push(snapPrice(p));
        supportsLabels.push('');
        sortAndDedup('support');
        renderLevels('supportLevels','support',supports);
      } else {
        resistances.push(snapPrice(p));
        resistancesLabels.push('');
        sortAndDedup('resistance');
        renderLevels('resistanceLevels','resistance',resistances);
      }
      applyLevels();
    }

    function addLevel(kind) {
      const id = kind === 'support' ? 'supportAdd' : 'resistanceAdd';
      const val = parseFloat(document.getElementById(id).value);
      if (!val || isNaN(val)) return;
      pushLevel(kind, val);
      document.getElementById(id).value = '';
    }

    function clearPriceLines(lines) {
      if (!lines) return;
      if (!candleSeries) return;
      lines.forEach(l => { try { candleSeries.removePriceLine(l); } catch(_){} });
      lines.length = 0;
    }

    function applyLevels() {
      initChart();
      if (!candleSeries) return;
      clearPriceLines(supportLines);
      clearPriceLines(resistanceLines);
      // 绘制支撑（绿色）
      supports.forEach((p, i) => {
        const lab = (supportsLabels[i] && supportsLabels[i].trim()) || `S${i+1}`;
        const line = candleSeries.createPriceLine({ price: p, color: '#10b981', lineWidth: 2, lineStyle: 2, title: `${lab} ${fmtPrice(p)}` });
        supportLines.push(line);
      });
      // 绘制阻力（红色）
      resistances.forEach((p, i) => {
        const lab = (resistancesLabels[i] && resistancesLabels[i].trim()) || `R${i+1}`;
        const line = candleSeries.createPriceLine({ price: p, color: '#ef4444', lineWidth: 2, lineStyle: 2, title: `${lab} ${fmtPrice(p)}` });
        resistanceLines.push(line);
      });
    }

    function drawChart() {
      initChart();
      const symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
      const timeframe = document.getElementById('timeframeSelect').value;
      const source = document.getElementById('sourceSelect').value;
      loadSeries(symbol, timeframe, source);
      applyLevels();
    }

    async function saveConfig() {
      try {
        const symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
        const timeframe = document.getElementById('timeframeSelect').value;
        const source = document.getElementById('sourceSelect').value;
        const name = document.getElementById('saveName').value.trim();
        const payload = { name, symbol, timeframe, source, supports, resistances, supports_labels: supportsLabels, resistances_labels: resistancesLabels, remarks: document.getElementById('remarksInput').value.trim() };
        const resp = await fetch('/kline-draw/api/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || '保存失败');
        setStatus(`已保存：${data.id}`);
        loadSavedList();
      } catch (e) {
        setStatus(`保存失败：${e.message}`, 'error');
      }
    }

    async function loadSavedList() {
      try {
        const symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
        const resp = await fetch('/kline-draw/api/list?symbol=' + encodeURIComponent(symbol));
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || '加载失败');
        const list = data.items || [];
      const el = document.getElementById('savedList');
      el.innerHTML = '';
      list.forEach(item => {
        const row = document.createElement('div');
        row.className = 'level-item';
        const txt = document.createElement('div');
        txt.textContent = `${item.name || '(未命名)'} · ${item.symbol} ${item.timeframe} · ${new Date(item.created_at).toLocaleString()} `;
        const loadBtn = document.createElement('button');
        loadBtn.className = 'btn'; loadBtn.textContent = '载入';
        loadBtn.onclick = () => applySaved(item);
        const delBtn = document.createElement('button');
        delBtn.className = 'btn danger'; delBtn.textContent = '删除';
        delBtn.onclick = () => deleteSaved(item.id);
        row.appendChild(txt); row.appendChild(loadBtn); row.appendChild(delBtn);
        el.appendChild(row);
      });
        setStatus(`已加载保存项：${list.length} 条`);
      } catch (e) {
        setStatus(`加载保存列表失败：${e.message}`, 'error');
      }
    }

    async function deleteSaved(id) {
      if (!id) return;
      try {
        const resp = await fetch('/kline-draw/api/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id }) });
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || '删除失败');
        loadSavedList();
      } catch (e) { setStatus(`删除失败：${e.message}`, 'error'); }
    }

    function applySaved(item) {
      document.getElementById('symbolInput').value = (item.symbol || 'BTCUSDT');
      document.getElementById('timeframeSelect').value = (item.timeframe || '4h');
      document.getElementById('sourceSelect').value = (item.source || 'gate');
      document.getElementById('remarksInput').value = (item.remarks || '');
      supports = (item.supports || []).slice().sort((a,b)=>a-b);
      resistances = (item.resistances || []).slice().sort((a,b)=>a-b);
      renderLevels('supportLevels','support',supports);
      renderLevels('resistanceLevels','resistance',resistances);
      drawChart();
    }

    function exportConfigJSON() {
      const obj = {
        symbol: document.getElementById('symbolInput').value.trim().toUpperCase(),
        timeframe: document.getElementById('timeframeSelect').value,
        source: document.getElementById('sourceSelect').value,
        supports, resistances,
        remarks: document.getElementById('remarksInput').value.trim(),
      };
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `kline_config_${obj.symbol}_${obj.timeframe}_${ts}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      setStatus('已导出配置 JSON');
    }

    function exportChartPNG() {
      try {
        initChart();
        if (!lwcChart) { setStatus('图表未初始化', 'error'); return; }
        const symbol = (document.getElementById('symbolInput').value || 'SYMBOL').toUpperCase();
        const timeframe = document.getElementById('timeframeSelect').value || 'tf';
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        const filename = `kline_${symbol}_${timeframe}_${ts}.png`;

        // 优先使用库自带截图（包含价格轴与时间轴）
        if (typeof lwcChart.takeScreenshot === 'function') {
          const cnv = lwcChart.takeScreenshot();
          const url = cnv.toDataURL('image/png');
          triggerDownload(url, filename);
          setStatus('已导出图表 PNG');
          return;
        }
        // 兼容方案：将容器内所有 canvas 叠加到临时画布
        const box = document.getElementById('klineChart');
        const canvases = box.querySelectorAll('canvas');
        if (!canvases || canvases.length === 0) throw new Error('未找到图表画布');
        // 使用第一个画布的内部分辨率
        const w = canvases[0].width, h = canvases[0].height;
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const ctx = off.getContext('2d');
        canvases.forEach(c => { try { ctx.drawImage(c, 0, 0); } catch(_){} });
        const url = off.toDataURL('image/png');
        triggerDownload(url, filename);
        setStatus('已导出图表 PNG');
      } catch (e) {
        console.error(e);
        setStatus('导出图表失败：' + e.message, 'error');
      }
    }

    function triggerDownload(url, filename) {
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.style.display = 'none';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    function exportLevelsCSV() {
      const lines = ['kind,label,price'];
      supports.forEach((p,i) => lines.push(`support,${(supportsLabels[i]||'')},${p}`));
      resistances.forEach((p,i) => lines.push(`resistance,${(resistancesLabels[i]||'')},${p}`));
      const blob = new Blob(['\uFEFF' + lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'levels.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      setStatus('已导出水平线 CSV');
    }

    function importConfigJSON(input) {
      const file = input.files && input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const obj = JSON.parse(reader.result);
          applySaved(obj);
          setStatus('已导入配置');
        } catch (e) { setStatus('导入失败：' + e.message, 'error'); }
      };
      reader.readAsText(file);
      input.value = '';
    }

    function parseNumbers(str) {
      if (!str) return [];
      return (str.match(/[-+]?[0-9]*\.?[0-9]+/g) || []).map(x => parseFloat(x)).filter(x => !isNaN(x));
    }

    function parseInput() {
      const text = document.getElementById('nlpInput').value.trim();
      if (!text) return;
      // 币种：$BTC / 币种 BTC / 币种: BTCUSDT / 直接出现 BTCUSDT
      let sym = null;
      const m1 = text.match(/\$([A-Za-z]{2,10})/);
      if (m1) sym = m1[1] + (m1[1].endsWith('USDT') ? '' : 'USDT');
      const m2 = text.match(/币种[：: ]*([A-Za-z]{2,15})/);
      if (!sym && m2) {
        const raw = m2[1].toUpperCase();
        sym = raw.endsWith('USDT') ? raw : (raw + 'USDT');
      }
      const m3 = text.match(/([A-Z]{2,15}USDT)/);
      if (!sym && m3) sym = m3[1].toUpperCase();
      if (!sym) sym = 'BTCUSDT';
      document.getElementById('symbolInput').value = sym;

      // 时间周期
      let tf = '4h';
      if (/1\s*天|日线|\b1d\b/i.test(text)) tf = '1d';
      else if (/4\s*小时|\b4h\b/i.test(text)) tf = '4h';
      else if (/1\s*小时|\b1h\b/i.test(text)) tf = '1h';
      document.getElementById('timeframeSelect').value = tf;

      // 支撑/阻力
      const sMatch = text.match(/支撑位[：:]?([^；。\n]*)/);
      const rMatch = text.match(/阻力位[：:]?([^；。\n]*)/);
      supports = parseNumbers(sMatch ? sMatch[1] : '').sort((a,b)=>a-b);
      resistances = parseNumbers(rMatch ? rMatch[1] : '').sort((a,b)=>a-b);
      renderLevels('supportLevels','support',supports);
      renderLevels('resistanceLevels','resistance',resistances);

      // 备注
      const note = (text.match(/备注[：:](.*)$/) || [])[1] || '';
      document.getElementById('remarksInput').value = note.trim();
    }

    function toggleAutoRefresh() {
      const btn = document.getElementById('autoBtn');
      if (autoTimer) {
        clearInterval(autoTimer); autoTimer = null; btn.textContent = '开启自动刷新'; setStatus('自动刷新关闭'); return;
      }
      const sec = Math.max(5, parseInt(document.getElementById('refreshSec').value || '30', 10));
      const symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
      const timeframe = document.getElementById('timeframeSelect').value;
      const source = document.getElementById('sourceSelect').value;
      autoTimer = setInterval(() => loadSeries(symbol, timeframe, source), sec * 1000);
      btn.textContent = '关闭自动刷新';
      setStatus(`自动刷新中，每 ${sec}s 更新一次`);
    }

    function clearAll() {
      document.getElementById('nlpInput').value = '';
      supports = []; resistances = [];
      renderLevels('supportLevels','support',supports);
      renderLevels('resistanceLevels','resistance',resistances);
      applyLevels();
      setStatus('');
    }

    // 内部状态：水平线集合
    let supports = [];
    let resistances = [];
    let supportsLabels = [];
    let resistancesLabels = [];

    window.addEventListener('load', () => {
      initChart();
      // 默认加载 BTC 4h Gate
      drawChart();
    });
  </script>
</body>
</html>
